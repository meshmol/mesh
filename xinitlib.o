(38 (normal system) ((import (normal compile) (scheme base) (scheme write)) (export pair-length last butlast sys-code sys-env sys-timer-set sys-timer-get sys-timer-gbc primitive-name? macroexpand-1 macroexpand addr entity-addr undefined step vm2-step vm1 vm2 dump addr-prt room macro-name? hygienic-name? gensym error flush sys-set-trace sys-set-untrace transfer debug profiler current-module sys-cont-room make-syntactic-closure symbol->identifier identifier->symbol syntactic-closure? identifier? identifier-bind! identifier-free? identifier-bound? identifier-bound global-bound? inspect lambda/asm)) 2 (normal system) 1)
(38 (normal compile) ((export compile assemble compile-file let let* cond letrec do case map)) 2 (normal compile) 1)
(38 (scheme base) ((import (normal system) (normal compile)) (export car cdr cons caar cdar cddr cadr caaar cdaar cadar caadr cddar caddr cdadr cdddr caaaar cdaaar cadaar caadar caaadr cddaar caddar caaddr cdaadr cdadar cadddr cdaddr cddadr cdddar cddddr assq assv assoc memq memv member reverse reverse! list-tail list-ref append append! set-car! set-cdr! list length newline write-char null? list? pair? atom? eq? eqv? equal? boolean? procedure? number? integer? real? rational? complex? exact? inexact? symbol? string? char? bignum? vector? macro? zero? + - * / < <= > >= = expt not odd? even? floor ceiling truncate round numerator denominator positive? negative? abs max min exact->inexact inexact->exact remainder modulo quotient gcd lcm string-append number->string string->number string=? string>? string>=? string<? string<=? string-ci=? string-ci>? string-ci>=? string-ci<? string-ci<=? string->symbol symbol->string string-length make-string string string-ref string-set! substring string->list list->string string-copy string-fill! make-vector vector-set! vector vector-ref vector-length vector-fill! vector->list list->vector open-input-file open-output-file close-input-port close-output-port eof-object? input-port? output-port? current-input-port current-output-port read-char peek-char char-ready? exit apply gbc eval values let let* cond letrec do case map for-each) (begin (define for-each (lambda (f ls . more) (do ((ls ls (cdr ls)) (more more (map cdr more))) ((null? ls)) (apply f (car ls) (map car more))) (undefined))))) 2 (scheme base) 1)
(38 (scheme inexact) ((export sin cos tan asin acos atan log exp sqrt)) 2 (scheme inexact) 1)
(38 (scheme complex) ((export real-part imag-part magnitude angle make-rectangular make-polar)) 2 (scheme complex) 1)
(38 (scheme load) ((export load)) 2 (scheme load) 1)
(38 (scheme read) ((export read)) 2 (scheme read) 1)
(38 (scheme write) ((export display write)) 2 (scheme write) 1)
(38 (scheme char) ((export char=? char>? char>=? char<? char<=? char-ci=? char-ci>? char-ci>=? char-ci<? char-ci<=? char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case? char->integer integer->char char-upcase char-downcase)) 2 (scheme char) 1)
(38 (scheme lazy) ((export delay force) (import (scheme base)) (begin (define-macro delay (lambda (expr) (cons 'make-promise (cons (cons 'lambda (cons '() (cons expr '()))) '())))) (define make-promise (lambda (p) (let ((val #f) (set? #f)) (lambda () (if (not set?) (let ((x (p))) (if (not set?) (begin (set! val x) (set! set? #t)) '())) '()) val)))) (define force (lambda (x) (if (procedure? x) (x) x))))) 2 (scheme lazy) 1)
(38 (scheme time) ((import (normal system) (scheme base) (scheme write)) (export time) (begin (define-macro time (lambda (expr) (cons 'begin (cons (cons 'gbc '()) (cons (cons 'sys-timer-set '()) (cons (cons 'display (cons expr '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"total " '())) (cons (cons 'display (cons (cons 'sys-timer-get '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"GC    " '())) (cons (cons 'display (cons (cons 'sys-timer-gbc '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) '()))))))))))))))))) 2 (scheme time) 1)
(38 (scheme file) ((export call-with-input-file call-with-output-file with-input-from-file with-output-to-file) (begin (define (call-with-input-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc p))) (close-input-port p) v))) (define (call-with-output-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc p))) (close-output-port p) v))) (define (with-input-from-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc))) (close-input-port p) v))) (define (with-output-to-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc))) (close-output-port p) v))))) 2 (scheme file) 1)
(40 ((scheme base)) 1)
(40 ((scheme load)) 1)
(40 ((scheme write)) 1)
(40 ((scheme read)) 1)
