(2 () 18 hygienic 1)
(15 1 (12 1 2 () 6 hygienic 7 3 0 0 4 inner-transfer 13 1 2 () 2 #t 2 #t 2 #f 2 #f 2 #t 2 #f 4 comp 13 8 2 halt 17 list 1 17 list 1 17 append 2 11) 18 compile 1)
(15 8 (12 8 3 0 0 17 null? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 boolean? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 symbol? 1 10 22 3 0 0 3 0 1 3 0 2 3 0 3 3 0 5 4 comp-var 13 5 11 3 0 0 17 syntactic-closure? 1 10 22 3 0 0 3 0 1 3 0 2 3 0 3 3 0 5 4 comp-var 13 5 11 3 0 0 17 atom? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 vector? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 bytevector? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 34 17 macro-name? 1 10 34 3 0 0 17 macroexpand-1 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 17 hygienic-name? 1 10 34 3 0 0 17 macroexpand-1 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 2 quote 17 eqv? 2 10 34 3 0 0 2 1 2 1 4 args-count-check 13 3 7 3 0 0 17 cadr 1 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 34 2 quasiquote 17 eqv? 2 10 38 3 0 0 17 cadr 1 4 macro-transfer 13 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 2 begin 17 eqv? 2 10 32 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-begin 13 8 11 3 0 0 34 2 set! 17 eqv? 2 10 111 3 0 0 2 2 2 2 4 args-count-check 13 3 7 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 3 0 0 17 cadr 1 3 0 1 4 gen-set 13 2 3 0 2 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 0 3 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 13 4 11 3 0 0 34 2 if 17 eqv? 2 10 82 3 0 0 17 length 1 2 3 21 10 16 3 0 0 2 ((undefined)) 17 append 2 5 0 0 7 8 2 3 0 0 2 3 2 3 4 args-count-check 13 3 7 3 0 0 17 cadr 1 3 0 0 17 caddr 1 3 0 0 17 cadddr 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 2 #t 4 comp-if 13 10 11 3 0 0 34 2 lambda 17 eqv? 2 10 41 3 0 2 10 33 3 0 0 17 cadr 1 3 0 0 17 cddr 1 3 0 1 3 0 6 3 0 7 4 comp-lambda 13 5 15 1 (12 1 2 fn 3 1 0 17 cadr 1 4 args-count 13 1 3 0 0 4 gen 13 3 3 1 3 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2) 13 1 11 2 #f 11 3 0 0 34 2 define 17 eqv? 2 10 77 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 2 1 15 1 (12 1 3 0 0 17 primitive-name? 1 17 not 1 11) 2 "can't overwrite primitive name " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 2 def 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 define-macro 17 eqv? 2 10 61 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 2 #f 3 0 7 4 comp 13 8 2 defm 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 define-syntax 17 eqv? 2 10 61 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 2 #f 3 0 7 4 comp 13 8 2 def 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 define-library 17 eqv? 2 10 63 3 0 0 2 2 2 infinity 4 args-count-check 13 3 7 3 0 0 2 1 4 list? 2 "require list for library name" 4 args-type-check 13 4 7 2 deflib 3 0 0 17 cadr 1 3 0 0 17 cddr 1 4 gen 13 3 2 const 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 let-syntax 17 eqv? 2 10 48 15 1 (12 1 3 0 0 34 3 0 0 17 cadr 1 3 1 1 2 #t 2 #t 2 #f 2 #f 2 #t 2 #f 4 comp 13 8 2 pause 4 gen 13 1 4 seq 13 2 4 assemble 13 1 17 vm1 1 36 4 hygienic 36 6 hygienic 11) 3 0 0 17 cadr 1 4 for-each 13 2 7 3 0 0 17 cddr 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-begin 13 8 11 3 0 0 34 2 letrec-syntax 17 eqv? 2 10 48 15 1 (12 1 3 0 0 34 3 0 0 17 cadr 1 3 1 1 2 #t 2 #t 2 #f 2 #f 2 #t 2 #f 4 comp 13 8 2 pause 4 gen 13 1 4 seq 13 2 4 assemble 13 1 17 vm1 1 36 4 hygienic 36 6 hygienic 11) 3 0 0 17 cadr 1 4 for-each 13 2 7 3 0 0 17 cddr 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-begin 13 8 11 3 0 0 34 4 hygienic 17 assv 2 10 46 3 0 0 3 0 0 34 4 hygienic 17 assv 2 35 17 get-car 1 13 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 2 export 17 eqv? 2 10 29 3 0 0 2 1 2 infinity 4 args-count-check 13 3 7 2 explib 3 0 0 35 4 gen 13 2 4 seq 13 1 11 3 0 0 34 2 import 17 eqv? 2 10 29 3 0 0 2 1 2 infinity 4 args-count-check 13 3 7 2 implib 3 0 0 35 4 gen 13 2 4 seq 13 1 11 3 0 0 34 2 math 17 eqv? 2 10 36 3 0 0 35 4 infix->prefix 13 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 2 syntax-rules 17 eqv? 2 10 94 2 lambda 2 expr 2 () 36 2 expand 2 quote 3 0 0 17 cddr 1 2 () 36 36 2 expr 2 quote 3 0 0 17 cadr 1 2 () 36 36 2 quote 3 0 1 2 () 36 36 2 () 36 36 36 36 36 2 () 36 36 36 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 2 defh 4 gen 13 1 4 seq 13 2 11 3 0 0 34 2 syntax-error 17 eqv? 2 10 12 4 error 3 0 0 35 17 apply 2 11 3 0 0 34 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-funcall 13 9 11) 18 comp 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 atom? 1 10 11 2 quote 3 0 0 17 list 2 11 3 0 0 17 pair? 1 10 13 3 0 0 34 2 unquote 17 eqv? 2 8 4 2 #f 10 9 3 0 0 17 cadr 1 11 3 0 0 17 pair? 1 10 28 3 0 0 34 17 pair? 1 10 15 3 0 0 17 caar 1 2 unquote 17 eqv? 2 8 4 2 #f 8 4 2 #f 10 22 2 cons 3 0 0 17 cadar 1 3 0 0 35 4 macro-transfer 13 1 17 list 3 11 3 0 0 17 pair? 1 10 28 3 0 0 34 17 pair? 1 10 15 3 0 0 17 caar 1 2 unquote-splicing 17 eqv? 2 8 4 2 #f 8 4 2 #f 10 22 2 append 3 0 0 17 cadar 1 3 0 0 35 4 macro-transfer 13 1 17 list 3 11 2 cons 3 0 0 34 4 macro-transfer 13 1 3 0 0 35 4 macro-transfer 13 1 17 list 3 11) 18 macro-transfer 1)
(15 1 (12 1 3 0 0 4 define? 13 1 10 15 3 0 0 4 formal-define 13 1 15 1 (12 1 3 0 0 34 3 0 0 17 cadr 1 3 0 0 17 caddr 1 4 inner-transfer1 13 1 17 list 3 11) 13 1 11 3 0 0 4 inner-transfer1 13 1 11) 18 inner-transfer 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 17 pair? 1 10 13 3 0 0 17 list? 1 17 not 1 8 4 2 #f 10 6 3 0 0 11 3 0 0 34 2 quote 17 eqv? 2 10 6 3 0 0 11 3 0 0 34 2 lambda 17 eqv? 2 10 31 3 0 0 34 3 0 0 17 cadr 1 4 inner-transfer1 3 0 0 17 cddr 1 4 inner-transfer2 13 1 4 map 13 2 36 36 11 3 0 0 34 2 let 17 eqv? 2 10 16 3 0 0 17 cadr 1 17 atom? 1 17 not 1 8 4 2 #f 10 31 3 0 0 34 3 0 0 17 cadr 1 4 inner-transfer1 3 0 0 17 cddr 1 4 inner-transfer2 13 1 4 map 13 2 36 36 11 3 0 0 34 2 letrec 17 eqv? 2 10 31 3 0 0 34 3 0 0 17 cadr 1 4 inner-transfer1 3 0 0 17 cddr 1 4 inner-transfer2 13 1 4 map 13 2 36 36 11 3 0 0 34 2 let* 17 eqv? 2 10 31 3 0 0 34 3 0 0 17 cadr 1 4 inner-transfer1 3 0 0 17 cddr 1 4 inner-transfer2 13 1 4 map 13 2 36 36 11 3 0 0 34 4 inner-transfer1 3 0 0 35 4 map 13 2 36 11) 18 inner-transfer1 1)
(15 1 (12 1 3 0 0 4 separate 13 1 15 1 (12 1 3 0 0 34 17 null? 1 10 7 3 0 0 35 11 2 letrec 3 0 0 34 17 reverse 1 3 0 0 35 36 36 17 list 1 11) 13 1 11) 18 inner-transfer2 1)
(15 1 (12 1 3 0 0 2 () 4 separate1 13 2 11) 18 separate 1)
(15 2 (12 2 3 0 0 17 pair? 1 10 12 3 0 0 34 4 define? 13 1 8 4 2 #f 10 16 3 0 0 34 4 formal-define 13 1 15 1 (12 1 3 1 0 35 3 0 0 17 cadr 1 3 0 0 17 caddr 1 4 inner-transfer1 13 1 17 list 2 3 1 1 36 4 separate1 14 2) 13 1 11 3 0 1 3 0 0 36 11) 18 separate1 1)
(15 1 (12 1 3 0 0 17 list? 1 10 12 3 0 0 34 2 define 17 eqv? 2 11 2 #f 11) 18 define? 1)
(15 1 (12 1 3 0 0 17 cadr 1 17 symbol? 1 10 6 3 0 0 11 3 0 0 34 3 0 0 17 caadr 1 2 lambda 3 0 0 17 cdadr 1 3 0 0 17 cddr 1 36 36 17 list 3 11) 18 formal-define 1)
(15 4 (12 4 3 0 1 10 42 2 const 3 0 0 4 gen 13 2 3 0 2 17 not 1 10 7 3 0 3 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2 2 () 11) 18 comp-const 1)
(15 5 (12 5 3 0 2 10 43 3 0 0 3 0 1 4 gen-var 13 2 3 0 3 17 not 1 10 7 3 0 4 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2 2 () 11) 18 comp-var 1)
(15 8 (12 8 3 0 0 17 null? 1 10 17 2 () 3 0 2 3 0 3 3 0 5 4 comp-const 14 4 3 0 0 4 length=1? 13 1 10 34 3 0 0 34 4 inner-transfer 13 1 3 0 1 3 0 2 2 #f 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 14 8 3 0 0 34 4 inner-transfer 13 1 3 0 1 2 #f 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-begin 13 8 4 seq 14 2) 18 comp-begin 1)
(15 6 (12 6 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 34 3 0 1 2 #t 2 #t 3 0 2 3 0 3 3 0 4 3 0 5 4 comp 13 8 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 4 comp-list 13 6 4 seq 14 2) 18 comp-list 1)
(15 10 (12 10 3 0 0 17 not 1 10 31 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 11 3 0 0 17 atom? 1 10 28 3 0 0 17 symbol? 1 17 not 1 10 13 3 0 0 17 not 1 17 not 1 8 4 2 #f 8 4 2 #f 10 31 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 11 3 0 0 17 list? 1 10 27 3 0 0 35 4 length=1? 13 1 10 13 3 0 0 34 2 not 17 eq? 2 8 4 2 #f 8 4 2 #f 10 40 3 0 0 17 cadr 1 3 0 2 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp-if 13 10 11 3 0 0 3 0 3 2 #t 2 #t 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 15 3 (12 3 3 0 1 3 0 2 17 equal? 2 10 36 3 1 0 3 1 3 2 #f 2 #t 3 1 6 3 1 7 3 1 8 3 1 9 4 comp 13 8 3 0 2 4 seq 13 2 11 3 0 1 17 not 1 10 12 4 gen-label 13 0 15 1 (12 1 3 1 0 2 tjump 3 0 0 4 gen 13 2 3 1 2 3 0 0 17 list 1 3 2 5 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5) 13 1 11 4 gen-label 13 0 3 1 5 10 8 4 gen-label 13 0 8 4 2 #f 15 2 (12 2 3 1 0 2 fjump 3 0 0 4 gen 13 2 3 1 1 3 2 5 10 13 2 jump 3 0 1 4 gen 13 2 8 4 2 () 3 0 0 17 list 1 3 1 2 3 2 5 10 10 3 0 1 17 list 1 8 4 2 () 4 seq 14 7) 13 2 11) 13 3 11) 18 comp-if 1)
(15 9 (12 9 3 0 0 17 symbol? 1 17 not 1 10 13 3 0 0 17 list? 1 17 not 1 8 4 2 #f 10 13 2 "illegal function call " 3 0 0 17 error 2 7 8 2 3 0 0 3 0 2 4 primitive? 13 2 15 1 (12 1 3 0 0 10 973 3 1 0 3 1 1 36 3 0 0 4 prim-min 13 1 3 0 0 4 prim-max 13 1 4 args-count-check 13 3 7 3 1 3 17 not 1 10 14 3 0 0 4 prim-side-effect? 13 1 17 not 1 8 4 2 #f 10 29 3 1 1 3 1 2 2 #f 3 1 4 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-begin 14 8 3 1 0 2 (= < <= > >=) 17 memv 2 10 13 3 1 1 17 length 1 2 2 21 8 4 2 #f 10 88 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 4 binomial-op 17 assv 2 17 cadr 1 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 zero? 17 eqv? 2 10 13 3 1 1 17 length 1 2 1 21 8 4 2 #f 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 zerop 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 - 17 eqv? 2 10 56 3 1 1 17 length 1 2 2 21 10 41 3 1 1 17 cadr 1 2 1 17 eq? 2 10 15 3 1 1 17 cadr 1 2 1 17 eq? 2 8 13 3 1 1 17 cadr 1 2 2 17 eq? 2 8 4 2 #f 8 4 2 #f 10 101 3 1 1 17 butlast 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 1 17 cadr 1 2 1 21 10 10 2 sub1 4 gen 13 1 8 8 2 sub2 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 + 17 eqv? 2 10 56 3 1 1 17 length 1 2 2 21 10 41 3 1 1 17 cadr 1 2 1 17 eq? 2 10 15 3 1 1 17 cadr 1 2 1 17 eq? 2 8 13 3 1 1 17 cadr 1 2 2 17 eq? 2 8 4 2 #f 8 4 2 #f 10 101 3 1 1 17 butlast 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 1 17 cadr 1 2 1 21 10 10 2 add1 4 gen 13 1 8 8 2 add2 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 car 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 car 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 cdr 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 cdr 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 cons 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 cons 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 prim 3 1 0 3 1 1 17 length 1 4 gen 13 3 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 17 list? 1 10 28 3 1 0 34 2 lambda 17 eqv? 2 10 13 3 1 0 17 cadr 1 17 null? 1 8 4 2 #f 8 4 2 #f 10 54 3 1 1 17 null? 1 17 not 1 10 13 2 "too many arguments: " 3 1 1 17 error 2 7 8 2 3 1 0 17 cddr 1 3 1 2 3 1 3 3 1 4 3 1 5 2 #f 3 1 7 3 1 8 4 comp-begin 14 8 3 1 4 17 not 1 10 28 3 1 5 17 not 1 10 16 3 1 7 10 7 3 1 8 8 4 2 #f 8 4 2 #f 8 4 2 #f 10 66 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 callj 3 1 1 17 length 1 4 gen 13 2 4 seq 14 3 3 1 0 2 call/cc 17 eqv? 2 10 101 3 1 1 3 1 2 3 1 5 3 1 6 2 #f 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 call 3 1 1 17 length 1 4 gen 13 2 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 call 3 1 1 17 length 1 4 gen 13 2 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5) 13 1 11) 18 comp-funcall 1)
(2 ((= neqp) (< smlp) (<= esmlp) (> grtp) (>= egrtp)) 18 binomial-op 1)
(15 1 (12 1 3 0 0 17 cadddr 1 11) 18 prim-always? 1)
(15 1 (12 1 3 0 0 17 cdddr 1 17 cadr 1 11) 18 prim-side-effect? 1)
(15 1 (12 1 3 0 0 17 cadr 1 11) 18 prim-min 1)
(15 1 (12 1 3 0 0 17 caddr 1 11) 18 prim-max 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 17 not 1 10 11 3 0 0 4 *primitive* 17 assoc 2 11 2 #f 11) 18 primitive? 1)
(15 5 (12 5 3 0 3 10 55 2 args 3 0 0 4 args-count 13 1 4 gen 13 2 3 0 1 3 0 0 3 0 2 36 2 #t 2 #t 3 0 1 17 macroexpand 1 4 inner-lambda? 13 1 2 #t 3 0 3 3 0 4 4 comp-begin 13 8 4 seq 14 2 2 args 3 0 0 4 args-count 13 1 4 gen 13 2 3 0 1 3 0 0 3 0 2 36 2 #t 2 #t 2 #f 2 #t 3 0 3 3 0 4 4 comp-begin 13 8 4 seq 14 2) 18 comp-lambda 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 5 2 -1 11 3 0 0 17 list? 1 10 9 3 0 0 17 length 1 11 3 0 0 17 pair-length 1 17 - 1 11) 18 args-count 1)
(15 1 (12 1 3 0 0 17 list? 1 10 12 3 0 0 17 length 1 2 1 21 11 2 #f 11) 18 length=1? 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 () 11 3 0 1 34 3 0 0 13 1 3 0 0 3 0 1 35 4 mappend 13 2 17 append 2 11) 18 mappend 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 #t 11 3 0 0 17 symbol? 1 10 5 2 #t 11 3 0 0 17 atom? 1 10 5 2 #f 11 3 0 0 34 17 symbol? 1 17 not 1 10 5 2 #f 11 3 0 0 35 4 lambda-args? 14 1) 18 lambda-args? 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 9 3 0 0 17 symbol? 1 11 3 0 0 17 list? 1 11) 18 symbol-or-list? 1)
(15 3 (12 3 3 0 0 35 17 length 1 15 1 (12 1 3 0 0 3 1 1 25 10 12 3 1 2 2 infinity 17 eq? 2 8 4 2 #f 10 5 2 #t 11 3 0 0 3 1 1 25 10 11 3 0 0 3 1 2 23 8 4 2 #f 10 5 2 #t 11 2 "incorrect argument count " 3 1 0 17 error 2 11) 13 1 11) 18 args-count-check 1)
(15 4 (12 4 3 0 0 3 0 1 17 list-ref 2 3 0 2 13 1 10 5 2 #t 11 3 0 3 3 0 0 17 error 2 11) 18 args-type-check 1)
(15 -2 (12 -2 3 0 0 3 0 1 36 17 list 1 11) 18 gen 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 15 1 (12 1 3 0 0 10 19 2 lvar 3 0 0 34 3 0 0 17 cadr 1 4 gen 13 3 11 3 1 0 17 identifier-free? 1 10 15 2 gvar 3 1 0 17 identifier->symbol 1 4 gen 13 2 11 3 1 0 17 syntactic-closure? 1 10 14 3 1 0 17 syntactic-closure-expr 1 15 1 (12 1 3 2 0 17 syntactic-closure-env 1 15 1 (12 1 3 1 0 3 0 0 4 in-env? 13 2 15 1 (12 1 3 0 0 10 36 2 lvar 3 0 0 34 3 4 1 17 length 1 3 1 0 17 length 1 17 - 2 17 + 2 3 0 0 17 cadr 1 4 gen 14 3 2 gvar 3 2 0 4 gen 14 2) 13 1 11) 13 1 11) 13 1 11 2 gvar 3 1 0 4 gen 13 2 11) 13 1 11) 18 gen-var 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 15 1 (12 1 3 0 0 10 18 2 lset 3 0 0 34 3 0 0 17 cadr 1 4 gen 14 3 2 gset 3 1 0 4 gen 14 2) 13 1 11) 18 gen-set 1)
(15 -1 (12 -1 4 append 3 0 0 17 apply 2 11) 18 seq 1)
(15 0 (12 0 2 "L" 17 gensym 1 11) 18 gen-label 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 19 3 0 0 17 symbol->string 1 2 2 17 string-ref 2 2 #\L 17 char=? 2 11 2 #f 11) 18 label? 1)
(15 2 (12 2 3 0 0 3 0 1 2 0 4 in-env-iter 13 3 11) 18 in-env? 1)
(15 3 (12 3 3 0 1 17 null? 1 10 5 2 #f 11 3 0 0 3 0 1 34 4 in-args? 13 2 10 20 3 0 2 3 0 0 3 0 1 34 4 nth-args 13 2 17 list 2 11 3 0 0 3 0 1 35 3 0 2 27 4 in-env-iter 14 3) 18 in-env-iter 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 #f 11 3 0 1 17 symbol? 1 10 13 3 0 0 3 0 1 17 eq? 2 8 4 2 #f 10 5 2 #t 11 3 0 1 17 symbol? 1 10 5 2 #f 11 3 0 0 3 0 1 34 17 eq? 2 10 5 2 #t 11 3 0 0 3 0 1 35 4 in-args? 14 2) 18 in-args? 1)
(15 2 (12 2 3 0 1 17 symbol? 1 10 13 3 0 0 3 0 1 17 eq? 2 8 4 2 #f 10 5 2 0 11 3 0 0 3 0 1 34 17 eq? 2 10 5 2 0 11 2 1 3 0 0 3 0 1 35 4 nth-args 13 2 17 + 2 11) 18 nth-args 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 #f 11 3 0 0 17 atom? 1 10 5 2 #f 11 3 0 0 17 vector? 1 10 5 2 #f 11 3 0 0 34 2 lambda 17 eq? 2 10 5 2 #t 11 3 0 0 34 4 inner-lambda? 13 1 10 10 3 0 0 34 4 inner-lambda? 14 1 3 0 0 35 4 inner-lambda? 14 1) 18 inner-lambda? 1)
(15 1 (12 1 3 0 0 17 cadr 1 11) 18 arg1 1)
(15 1 (12 1 3 0 0 17 caddr 1 11) 18 arg2 1)
(15 1 (12 1 3 0 0 17 cadddr 1 11) 18 arg3 1)
(15 1 (12 1 3 0 0 34 11) 18 op 1)
(15 1 (12 1 3 0 0 2 (+) 17 memv 2 10 5 2 + 11 3 0 0 2 (-) 17 memv 2 10 5 2 - 11 3 0 0 2 (/) 17 memv 2 10 5 2 / 11 3 0 0 2 (*) 17 memv 2 10 5 2 * 11 3 0 0 2 (^) 17 memv 2 10 5 2 ^ 11 3 0 0 2 (sin) 17 memv 2 10 5 2 sin 11 3 0 0 2 (cos) 17 memv 2 10 5 2 cos 11 3 0 0 2 (exp) 17 memv 2 10 5 2 exp 11 3 0 0 2 (log) 17 memv 2 10 5 2 log 11 3 0 0 2 (sinh) 17 memv 2 10 5 2 sinh 11 3 0 0 2 (cosh) 17 memv 2 10 5 2 cosh 11 3 0 0 2 else 17 memv 2 10 11 2 "opecode else: " 3 0 0 17 error 2 11 17 undefined 0 11) 18 opcode 1)
(15 1 (12 1 3 0 0 2 (+) 17 memv 2 10 5 2 1 11 3 0 0 2 (-) 17 memv 2 10 5 2 1 11 3 0 0 2 (/) 17 memv 2 10 5 2 2 11 3 0 0 2 (*) 17 memv 2 10 5 2 3 11 3 0 0 2 (^) 17 memv 2 10 5 2 4 11 3 0 0 2 (sin) 17 memv 2 10 5 2 6 11 3 0 0 2 (cos) 17 memv 2 10 5 2 6 11 3 0 0 2 (exp) 17 memv 2 10 5 2 6 11 3 0 0 2 (log) 17 memv 2 10 5 2 6 11 3 0 0 2 (cosh) 17 memv 2 10 5 2 6 11 3 0 0 2 (sinh) 17 memv 2 10 5 2 6 11 3 0 0 2 else 17 memv 2 10 5 2 9 11 17 undefined 0 11) 18 weight 1)
(15 1 (12 1 3 0 0 4 infip 13 1 11) 18 infix->prefix 1)
(15 1 (12 1 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 2 () 2 () 4 inf1 14 3) 18 infip 1)
(15 3 (12 3 3 0 0 4 op 13 1 4 weight 13 1 2 5 22 10 18 3 0 0 4 op 13 1 4 weight 13 1 2 5 22 8 16 3 0 0 4 op 13 1 4 weight 13 1 2 7 24 10 25 3 0 0 35 3 0 1 3 0 0 34 4 infip 13 1 3 0 2 36 4 inf2 14 3 3 0 0 17 cddr 1 3 0 1 3 0 0 4 op 13 1 3 0 0 4 arg1 13 1 4 infip 13 1 17 list 2 3 0 2 36 4 inf3 14 3) 18 inf1 1)
(15 3 (12 3 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 7 3 0 2 34 11 3 0 0 17 null? 1 17 not 1 10 37 3 0 1 17 null? 1 10 10 3 0 1 17 null? 1 8 19 3 0 0 34 4 weight 13 1 3 0 1 34 4 weight 13 1 24 8 4 2 #f 10 21 3 0 0 35 3 0 0 34 3 0 1 36 3 0 2 4 inf1 14 3 3 0 0 3 0 1 35 3 0 1 34 4 opcode 13 1 3 0 2 17 cadr 1 3 0 2 34 17 list 3 3 0 2 17 cddr 1 36 4 inf2 14 3) 18 inf2 1)
(15 3 (12 3 3 0 0 17 null? 1 10 10 3 0 2 17 null? 1 8 4 2 #f 10 7 3 0 2 34 11 3 0 0 17 null? 1 17 not 1 10 39 3 0 1 17 null? 1 10 10 3 0 1 17 null? 1 8 21 3 0 0 34 4 weight 13 1 3 0 0 17 cadr 1 4 weight 13 1 24 8 4 2 #f 10 21 3 0 0 35 3 0 0 34 3 0 1 36 3 0 2 4 inf1 14 3 3 0 0 3 0 1 3 0 2 4 inf2 14 3) 18 inf3 1)
(15 1 (12 1 3 0 0 3 0 0 4 pass1 13 1 4 pass2 13 2 11) 18 assemble 1)
(15 1 (12 1 3 0 0 2 1 2 () 4 pass1-iter 13 3 11) 18 pass1 1)
(15 3 (12 3 3 0 0 17 null? 1 10 6 3 0 2 11 3 0 0 34 4 label? 13 1 10 25 3 0 0 35 3 0 1 3 0 0 34 3 0 1 36 3 0 2 36 4 pass1-iter 14 3 3 0 0 35 3 0 1 3 0 0 34 4 op-count 13 1 17 + 2 3 0 2 4 pass1-iter 14 3) 18 pass1-iter 1)
(15 2 (12 2 3 0 0 2 1 2 () 3 0 1 4 pass2-iter 13 4 11) 18 pass2 1)
(15 4 (12 4 3 0 0 17 null? 1 10 9 3 0 2 17 reverse 1 11 3 0 0 34 4 label? 13 1 10 19 3 0 0 35 3 0 1 3 0 2 3 0 3 4 pass2-iter 14 4 3 0 0 35 3 0 1 3 0 0 34 4 op-count 13 1 17 + 2 3 0 0 34 3 0 3 3 0 1 4 mnemonic->code 13 3 17 reverse 1 3 0 2 17 append 2 3 0 3 4 pass2-iter 14 4) 18 pass2-iter 1)
(15 3 (12 3 3 0 0 34 2 halt 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 const 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 lvar 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 gvar 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 lset 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 gset 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 pop 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 jump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 tjump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 fjump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 return 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 args 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 call 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 callj 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 fn 17 eqv? 2 10 30 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 4 assemble 13 1 17 list 3 11 3 0 0 34 2 save 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 prim 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 def 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 defm 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 defh 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 neqp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 smlp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 esmlp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 grtp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 egrtp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 zerop 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 add1 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 sub1 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 add2 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 sub2 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 gref 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 catch 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 pause 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 car 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 cdr 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 cons 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 adapt 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 deflib 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 explib 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 implib 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 17 undefined 0 11) 18 mnemonic->code 1)
(15 1 (12 1 3 0 0 17 length 1 11) 18 op-count 1)
(15 1 (12 1 3 0 0 4 mnemonic 17 member 2 11) 18 op-code? 1)
(15 1 (12 1 4 mnemonic 17 length 1 3 0 0 4 mnemonic 17 member 2 17 length 1 17 - 2 11) 18 op-code 1)
(2 nop 2 halt 2 const 2 lvar 2 gvar 2 lset 2 gset 2 pop 2 jump 2 tjump 2 fjump 2 return 2 args 2 call 2 callj 2 fn 2 save 2 prim 2 def 2 defm 2 defh 2 neqp 2 smlp 2 esmlp 2 grtp 2 egrtp 2 zerop 2 add1 2 sub1 2 add2 2 sub2 2 gref 2 catch 2 pause 2 car 2 cdr 2 cons 2 adapt 2 deflib 2 explib 2 implib 17 list 41 18 mnemonic 1)
(2 ((car 1 1 #t #f) (cdr 1 1 #t #f) (cons 2 2 #t #f) (caar 1 1 #t #f) (cdar 1 1 #t #f) (cddr 1 1 #t #f) (cadr 1 1 #t #f) (caaar 1 1 #t #f) (cdaar 1 1 #t #f) (cadar 1 1 #t #f) (caadr 1 1 #t #f) (cddar 1 1 #t #f) (caddr 1 1 #t #f) (cdadr 1 1 #t #f) (cdddr 1 1 #t #f) (caaaar 1 1 #t #f) (cdaaar 1 1 #t #f) (cadaar 1 1 #t #f) (caadar 1 1 #t #f) (caaadr 1 1 #t #f) (cddaar 1 1 #t #f) (caddar 1 1 #t #f) (caaddr 1 1 #t #f) (cdaadr 1 1 #t #f) (cdadar 1 1 #t #f) (cadddr 1 1 #t #f) (cdaddr 1 1 #t #f) (cddadr 1 1 #t #f) (cdddar 1 1 #t #f) (cddddr 1 1 #t #f) (assq 2 2 #t #f) (assv 2 2 #t #f) (assoc 2 2 #t #f) (memq 2 2 #t #f) (memv 2 2 #t #f) (member 2 2 #t #f) (reverse 1 1 #t #f) (reverse! 1 1 #t #t) (list-tail 1 1 #t #f) (list-ref 2 2 #t #f) (list-set! 3 3 #t #t) (append 2 2 #t #f) (append! 2 infinity #t #t) (set-car! 2 2 #t #f) (set-cdr! 2 2 #t #f) (list 0 infinity #t #f) (length 1 1 #t #f) (pair-length 1 1 #t #f) (last 1 1 #t #f) (butlast 1 1 #t #f) (newline 0 1 #t #t) (display 1 2 #t #t) (write 1 2 #t #t) (write-char 1 1 #t #t) (null? 1 1 #t #f) (list? 1 1 #t #f) (pair? 1 1 #t #f) (atom? 1 1 #t #f) (eq? 1 infinity #t #f) (eqv? 1 infinity #t #f) (equal? 1 infinity #t #f) (boolean? 1 1 #t #f) (procedure? 1 1 #t #f) (number? 1 1 #t #f) (integer? 1 1 #t #f) (real? 1 1 #t #f) (rational? 1 1 #t #f) (complex? 1 1 #t #f) (exact? 1 1 #t #f) (inexact? 1 1 #t #f) (symbol? 1 1 #t #f) (string? 1 1 #t #f) (char? 1 1 #t #f) (bignum? 1 1 #t #f) (vector? 1 1 #t #f) (macro? 1 1 #t #f) (macro-name? 1 1 #t #f) (hygienic? 1 1 #t #f) (hygienic-name? 1 1 #t #f) (zero? 1 1 #t #f) (+ 0 infinity #t #f) (- 1 infinity #t #f) (* 0 infinity #t #f) (/ 1 infinity #t #f) (< 2 infinity #t #f) (<= 2 infinity #t #f) (> 2 infinity #t #f) (>= 2 infinity #t #f) (= 2 infinity #t #f) (sin 1 1 #t #f) (cos 1 1 #t #f) (tan 1 1 #t #f) (asin 1 1 #t #f) (acos 1 1 #t #f) (atan 1 2 #t #f) (log 1 1 #t #f) (exp 1 1 #t #f) (sqrt 1 1 #t #f) (expt 2 2 #t #f) (not 1 1 #t #f) (odd? 1 1 #t #f) (even? 1 1 #t #f) (floor 1 1 #t #f) (ceiling 1 1 #t #f) (truncate 1 1 #t #f) (round 1 1 #t #f) (numerator 1 1 #t #f) (denominator 1 1 #t #f) (positive? 1 1 #t #f) (negative? 1 1 #t #f) (abs 1 1 #t #f) (max 1 infinity #t #f) (min 1 infinity #t #f) (real-part 1 1 #t #f) (imag-part 1 1 #t #f) (magnitude 1 1 #t #f) (angle 1 1 #t #f) (make-rectangular 2 2 #t #f) (make-polar 2 2 #t #f) (exact->inexact 1 1 #t #f) (exact 1 1 #t #f) (inexact->exact 1 1 #t #f) (inexact 1 1 #t #f) (remainder 2 2 #t #f) (modulo 2 2 #t #f) (quotient 2 2 #t #f) (gcd 0 2 #t #f) (lcm 0 2 #t #f) (char=? 2 2 #t #f) (char>? 2 2 #t #f) (char>=? 2 2 #t #f) (char<? 2 2 #t #f) (char<=? 2 2 #t #f) (char-ci=? 2 2 #t #f) (char-ci>? 2 2 #t #f) (char-ci>=? 2 2 #t #f) (char-ci<? 2 2 #t #f) (char-ci<=? 2 2 #t #f) (char-alphabetic? 1 1 #t #f) (char-numeric? 1 1 #t #f) (char-whitespace? 1 1 #t #f) (char-upper-case? 1 1 #t #f) (char-lower-case? 1 1 #t #f) (char->integer 1 1 #t #f) (integer->char 1 1 #t #f) (char-upcase 1 1 #t #f) (char-downcase 1 1 #t #f) (string-append 1 infinity #t #f) (number->string 1 2 #t #f) (string->number 1 2 #t #f) (string=? 1 1 #t #f) (string>? 1 1 #t #f) (string>=? 1 1 #t #f) (string<? 1 1 #t #f) (string<=? 1 1 #t #f) (string-ci=? 1 1 #t #f) (string-ci>? 1 1 #t #f) (string-ci>=? 1 1 #t #f) (string-ci<? 1 1 #t #f) (string-ci<=? 1 1 #t #f) (string->symbol 1 1 #t #f) (symbol->string 1 1 #t #f) (string-length 1 1 #t #f) (make-string 1 1 #t #f) (string 1 1 #t #f) (string-ref 2 2 #t #f) (string-set! 3 3 #t #t) (substring 1 1 #t #f) (string->list 1 1 #t #f) (list->string 1 1 #t #f) (string-copy 1 1 #t #f) (string-fill! 1 1 #t #t) (make-vector 1 2 #t #t) (vector-set! 3 3 #t #t) (vector 0 infinity #t #t) (vector-ref 2 2 #t #f) (vector-length 1 1 #t #f) (vector-fill! 2 2 #t #t) (vector->list 1 1 #t #f) (list->vector 1 1 #t #f) (read 0 1 #t #f) (load 1 1 #t #f) (open-input-file 1 1 #t #t) (open-output-file 1 1 #t #t) (close-input-port 1 1 #t #t) (close-output-port 1 1 #t #t) (eof-object? 1 1 #t #f) (input-port? 1 1 #t #f) (output-port? 1 1 #t #f) (current-input-port 1 1 #t #f) (current-output-port 1 1 #t #f) (read-char 1 1 #t #f) (peek-char 1 1 #t #f) (read-line 0 0 #t #f) (read-string 1 1 #t #f) (char-ready? 1 1 #t #f) (exit 0 0 #t #t) (gensym 0 1 #t #f) (apply 2 infinity #t #t) (primitive-name? 1 1 #t #f) (macroexpand-1 1 1 #t #f) (macroexpand 1 1 #t #f) (addr 1 1 #t #f) (entity-addr 1 1 #t #f) (undefined 0 0 #t #f) (step 1 1 #t #t) (vm2-step 1 1 #t #t) (vm1 1 1 #t #t) (vm2 1 1 #t #t) (dump 1 2 #t #t) (addr-prt 1 1 #t #t) (gbc 0 1 #t #t) (room 0 0 #t #f) (vmcode 1 1 #t #f) (env 1 1 #t #f) (timer-set 0 0 #t #t) (timer-get 0 0 #t #t) (timer-gbc 0 0 #t #t) (current-second 0 0 #t #f) (current-jiffy 0 0 #t #f) (jiffies-per-second 0 0 #t #f) (eval 1 1 #t #f) (load 1 1 #t #t) (error 1 infinity #t #t) (flush 0 1 #t #t) (set-trace 0 infinity #t #t) (set-untrace 0 infinity #t #t) (current-module 0 0 #t #f) (debug 1 1 #t #t) (profiler 1 1 #t #t) (lambda/asm 2 2 #t #f) (values 0 infinity #t #t) (sys-cont-room 1 1 #t #t) (make-syntactic-closure 3 3 #t #t) (syntactic-closure-expr 1 1 #t #f) (syntactic-closure-env 1 1 #t #f) (syntactic-closure-freevar 1 1 #t #f) (symbol->identifier 1 1 #t #f) (identifier->symbol 1 1 #t #f) (syntactic-closure? 1 1 #t #f) (identifier? 1 1 #t #f) (identifier-bind! 2 2 #t #t) (identifier-free? 1 1 #t #f) (identifier-bound? 1 1 #t #f) (identifier-bound 1 1 #t #f) (global-bound? 1 1 #t #f) (inspect 0 0 #t #t) (exact-integer? 1 1 #t #f) (file-exists? 1 1 #t #f) (system 1 1 #t #t) (flush-output-port 0 1 #t #t) (infinity? 1 1 #t #f) (finity? 1 1 #t #f) (nan? 1 1 #t #f) (square 1 1 #t #f) (bytevector? 1 1 #t #f) (make-bytevector 1 2 #t #t) (bytevector 0 infinity #t #t) (bytevector-length 1 1 #t #f) (bytevector-u8-set! 3 3 #t #f) (bytevector-u8-ref 2 2 #t #f) (bytevector-copy 1 3 #t #t) (bytevector-copy! 3 5 #t #t) (bytevector-append 0 infinity #t #f) (command-line 0 0 #t #f) (get-environment-variable 1 1 #t #f) (get-environment-variables 0 0 #t #f) (get-car 1 1 #t #f)) 18 *primitive* 1)
(15 1 (12 1 3 0 0 2 ".scm" 17 string-append 2 15 1 (12 1 3 1 0 2 ".o" 17 string-append 2 15 1 (12 1 3 1 0 17 open-input-file 1 15 1 (12 1 3 1 0 17 open-output-file 1 15 1 (12 1 3 1 0 17 read 1 3 1 0 3 0 0 4 compile-file1 13 3 7 3 1 0 17 close-input-port 1 7 3 0 0 17 close-output-port 1 7 2 #t 11) 13 1 11) 13 1 11) 13 1 11) 13 1 11) 18 compile-file 1)
(15 3 (12 3 3 0 0 17 eof-object? 1 10 5 2 #t 11 3 0 0 4 compile 13 1 4 assemble 13 1 3 0 2 17 write 2 7 3 0 2 17 newline 1 7 17 gbc 0 7 3 0 1 17 read 1 3 0 1 3 0 2 4 compile-file1 14 3) 18 compile-file1 1)
(2 1 2 ((args 1) (catch) (lvar 0 0) (call 1) (return)) 17 lambda/asm 2 18 ncall/cc 1)
(2 2 2 ((args 2) (lvar 0 0) (call 0) (adapt) (lvar 0 1) (call 0) (return)) 17 lambda/asm 2 18 call-with-values 1)
(2 () 18 winders 1)
(15 3 (12 3 3 0 0 13 0 7 3 0 0 3 0 2 36 4 winders 36 6 winders 7 3 0 1 13 0 15 1 (12 1 4 winders 35 6 winders 7 3 1 2 13 0 7 3 0 0 11) 13 1 11) 18 dynamic-wind 1)
(15 2 (12 2 3 0 0 17 reverse 1 3 0 1 17 reverse 1 4 common-tail1 13 2 17 reverse 1 11) 18 common-tail 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 1 17 null? 1 10 5 2 () 11 3 0 0 34 3 0 1 34 17 eq? 2 17 not 1 10 5 2 () 11 3 0 0 34 3 0 0 35 3 0 1 35 4 common-tail1 13 2 36 11) 18 common-tail1 1)
(15 1 (12 1 3 0 0 4 winders 4 common-tail 13 2 15 1 (12 1 4 winders 3 0 0 4 do-wind-after 13 2 7 3 1 0 17 reverse 1 3 0 0 17 reverse 1 4 do-wind-before 13 2 7 3 1 0 6 winders 11) 13 1 11) 18 do-wind 1)
(15 2 (12 2 3 0 0 3 0 1 17 equal? 2 10 5 2 #t 11 3 0 0 17 cdar 1 13 0 7 3 0 0 35 3 0 1 4 do-wind-after 14 2) 18 do-wind-after 1)
(15 2 (12 2 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 5 2 #t 11 3 0 1 17 null? 1 10 22 3 0 0 17 caar 1 13 0 7 3 0 0 35 3 0 1 4 do-wind-before 14 2 3 0 0 35 3 0 1 35 4 do-wind-before 14 2) 18 do-wind-before 1)
(15 1 (12 1 15 1 (12 1 4 winders 15 1 (12 1 15 -1 (12 -1 3 1 0 4 winders 17 eq? 2 17 not 1 10 12 3 1 0 4 do-wind 13 1 7 8 2 3 2 0 3 0 0 17 apply 2 11) 11) 13 1 3 1 0 13 1 11) 4 ncall/cc 13 1 11) 18 call/cc 1)
(4 call/cc 18 call-with-current-continuation 1)
(15 3 (12 3 3 0 0 3 0 1 3 0 2 2 () 4 match1 13 4 11) 18 match 1)
(15 4 (12 4 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 6 3 0 3 11 3 0 0 17 symbol? 1 10 31 3 0 0 3 0 2 17 memv 2 10 16 3 0 0 3 0 1 17 eqv? 2 17 not 1 8 4 2 #f 8 4 2 #f 10 5 2 #f 11 3 0 1 17 symbol? 1 10 31 3 0 1 3 0 2 17 memv 2 10 16 3 0 0 3 0 1 17 eqv? 2 17 not 1 8 4 2 #f 8 4 2 #f 10 5 2 #f 11 3 0 0 17 symbol? 1 10 14 3 0 0 3 0 1 36 3 0 3 36 11 3 0 0 4 ellipsis? 13 1 10 66 3 0 0 17 cddr 1 3 0 1 3 0 0 17 cddr 1 17 length 1 4 list-take-right 13 2 3 0 2 3 0 0 34 3 0 1 3 0 1 17 length 1 3 0 0 17 cddr 1 17 length 1 17 - 2 4 list-take 13 2 36 3 0 3 36 4 match1 13 4 11 3 0 0 17 vector? 1 10 10 3 0 1 17 vector? 1 8 4 2 #f 10 25 3 0 0 17 vector->list 1 3 0 1 17 vector->list 1 3 0 2 3 0 3 4 match1 13 4 11 3 0 0 17 null? 1 10 13 3 0 1 17 null? 1 17 not 1 8 4 2 #f 10 5 2 #f 11 3 0 0 17 null? 1 17 not 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 5 2 #f 11 3 0 0 17 atom? 1 10 16 3 0 0 3 0 1 17 equal? 2 17 not 1 8 4 2 #f 10 5 2 #f 11 3 0 0 34 3 0 1 34 3 0 2 3 0 3 4 match1 13 4 3 0 0 35 3 0 1 35 3 0 2 3 0 3 4 match1 13 4 15 2 (12 2 3 0 0 10 7 3 0 1 8 4 2 #f 10 12 3 0 0 3 0 1 17 append 2 11 2 #f 11) 13 2 11) 18 match1 1)
(15 1 (12 1 2 *undef* 15 1 (12 1 15 2 (12 2 3 0 0 3 0 1 21 10 5 2 () 11 15 1 (12 1 3 0 0 3 1 0 17 list-ref 2 11) 3 2 0 4 map 13 2 3 0 0 27 3 0 1 3 1 0 13 2 36 11) 5 0 0 7 2 0 3 1 0 34 17 length 1 3 0 0 13 2 11) 13 1 11) 18 transpose 1)
(15 1 (12 1 3 0 0 17 list? 1 10 58 3 0 0 17 length 1 2 2 25 10 44 3 0 0 34 17 identifier? 1 10 11 3 0 0 34 17 identifier? 1 8 9 3 0 0 34 17 symbol? 1 10 14 3 0 0 17 cadr 1 2 ... 17 eqv? 2 11 2 #f 11 2 #f 11 2 #f 11) 18 ellipsis? 1)
(15 1 (12 1 3 0 0 17 list 1 10 40 3 0 0 17 length 1 2 2 25 10 26 3 0 0 34 17 list? 1 10 14 3 0 0 17 cadr 1 2 ... 17 eqv? 2 11 2 #f 11 2 #f 11 2 #f 11) 18 ellipsises? 1)
(15 1 (12 1 3 0 0 17 vector? 1 10 21 3 0 0 3 0 0 17 vector-length 1 28 17 vector-ref 2 2 ... 17 eqv? 2 11 2 #f 11) 18 vec-ellipsis? 1)
(15 2 (12 2 3 0 1 2 0 21 10 5 2 () 11 3 0 0 34 3 0 0 35 3 0 1 28 4 list-take 13 2 36 11) 18 list-take 1)
(15 2 (12 2 3 0 0 3 0 0 17 length 1 3 0 1 17 - 2 4 list-drop 13 2 11) 18 list-take-right 1)
(15 2 (12 2 3 0 1 2 0 21 10 6 3 0 0 11 3 0 0 35 3 0 1 28 4 list-drop 14 2) 18 list-drop 1)
(15 1 (12 1 3 0 0 2 fail 17 eq? 2 11) 18 fail? 1)
(15 3 (12 3 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 symbol? 1 10 14 3 0 0 3 0 1 4 local-bound? 13 2 8 4 2 #f 10 14 3 0 1 2 () 3 0 0 17 make-syntactic-closure 3 11 3 0 0 17 symbol? 1 10 10 3 0 0 17 global-bound? 1 8 4 2 #f 10 15 3 0 0 17 symbol->identifier 1 3 0 0 17 identifier-bind! 2 11 3 0 0 17 symbol? 1 10 13 3 0 0 3 0 2 17 memv 2 8 4 2 #f 10 15 3 0 0 17 symbol->identifier 1 3 0 0 17 identifier-bind! 2 11 3 0 0 17 symbol? 1 10 9 3 0 0 17 symbol->identifier 1 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 22 3 0 0 17 vector->list 1 3 0 1 3 0 2 4 subst-to-identifier 13 3 17 list->vector 1 11 3 0 0 34 3 0 1 3 0 2 4 subst-to-identifier 13 3 3 0 0 35 3 0 1 3 0 2 4 subst-to-identifier 13 3 36 11) 18 subst-to-identifier 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 #f 11 3 0 0 3 0 1 34 17 member 2 10 5 2 #t 11 3 0 0 3 0 1 35 4 local-bound? 14 2) 18 local-bound? 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier? 1 10 13 3 0 0 3 0 1 17 assv 2 8 4 2 #f 10 19 3 0 0 3 0 0 3 0 1 17 assv 2 35 17 identifier-bind! 2 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 19 3 0 0 17 vector->list 1 3 0 1 4 subst-pattern-vars 13 2 17 list->vector 1 11 3 0 0 34 3 0 1 4 subst-pattern-vars 13 2 3 0 0 35 3 0 1 4 subst-pattern-vars 13 2 36 11) 18 subst-pattern-vars 1)
(15 1 (12 1 3 0 0 3 0 0 2 () 4 scan-let-vars 13 2 4 subst-let-vars1 13 2 11) 18 subst-let-vars 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier? 1 10 25 3 0 0 17 identifier-free? 1 10 13 3 0 0 3 0 1 17 assv 2 8 4 2 #f 8 4 2 #f 10 19 3 0 0 3 0 0 3 0 1 17 assv 2 35 17 identifier-bind! 2 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 34 3 0 1 4 subst-let-vars1 13 2 3 0 0 35 3 0 1 4 subst-let-vars1 13 2 36 11) 18 subst-let-vars1 1)
(15 2 (12 2 3 0 0 17 null? 1 10 12 15 1 (12 1 3 0 0 17 gensym 0 36 11) 3 0 1 4 map 14 2 3 0 0 17 atom? 1 10 5 2 () 11 3 0 0 17 vector? 1 10 5 2 () 11 3 0 0 4 lambda? 13 1 10 13 3 0 0 17 cadr 1 17 atom? 1 8 4 2 #f 10 22 3 0 0 17 cddr 1 3 0 0 17 cadr 1 3 0 1 36 4 scan-let-vars 14 2 3 0 0 4 lambda? 13 1 10 31 3 0 0 17 cadr 1 17 list? 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 8 4 2 #f 10 24 3 0 0 17 cddr 1 3 0 0 17 cadr 1 3 0 1 17 append 2 4 scan-let-vars 14 2 3 0 0 4 lambda? 13 1 10 31 3 0 0 17 cadr 1 17 pair? 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 8 4 2 #f 10 22 3 0 0 17 caddr 1 3 0 0 17 cadr 1 4 pair->list 13 1 4 scan-let-vars 14 2 3 0 0 4 let? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 let*? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 letrec? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 named-let? 13 1 10 16 3 0 0 17 caddr 1 17 null? 1 17 not 1 8 4 2 #f 10 36 3 0 0 17 cdddr 1 3 0 0 17 caddr 1 4 transpose 13 1 34 3 0 0 17 cadr 1 3 0 1 36 17 append 2 4 scan-let-vars 14 2 3 0 0 35 3 0 1 4 scan-let-vars 14 2) 18 scan-let-vars 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 lambda 17 eqv? 2 11 2 #f 11 2 #f 11) 18 lambda? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 43 3 0 0 17 length 1 2 3 25 10 29 3 0 0 34 2 let 17 eqv? 2 10 15 3 0 0 17 cadr 1 17 identifier? 1 17 not 1 11 2 #f 11 2 #f 11 2 #f 11) 18 let? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 40 3 0 0 17 length 1 2 4 25 10 26 3 0 0 34 2 let 17 eqv? 2 10 12 3 0 0 17 cadr 1 17 identifier? 1 11 2 #f 11 2 #f 11 2 #f 11) 18 named-let? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 letrec 17 eqv? 2 11 2 #f 11 2 #f 11) 18 letrec? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 let* 17 eqv? 2 11 2 #f 11 2 #f 11) 18 let*? 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier-free? 1 10 9 3 0 0 17 identifier->symbol 1 11 3 0 0 17 identifier? 1 10 9 3 0 0 17 identifier-bound 1 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 16 3 0 0 17 vector->list 1 4 subst-from-identifier 13 1 17 list->vector 1 11 3 0 0 17 length 1 2 2 21 10 11 3 0 0 4 ellipsis? 13 1 8 4 2 #f 10 10 3 0 0 34 17 identifier-bound 1 11 3 0 0 17 length 1 2 2 24 10 17 3 0 0 2 2 4 list-take 13 2 4 ellipsis? 13 1 8 4 2 #f 10 23 3 0 0 34 17 identifier-bound 1 3 0 0 17 cddr 1 4 subst-from-identifier 13 1 17 append 2 11 3 0 0 34 4 subst-from-identifier 13 1 3 0 0 35 4 subst-from-identifier 13 1 36 11) 18 subst-from-identifier 1)
(15 4 (12 4 2 #f 2 #f 2 #f 2 #f 15 4 (12 4 3 1 0 3 1 2 3 1 3 4 subst-to-identifier 13 3 5 0 0 7 3 0 0 3 1 1 4 subst-pattern-vars 13 2 5 0 1 7 3 0 1 4 subst-let-vars 13 1 5 0 2 7 3 0 2 4 subst-from-identifier 13 1 5 0 3 7 3 0 3 11) 13 4 11) 18 expand-template 1)
(15 4 (12 4 3 0 0 17 caar 1 15 1 (12 1 3 1 0 17 cadar 1 15 1 (12 1 3 1 0 3 2 1 3 2 2 4 match 13 3 15 1 (12 1 3 0 0 10 18 3 1 0 3 0 0 3 3 3 3 3 2 4 expand-template 14 4 3 3 0 35 17 null? 1 10 11 2 "syntax-rules match fail " 3 3 1 17 error 2 11 3 3 0 35 3 3 1 3 3 2 3 3 3 4 expand 14 4) 13 1 11) 13 1 11) 13 1 11) 18 expand 1)
(15 -3 (12 -3 17 undefined 0 17 undefined 0 15 2 (12 2 15 1 (12 1 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 34 3 2 0 13 1 3 0 0 35 3 1 0 13 1 36 11) 5 0 0 7 15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 2 0 3 0 0 34 4 car 3 0 1 4 map 13 2 17 apply 3 3 0 0 35 4 cdr 3 0 1 4 map 13 2 3 1 1 13 2 36 11) 5 0 1 7 3 1 2 17 null? 1 10 10 3 1 1 3 0 0 14 1 3 1 1 3 1 2 3 0 1 14 2) 13 2 11) 18 map 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 5 2 #t 11 3 0 0 35 17 null? 1 10 7 3 0 0 34 11 2 if 3 0 0 34 2 and 3 0 0 35 2 () 17 append 2 36 2 #f 2 () 36 36 36 36 11) 19 and 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 5 2 #f 11 3 0 0 35 17 null? 1 10 7 3 0 0 34 11 2 if 3 0 0 34 3 0 0 34 2 or 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 11) 19 or 1)
(15 -2 (12 -2 3 0 0 17 null? 1 10 20 2 lambda 2 () 3 0 1 2 () 17 append 2 36 36 2 () 36 11 3 0 0 17 pair? 1 10 39 2 lambda 4 car 3 0 0 4 map 13 2 3 0 1 2 () 17 append 2 36 36 4 cadr 3 0 0 4 map 13 2 2 () 17 append 2 36 11 2 letrec 3 0 0 2 lambda 4 car 3 0 1 34 4 map 13 2 3 0 1 35 2 () 17 append 2 36 36 2 () 36 36 2 () 36 3 0 0 4 cadr 3 0 1 34 4 map 13 2 2 () 17 append 2 36 2 () 36 36 36 11) 19 let 1)
(15 -2 (12 -2 3 0 0 17 null? 1 10 20 2 lambda 2 () 3 0 1 2 () 17 append 2 36 36 2 () 36 11 3 0 0 35 17 null? 1 10 22 2 let 3 0 0 34 2 () 36 3 0 1 2 () 17 append 2 36 36 11 2 let 3 0 0 34 2 () 36 2 let* 3 0 0 35 3 0 1 2 () 17 append 2 36 36 2 () 36 36 36 11) 19 let* 1)
(15 -2 (12 -2 4 car 3 0 0 4 map 13 2 4 cadr 3 0 0 4 map 13 2 15 2 (12 2 2 let 15 1 (12 1 3 0 0 2 quote 2 *undef* 2 () 36 36 2 () 36 36 11) 3 0 0 4 map 13 2 15 2 (12 2 2 set! 3 0 0 3 0 1 2 () 36 36 36 11) 3 0 0 3 0 1 4 map 13 3 3 1 1 2 () 17 append 2 17 append 2 36 36 11) 13 2 11) 19 letrec 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 8 2 undefined 2 () 36 11 3 0 0 17 cdar 1 17 null? 1 10 49 2 let 2 *val* 3 0 0 17 caar 1 2 () 36 36 2 () 36 2 if 2 *val* 2 *val* 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 2 () 36 36 36 11 3 0 0 17 cadar 1 2 => 17 eq? 2 10 46 2 let 2 *val* 3 0 0 17 caar 1 2 () 36 36 2 () 36 2 if 2 *val* 3 0 0 17 caddar 1 2 *val* 2 () 36 36 2 () 36 36 36 2 () 36 36 36 11 3 0 0 17 caar 1 2 else 17 eqv? 2 10 36 3 0 0 17 cdar 1 4 length=1? 13 1 10 9 3 0 0 17 cadar 1 11 2 begin 3 0 0 17 cdar 1 2 () 17 append 2 36 11 3 0 0 17 cdar 1 4 length=1? 13 1 10 37 2 if 3 0 0 17 caar 1 3 0 0 17 cdar 1 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 17 append 2 36 36 11 2 if 3 0 0 17 caar 1 2 begin 3 0 0 17 cdar 1 2 () 17 append 2 36 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 11) 19 cond 1)
(15 -2 (12 -2 3 0 1 17 null? 1 10 8 2 undefined 2 () 36 11 3 0 1 17 caar 1 2 else 17 eq? 2 10 17 2 begin 3 0 1 17 cdar 1 2 () 17 append 2 36 11 2 if 2 memv 3 0 0 2 quote 3 0 1 17 caar 1 2 () 36 36 2 () 36 36 36 2 begin 3 0 1 17 cdar 1 2 () 17 append 2 36 2 case 3 0 0 3 0 1 35 2 () 17 append 2 36 36 2 () 36 36 36 36 11) 19 case 1)
(15 -3 (12 -3 4 car 3 0 0 4 map 13 2 4 cadr 3 0 0 4 map 13 2 4 cddr 3 0 0 4 map 13 2 15 3 (12 3 2 letrec 2 loop 2 lambda 3 0 0 2 if 3 1 1 34 2 begin 3 1 1 35 2 () 17 append 2 36 2 begin 3 1 2 2 loop 15 2 (12 2 3 0 0 17 null? 1 10 6 3 0 1 11 3 0 0 34 11) 3 0 2 3 0 0 4 map 13 3 2 () 17 append 2 36 2 () 36 17 append 2 36 2 () 36 36 36 36 2 () 36 36 36 2 () 36 36 2 () 36 2 loop 3 0 1 2 () 17 append 2 36 2 () 36 36 36 11) 13 3 11) 19 do 1)
(15 -3 (12 -3 2 *undef* 15 1 (12 1 15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 2 0 3 0 0 34 4 car 3 0 1 4 map 13 2 17 apply 3 7 3 0 0 35 4 cdr 3 0 1 4 map 13 2 3 1 0 14 2) 5 0 0 7 3 1 1 3 1 2 3 0 0 13 2 11) 13 1 7 17 undefined 0 11) 18 for-each 1)
