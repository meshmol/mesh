;;末尾再帰最適化コンパイラ
;;has-lambda? 入れ子のlambda式をもつかどうか。
;;in-lambda?　lambda式の中の式かどうか？
;;tail?　末尾再帰最適化をするべきかどうか？
;;define-macroのときには#fにする。
;;--------------------------------- 

(define (compile x)
  (append (comp (transfer x) '() #t #t #f #f #t) (list (list 'halt))))


(define (comp x env val? more? has-lambda? in-lambda? tail?)
  (cond ((null? x) (comp-const x val? more?))
        ((boolean? x) (comp-const x val? more?))
        ((symbol? x) (comp-var x env val? more?))
        ((atom? x ) (comp-const x val? more?))
        ((vector? x) (comp-const x val? more?))
        ((macro-name? (car x))
         (comp (macroexpand-1 x) env val? more? has-lambda? in-lambda? tail?))
        ((eq? (car x) 'quote)
         (args-count-check x 1 1)
         (comp-const (cadr x) val? more?))
        ((eq? (car x) 'begin)
         (comp-begin (cdr x) env val? more? has-lambda? in-lambda? tail?))
        ((eq? (car x) 'set!)
         (args-count-check x 2 2)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? tail?)
              (gen-set (cadr x) env)
              (if (not val?) (gen 'pop) '())
              (if (not more?) (gen 'return) '())))
        ((eq? (car x) 'if)
         (args-count-check x 3 3)
         (comp-if (cadr x) (caddr x) (cadddr x)
                   env val? more? has-lambda? in-lambda? tail?))
        ((eq? (car x) 'lambda)
         (if val?
             (let ((f (comp-lambda (cadr x) (cddr x) env tail?)))
               (seq (gen 'fn (args-count (cadr x))f)
                    (if (not more?) (gen 'return) '())))
             #f))
        ((eq? (car x) 'define)
         (args-type-check x 1 symbol? "require symbol ")
         (args-type-check x 1 (lambda (y) (not (primitive-name? y)))
                          "can't overwrite primitive name ")
         (seq (comp (caddr x) env val? more? has-lambda? in-lambda? tail?) 
              (gen 'def (cadr x))))
        ((eq? (car x) 'define-macro)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env val? more? has-lambda? in-lambda? #f)
              (gen 'defm (cadr x))))
        (else
          (comp-funcall (car x) (cdr x) env val? more? has-lambda? in-lambda? tail?))))
        

(define (comp-const x val? more?)
  (if val? 
      (seq (gen 'const x)
                (if (not more?)
                    (gen 'return)
                    '()))
      '()))

(define (comp-var x env val? more?)
  (if val?
      (seq (gen-var x env)
           (if (not more?)
               (gen 'return)
               '()))
      '()))

(define (comp-begin exps env val? more? has-lambda? in-lambda? tail?)
  (cond ((null? exps) (comp-const '() val? more?))
        ((length=1? exps) (comp (car exps) env val? #f has-lambda? in-lambda? tail?))
        (else (seq (comp (car exps) env #f #t has-lambda? in-lambda? tail?)
                   (comp-begin  (cdr exps) env val? more? has-lambda? in-lambda? tail?)))))

(define (comp-list exps env has-lambda? in-lambda? tail?)
  (if (null? exps)
      '()
      (seq (comp (car exps) env #t #t has-lambda? in-lambda? tail?)
           (comp-list (cdr exps) env has-lambda? in-lambda? tail?))))

(define (comp-if pred then else env val? more? has-lambda? in-lambda? tail?)
  (cond ((not pred)
         (comp else env val? more? has-lambda? in-lambda? tail?))
        ((and (atom? pred) (not (symbol? pred)) (not (not pred)))
         (comp then env val? more? has-lambda? in-lambda? tail?))
        ((and (list? pred)
              (length=1? (cdr pred))
              (eq? (car pred) 'not))
         (comp-if (cadr pred) else then env val? more? has-lambda? in-lambda? tail?))
        (else 
          (let ((pcode (comp pred env #t #t has-lambda? in-lambda? tail?))
                (tcode (comp then env val? more? has-lambda? in-lambda? tail?))
                (ecode (comp else env val? more? has-lambda? in-lambda? tail?)))
            (cond ((equal? tcode ecode)
                   (seq (comp pred env #f #t has-lambda? in-lambda? tail?) ecode))
                  ((not tcode)
                   (let ((L2 (gen-label)))
                     (seq pcode (gen 'tjump L2) ecode (list L2)
                          (if (not more?) (gen 'return) '()))))
                  (else
                    (let ((L1 (gen-label))
                          (L2 (if more? (gen-label) #f)))
                      (seq pcode (gen 'fjump L1) tcode
                           (if more? (gen 'jump L2) '())
                           (list L1) ecode (if more? (list L2) '())))))))))


(define (comp-funcall f args env val? more? has-lambda? in-lambda? tail?)
  (let ((prim (primitive? f env)))
    (cond (prim
            (args-count-check (cons f args) (prim-min prim) (prim-max prim))
            (cond ((and (not val?) (not (prim-side-effect? prim)))
                   (comp-begin args env #f more? has-lambda? in-lambda? tail?))
                  ((eq? f 'call/cc);;call/ccのときはCALL命令を生成する。
                    (seq (comp-list args env has-lambda? in-lambda? #f)
                         (gen 'prim f (length args))
                         (if (not val?) (gen 'pop) '())
                         (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (memq f '(= < <= > >=))(= (length args) 2));;2項比較演算子
                   (seq (comp-list args env has-lambda? in-lambda? tail?)
                             (gen (cadr (assq f binomial-op)))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eq? f 'zero?)(= (length args) 1));;(zero? n)->(zerop)
                   (seq (comp-list args env has-lambda? in-lambda? tail?)
                             (gen 'zerop)
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eq? f '-)(= (length args) 2)
                        (or (eq? (cadr args) 1) (eq? (cadr args) 2))) ;;(- x 1or2)->(sub1or2)
                   (seq (comp-list (butlast args) env has-lambda? in-lambda? tail?)
                             (if (= (cadr args) 1) (gen 'sub1) (gen 'sub2))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eq? f '+)(= (length args) 2)
                        (or (eq? (cadr args) 1) (eq? (cadr args) 2))) ;;(+ x 1or2)->(add1or2)
                   (seq (comp-list (butlast args) env has-lambda? in-lambda? tail?)
                             (if (= (cadr args) 1) (gen 'add1) (gen 'add2))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))
                  (else (seq (comp-list args env has-lambda? in-lambda? tail?)
                             (gen 'prim f (length args))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))))
          ((and (list? f) (eq? (car f) 'lambda) (null? (cadr f)))
           (if (not (null? args)) (error "too many arguments: " args) '())
           (comp-begin (cddr r) env val? more? has-lambda? in-lambda? tail?))
          ((and (not more?)(not has-lambda?) tail?)
           (seq (comp-list args env has-lambda? in-lambda? tail?)
                (comp f env #t #t has-lambda? in-lambda? tail?)
                (gen 'callj (length args))))
          (else
            (seq (comp-list args env has-lambda? in-lambda? tail?)
                 (comp f env #t #t has-lambda? in-lambda? tail?)
                 (gen 'call (length args))
                 (if (not val?) (gen 'pop) '())
                 (if (not more?) (gen 'return) '()))))))

;;; 
;;; (define binomial-op
;;;   '((= neqp) (< smlp) (<= esmlp)
;;;     (> grtp) (>= egrtp)))
;;; 

;;; (define (prim-always? x)
;;;   (cadddr x))
;;; 
;;; (define (prim-side-effect? x)
;;;   (cadr (cdddr x)))
;;; 
;;; (define (prim-min x)
;;;   (cadr x))
;;; 
;;; (define (prim-max x)
;;;   (caddr x))
;;; 
;;; ;;(symbol-name args-min args-max always side-effect)
;;; (define *primitive*
;;;   '((car 1 1 #t #f)
;;;     (cdr 1 1 #t #f)
;;;     (cons 2 2 #t #f)
;;;     (caar 1 1 #t #f)
;;;     (cdar 1 1 #t #f)
;;;     (cddr 1 1 #t #f)
;;;     (cadr 1 1 #t #f)
;;;     (caaar 1 1 #t #f)
;;;     (cdaar 1 1 #t #f)
;;;     (cadar 1 1 #t #f)
;;;     (caadr 1 1 #t #f)
;;;     (cddar 1 1 #t #f)
;;;     (caddr 1 1 #t #f)
;;;     (cdadr 1 1 #t #f)
;;;     (cdddr 1 1 #t #f)
;;;     (caaaar 1 1 #t #f)
;;;     (cdaaar 1 1 #t #f)
;;;     (cadaar 1 1 #t #f)
;;;     (caadar 1 1 #t #f)
;;;     (caaadr 1 1 #t #f)
;;;     (cddaar 1 1 #t #f)
;;;     (caddar 1 1 #t #f)
;;;     (caaddr 1 1 #t #f)
;;;     (cdaadr 1 1 #t #f)
;;;     (cdadar 1 1 #t #f)
;;;     (cadddr 1 1 #t #f)
;;;     (cdaddr 1 1 #t #f)
;;;     (cddadr 1 1 #t #f)
;;;     (cdddar 1 1 #t #f)
;;;     (cddddr 1 1 #t #f)
;;;     (assq 2 2 #t #f)
;;;     (assv 2 2 #t #f)
;;;     (assoc 2 2 #t #f)
;;;     (memq 2 2 #t #f)
;;;     (memv 2 2 #t #f)
;;;     (member 2 2 #t #f)
;;;     (reverse 1 1 #t #f)
;;;     (reverse! 1 1 #t #t)
;;;     (list-tail 1 1 #t #f)
;;;     (list-ref 2 2 #t #f)
;;;     (append 2 2 #t #f)
;;;     (append! 2 infinity #t #ft)
;;;     (set-car! 2 2 #t #f)
;;;     (set-cdr! 2 2 #t #f)
;;;     (list 0 infinity #t #f)
;;;     (length 1 1 #t #f)
;;;     (pair-length 1 1 #t #f)
;;;     (last 1 1 #t #f)
;;;     (butlast 1 1 #t #f)
;;;     (newline 0 1 #t #t)
;;;     (display 1 2 #t #t)
;;;     (write 1 2 #t #t)
;;;     (write-char 1 1 #t #t)
;;;     (null? 1 1 #t #f)
;;;     (list? 1 1 #t #f)
;;;     (pair? 1 1 #t #f)
;;;     (atom? 1 1 #t #f)
;;;     (eq? 1 infinity #t #f)
;;;     (eqv? 1 infinity #t #f)
;;;     (equal? 1 infinity #t #f)
;;;     (boolean? 1 1 #t #f)
;;;     (procedure? 1 1 #t #f)
;;;     (number? 1 1 #t #f)
;;;     (integer? 1 1 #t #f)
;;;     (real? 1 1 #t #f)
;;;     (rational? 1 1 #t #f)
;;;     (complex? 1 1 #t #f)
;;;     (exact? 1 1 #t #f)
;;;     (inexact? 1 1 #t #f)
;;;     (symbol? 1 1 #t #f)
;;;     (string? 1 1 #t #f)
;;;     (char? 1 1 #t #f)
;;;     (bignum? 1 1 #t #f)
;;;     (vector? 1 1 #t #f)
;;;     (macro? 1 1 #t #f)
;;;     (macro-name? 1 1 #t #f)
;;;     (hygienic-name? 1 1 #t #f)
;;;     (zero? 1 1 #t #f)
;;;     (+ 0 infinity #t #f)
;;;     (- 1 infinity #t #f)
;;;     (* 0 infinity #t #f)
;;;     (/ 1 infinity #t #f)
;;;     (< 1 infinity #t #f)
;;;     (<= 1 infinity #t #f)
;;;     (> 1 infinity #t #f)
;;;     (>= 1 infinity #t #f)
;;;     (= 1 infinity #t #f)
;;;     (sin 1 1 #t #f)
;;;     (cos 1 1 #t #f)
;;;     (tan 1 1 #t #f)
;;;     (asin 1 1 #t #f)
;;;     (acos 1 1 #t #f)
;;;     (atan 1 2 #t #f)
;;;     (log 1 1 #t #f)
;;;     (exp 1 1 #t #f)
;;;     (sqrt 1 1 #t #f)
;;;     (expt 2 2 #t #f)
;;;     (not 1 1 #t #f)
;;;     (odd? 1 1 #t #f)
;;;     (even? 1 1 #t #f)
;;;     (floor 1 1 #t #f)
;;;     (ceiling 1 1 #t #f)
;;;     (truncate 1 1 #t #f)
;;;     (round 1 1 #t #f)
;;;     (numerator 1 1 #t #f)
;;;     (denominator 1 1 #t #f)
;;;     (positive? 1 1 #t #f)
;;;     (negative? 1 1 #t #f)
;;;     (abs 1 1 #t #f)
;;;     (max 1 infinity #t #f)
;;;     (min 1 infinity #t #f)
;;;     (real-part 1 1 #t #f)
;;;     (imag-part 1 1 #t #f)
;;;     (magnitude 1 1 #t #f)
;;;     (angle 1 1 #t #f)
;;;     (make-rectangular 2 2 #t #f)
;;;     (make-polar 2 2 #t #f)
;;;     (exact->inexact 1 1 #t #f)
;;;     (inexact->exact 1 1 #t #f)
;;;     (remainder 2 2 #t #f)
;;;     (modulo 2 2 #t #f)
;;;     (quotient 2 2 #t #f)
;;;     (gcd 0 2 #t #f)
;;;     (lcm 0 2 #t #f)
;;;     (char=? 1 1 #t #f)
;;;     (char>? 1 1 #t #f)
;;;     (char>=? 1 1 #t #f)
;;;     (char<? 1 1 #t #f)
;;;     (char<=? 1 1 #t #f)
;;;     (char-ci=? 1 1 #t #f)
;;;     (char-ci>? 1 1 #t #f)
;;;     (char-ci>=? 1 1 #t #f)
;;;     (char-ci<? 1 1 #t #f)
;;;     (char-ci<=? 1 1 #t #f)
;;;     (char-alphabetic? 1 1 #t #f)
;;;     (char-numeric? 1 1 #t #f)
;;;     (char-whitespace? 1 1 #t #f)
;;;     (char-upper-case? 1 1 #t #f)
;;;     (char-lower-case? 1 1 #t #f)
;;;     (char->integer 1 1 #t #f)
;;;     (integer->char 1 1 #t #f)
;;;     (char-upcase 1 1 #t #f)
;;;     (char-downcase 1 1 #t #f)
;;;     (string-append 1 1 #t #f)
;;;     (number->string 1 1 #t #f)
;;;     (string->number 1 1 #t #f)
;;;     (string=? 1 1 #t #f)
;;;     (string>? 1 1 #t #f)
;;;     (string>=? 1 1 #t #f)
;;;     (string<? 1 1 #t #f)
;;;     (string<=? 1 1 #t #f)
;;;     (string-ci=? 1 1 #t #f)
;;;     (string-ci>? 1 1 #t #f)
;;;     (string-ci>=? 1 1 #t #f)
;;;     (string-ci<? 1 1 #t #f)
;;;     (string-ci<=? 1 1 #t #f)
;;;     (string->symbol 1 1 #t #f)
;;;     (symbol->string 1 1 #t #f)
;;;     (string-length 1 1 #t #f)
;;;     (make-string 1 1 #t #f)
;;;     (string 1 1 #t #f)
;;;     (string-ref 1 1 #t #f)
;;;     (string-set! 1 1 #t #t)
;;;     (substring 1 1 #t #f)
;;;     (string->list 1 1 #t #f)
;;;     (list->string 1 1 #t #f)
;;;     (string-copy 1 1 #t #f)
;;;     (string-fill! 1 1 #t #t)
;;;     (make-vector 2 2 #t #f)
;;;     (vector-set! 3 3 #t #f)
;;;     (vector 1 infinity #t #f)
;;;     (vector-ref 2 2 #t #f)
;;;     (vector-length 1 1 #t #f)
;;;     (vector-fill! 2 2 #t #f)
;;;     (vector->list 1 1 #t #f)
;;;     (list->vector 1 1 #t #f)
;;;     (read 0 1 #t #f)
;;;     (load 1 1 #t #f)
;;;     (open-input-file 1 1 #t #t)
;;;     (open-output-file 1 1 #t #t)
;;;     (close-input-port 1 1 #t #t)
;;;     (close-output-port 1 1 #t #t)
;;;     (eof-object? 1 1 #t #f)
;;;     (input-port? 1 1 #t #f)
;;;     (output-port? 1 1 #t #f)
;;;     (current-input-port 1 1 #t #f)
;;;     (current-output-port 1 1 #t #f)
;;;     (read-char 1 1 #t #f)
;;;     (peek-char 1 1 #t #f)
;;;     (char-ready? 1 1 #t #f)
;;;     (call/cc 1 1 #t #t)
;;;     (exit 0 0 #t #t)
;;;     (gensym 0 1 #t #f)
;;;     (apply 2 infinity #t #f)
;;;     (primitive-name? 1 1 #t #f)
;;;     (macroexpand-1 1 1 #t #f)
;;;     (macroexpand 1 1 #t #f)
;;;     (addr 1 1 #t #f)
;;;     (entity-addr 1 1 #t #f)
;;;     (undefined 0 0 #t #f)
;;;     (step 1 1 #t #t)
;;;     (vm2-step 1 1 #t #t)
;;;     (vm1 1 1 #t #t)
;;;     (vm2 1 1 #t #t)
;;;     (dump 1 2 #t #t)
;;;     (addr-prt 1 1 #t #t)
;;;     (gbc 0 1 #t #t)
;;;     (room 0 0 #t #f)
;;;     (vmcode 1 1 #t #f)
;;;     (env 1 1 #t #f)
;;;     (timer-set 0 0 #t #t)
;;;     (timer-get 0 0 #t #t)
;;;     (timer-gbc 0 0 #t #t)
;;;     (eval 1 1 #t #f)
;;;     (load 1 1 #t #t)
;;;     (error 2 2 #t #t)
;;;     (flush 0 1 #t #t)
;;;     (map 1 infinity #t #f)
;;;     (for-each 1 infinity #t #t)
;;;     (set-trace 0 infinity #t #t)
;;;     (set-untrace 0 infinity #t #t)
;;;     (set-export 1 infinity #t #t)
;;;     (get-module 2 2 #t #f)
;;;     (set-module 2 infinity #t #t)
;;;     (current-module 0 0 #t #f)
;;;     (sel-module 1 1 #t #t)
;;;     (add1 1 1 #t #f)
;;;     (sub1 1 1 #t #f)
;;;     (transfer 1 1 #t #f)
;;;     (randome-integer 1 1 #t #f)
;;;     (debug 1 1 #t #t)
;;;     (prof 1 1 #t #t)
;;;     ))
;;; 
;;; 
;;; (define (primitive? x env)
;;;   (and (not (in-env? x env))
;;;        (assoc x *primitive*)))
;;; 
;;; ;;macroではtail?=#fにして末尾再帰最適化はしない。
;;; (define (comp-lambda args body env tail?)
;;;   (if tail?
;;;       (seq (gen 'args (args-count args))
;;;            (comp-begin body
;;;                        (cons args env) #t #t 
;;;                        (inner-lambda? (macroexpand body)) #t tail?))
;;;       (seq (gen 'args (args-count args))
;;;            (comp-begin body
;;;                        (cons args env) #t #t #f #t tail?))))
;;;       
;;;       
;;; 
;;; (define (args-count x)
;;;   (cond ((symbol? x) -1)
;;;         ((list? x)(length x))
;;;         (else (- (pair-length x)))))
;;; 
;;; (define (length=1? x)
;;;   (and (list? x)
;;;        (= (length x) 1)))
;;; 
;;; (define (lambda-args? x)
;;;   (cond ((null? x) #t)
;;;         ((symbol? x) #t)
;;;         ((atom? x) #f)
;;;         ((not (symbol? (car x))) #f)
;;;         (else (lambda-args? (cdr x)))))
;;; 
;;; (define (symbol-or-list? x)
;;;   (or (symbol? x)
;;;       (list? x)))
;;; 
;;; (define (args-count-check x min max)
;;;   (let ((n (length (cdr x))))
;;;     (cond ((and (>= n min) (eq? max 'infinity)) #t)
;;;           ((and (>= n min) (<= n max)) #t)
;;;           (else (error "incorrect argument count " x)))))
;;;                  
;;; (define (args-type-check x n pred msg)
;;;   (if (pred (list-ref x n))
;;;       #t
;;;       (error msg x)))
;;; 
;;; (define (gen opcode . args)
;;;   (list (cons opcode args)))
;;; 
;;; (define (gen-var var env)
;;;   (let ((p (in-env? var env)))
;;;     (if p
;;;         (gen 'lvar (car p) (cadr p))
;;;         (gen 'gvar var))))
;;; 
;;; (define (gen-set var env)
;;;   (let ((p (in-env? var env)))
;;;     (if p
;;;         (gen 'lset (car p) (cadr p))
;;;         (gen 'gset var))))
;;; 
;;; (define (seq . code)
;;;   (apply append code))
;;; 
;;; (define (gen-label)
;;;   (gensym "L"))
;;; 
;;; (define (label? x)
;;;   (and (symbol? x)
;;;        (char=? (string-ref (symbol->string x) 2) #\L)))
;;; 
;;; 
;;; (define (in-env? symbol env)
;;;   (in-env-iter symbol env 0))
;;; 
;;; (define (in-env-iter symbol env i)
;;;   (cond ((null? env) #f)
;;;         ((in-args? symbol (car env)) (list i (nth-args symbol (car env))))
;;;         (else (in-env-iter symbol (cdr env) (+ i 1)))))
;;; 
;;; (define (in-args? symbol args)
;;;   (cond ((null? args) #f)
;;;         ((and (symbol? args) (eq? symbol args)) #t)
;;;         ((symbol? args) #f)
;;;         ((eq? symbol (car args)) #t)
;;;         (else (in-args? symbol (cdr args)))))
;;; 
;;; 
;;; (define (nth-args symbol args)
;;;   (cond ((and (symbol? args) (eq? symbol args)) 0)
;;;         ((eq? symbol (car args)) 0)
;;;         (else (+ 1 (nth-args symbol (cdr args))))))
;;; 
;;; 
;;; (define (inner-lambda? x)
;;;   (cond ((null? x) #f)
;;;         ((atom? x) #f)
;;;         ((vector? x) #f)
;;;         ((eq? (car x) 'lambda) #t)
;;;         (else (or (inner-lambda? (car x))
;;;                   (inner-lambda? (cdr x))))))
;;; 
;;; 
;;; ;;アセンブラ
;;; ;;アセンブラ
;;; 
;;; (define (asm ls)
;;;   (pass2 ls (pass1 ls))) 
;;; 
;;; 
;;; (define (pass1 x)
;;;   (pass1-iter x 1 '()))
;;; 
;;; (define (pass1-iter ls pc labels)
;;;   (cond ((null? ls) labels)
;;;         ((label? (car ls))
;;;          (pass1-iter (cdr ls) pc (cons (cons (car ls) pc) labels)))
;;;         (else
;;;           (pass1-iter (cdr ls) (+ pc (op-count (car ls))) labels))))
;;; 
;;; (define (pass2 x labels)
;;;   (pass2-iter x 1 '() labels))
;;; 
;;; (define (pass2-iter ls pc obj labels)
;;;   (cond ((null? ls) (reverse obj))
;;;         ((label? (car ls)) (pass2-iter (cdr ls) pc obj labels))
;;;         (else
;;;           (pass2-iter (cdr ls)
;;;                       (+ pc (op-count (car ls)))
;;;                       (append (reverse (mnemonic->code (car ls) labels pc))
;;;                               obj)
;;;                       labels))))
;;; 
;;; (define (mnemonic->code x labels pc)
;;;   (cond ((eq? (car x) 'halt) (list (op-code (car x))))
;;;         ((eq? (car x) 'const) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'lvar) (list (op-code (car x)) (cadr x) (caddr x)))
;;;         ((eq? (car x) 'gvar) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'lset) (list (op-code (car x)) (cadr x) (caddr x)))
;;;         ((eq? (car x) 'gset) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'pop) (list (op-code (car x))))
;;;         ((eq? (car x) 'jump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
;;;         ((eq? (car x) 'tjump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
;;;         ((eq? (car x) 'fjump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
;;;         ((eq? (car x) 'return) (list (op-code (car x))))
;;;         ((eq? (car x) 'args) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'call) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'callj) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'fn) (list (op-code (car x)) (cadr x) (asm (caddr x))))
;;;         ((eq? (car x) 'save) (list (op-code (car x))))
;;;         ((eq? (car x) 'prim) (list (op-code (car x)) (entity-addr (cadr x)) (caddr x)))
;;;         ((eq? (car x) 'def) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'defm) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'neqp) (list (op-code (car x))))
;;;         ((eq? (car x) 'smlp) (list (op-code (car x))))
;;;         ((eq? (car x) 'esmlp) (list (op-code (car x))))
;;;         ((eq? (car x) 'grtp) (list (op-code (car x))))
;;;         ((eq? (car x) 'egrtp) (list (op-code (car x))))
;;;         ((eq? (car x) 'zerp) (list (op-code (car x))))
;;;         ((eq? (car x) 'add1) (list (op-code (car x))))
;;;         ((eq? (car x) 'sub1) (list (op-code (car x))))
;;;         ((eq? (car x) 'add2) (list (op-code (car x))))
;;;         ((eq? (car x) 'sub2) (list (op-code (car x))))))
;;; 
;;; (define (op-count x) 
;;;   (length x))
;;; 
;;; 
;;; (define (op-code? x)
;;;   (member x mnemonic))
;;; 
;;; (define (op-code x)
;;;   (- (length mnemonic) (length (member x mnemonic))))
;;; 
;;; 
;;; (define mnemonic 
;;;   (list 'nop 'halt 'const 'lvar 'gvar 'lset 'gset 'pop 'jump 'tjump 'fjump
;;;         'return 'args 'call 'callj 'fn 'save 'prim 'def 'defm 'defh
;;;         'neqp 'smlp 'esmlp 'grtp 'egrtp 'zerop 
;;;         'add1 'sub1 'add2 'sub2))
