(38 (normal system) ((export pair-length last butlast sys-code sys-env sys-timer-set sys-timer-get sys-timer-gbc primitive-name? macroexpand-1 macroexpand addr entity-addr undefined step vm2-step vm1 vm2 dump addr-prt room macro-name? hygienic-name? gensym flush sys-set-trace sys-set-untrace transfer debug profiler current-module sys-cont-room make-syntactic-closure symbol->identifier identifier->symbol syntactic-closure? identifier? identifier-bind! identifier-free? identifier-bound? identifier-bound global-bound? inspect lambda/asm system)) 2 (normal system) 1)
(38 (normal compile) ((export compile assemble compile-file map for-each and or let let* cond letrec do case call/cc call-with-current-continuation dynamic-wind call-with-values)) 2 (normal compile) 1)
(38 (scheme base) ((import (normal system) (normal compile)) (export car cdr cons caar cdar cddr cadr caaar cdaar cadar caadr cddar caddr cdadr cdddr caaaar cdaaar cadaar caadar caaadr cddaar caddar caaddr cdaadr cdadar cadddr cdaddr cddadr cdddar cddddr assq assv assoc memq memv member reverse reverse! list-tail list-ref append append! set-car! set-cdr! list make-list length newline write-char null? list? pair? atom? eq? eqv? equal? boolean? procedure? number? integer? real? rational? complex? exact? inexact? symbol? string? char? bignum? vector? macro? zero? error + - * / < <= > >= = expt not odd? even? floor ceiling truncate round numerator denominator positive? negative? abs max min exact->inexact inexact->exact remainder modulo quotient gcd lcm string-append number->string string->number string=? string>? string>=? string<? string<=? string-ci=? string-ci>? string-ci>=? string-ci<? string-ci<=? string->symbol symbol->string string-length make-string string string-ref string-set! substring string->list list->string string-copy string-fill! make-vector vector-set! vector vector-ref vector-length vector-fill! vector->list list->vector open-input-file open-output-file close-input-port close-output-port eof-object? input-port? output-port? current-input-port current-output-port read-char peek-char char-ready? exit apply gbc values map for-each and or let let* cond letrec do case call/cc call-with-current-continuation dynamic-wind call-with-values exact-integer? when unless) (begin (define-macro when (lambda (pred . true) (cons 'if (cons pred (cons (cons 'begin (append true '())) '()))))) (define-macro unless (lambda (pred . else) (cons 'if (cons (cons 'not (cons pred '())) (cons (cons 'undefined '()) (cons (cons 'begin (append else '())) '())))))))) 2 (scheme base) 1)
(38 (scheme inexact) ((export sin cos tan asin acos atan log exp sqrt)) 2 (scheme inexact) 1)
(38 (scheme complex) ((export real-part imag-part magnitude angle make-rectangular make-polar)) 2 (scheme complex) 1)
(38 (scheme division) ((import (scheme base)) (export floor/ round/ truncate/ ceiling/) (begin (define (floor/ n1 n2) (when (zero? n2) (error "in floor/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in floor/ not integer " n1 n2)) (let* ((q (floor (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (round/ n1 n2) (when (zero? n2) (error "in round/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in round/ not integer " n1 n2)) (let* ((q (round (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (truncate/ n1 n2) (when (zero? n2) (error "in truncate/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in truncate/ not integer " n1 n2)) (let* ((q (truncate (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (ceiling/ n1 n2) (when (zero? n2) (error "in ceiling/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in ceiling/ not integer " n1 n2)) (let* ((q (ceiling (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))))) 2 (scheme division) 1)
(38 (scheme eval) ((export eval)) 2 (scheme eval) 1)
(38 (scheme load) ((export load)) 2 (scheme load) 1)
(38 (scheme read) ((export read)) 2 (scheme read) 1)
(38 (scheme write) ((export display write)) 2 (scheme write) 1)
(38 (scheme char) ((export char=? char>? char>=? char<? char<=? char-ci=? char-ci>? char-ci>=? char-ci<? char-ci<=? char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case? char->integer integer->char char-upcase char-downcase)) 2 (scheme char) 1)
(38 (scheme lazy) ((export delay force) (import (scheme base)) (begin (define-macro delay (lambda (expr) (cons 'make-promise (cons (cons 'lambda (cons '() (cons expr '()))) '())))) (define make-promise (lambda (p) (let ((val #f) (set? #f)) (lambda () (if (not set?) (let ((x (p))) (if (not set?) (begin (set! val x) (set! set? #t)) '())) '()) val)))) (define force (lambda (x) (if (procedure? x) (x) x))))) 2 (scheme lazy) 1)
(38 (scheme time) ((import (normal system) (scheme base) (scheme write)) (export time) (begin (define-macro time (lambda (expr) (cons 'begin (cons (cons 'gbc '()) (cons (cons 'sys-timer-set '()) (cons (cons 'display (cons expr '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"total " '())) (cons (cons 'display (cons (cons 'sys-timer-get '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"GC    " '())) (cons (cons 'display (cons (cons 'sys-timer-gbc '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) '()))))))))))))))))) 2 (scheme time) 1)
(38 (scheme file) ((export call-with-input-file call-with-output-file with-input-from-file with-output-to-file file-exists? delete-file) (import (scheme base) (normal system)) (begin (define (call-with-input-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc p))) (close-input-port p) v))) (define (call-with-output-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc p))) (close-output-port p) v))) (define (with-input-from-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc))) (close-input-port p) v))) (define (with-output-to-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc))) (close-output-port p) v))) (define (delete-file x) (when (not (string? x)) (error "in delete-file require string " x)) (system (string-append "del " x))))) 2 (scheme file) 1)
(38 (normal test) ((import (scheme base) (scheme write)) (export test*) (begin (define-macro test* (lambda (name expected expr) (cons 'let (cons (cons (cons 'result (cons (cons 'quote (cons '() '())) '())) '()) (cons (cons 'display (cons '"test " '())) (cons (cons 'display (cons name '())) (cons (cons 'display (cons '", expects " '())) (cons (cons 'display (cons expected '())) (cons (cons 'display (cons '" ==> " '())) (cons (cons 'set! (cons 'result (cons expr '()))) (cons (cons 'if (cons (cons 'equal? (cons 'result (cons expected '()))) (cons (cons 'display (cons '"ok\n" '())) (cons (cons 'begin (cons (cons 'display (cons '"ERROR: GOT " '())) (cons (cons 'display (cons 'result '())) (cons (cons 'newline '()) '())))) '())))) '()))))))))))))) 2 (normal test) 1)
(38 (normal debug) ((import (normal system) (scheme base)) (export trace untrace debug step profiler) (begin (define-macro trace (lambda fn (cons 'sys-set-trace (append (map (lambda (x) (list 'quote x)) fn) '())))) (define-macro untrace (lambda fn (cons 'sys-set-untrace (append (map (lambda (x) (list 'quote x)) fn) '())))))) 2 (normal debug) 1)
(40 ((scheme base)) 1)
(40 ((scheme load)) 1)
(40 ((scheme write)) 1)
(40 ((scheme read)) 1)
(40 ((scheme eval)) 1)
