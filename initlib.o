(38 (normal system) ((export pair-length last butlast sys-code sys-env sys-timer-set sys-timer-get sys-timer-gbc primitive-name? macroexpand-1 macroexpand addr entity-addr undefined step vm2-step vm1 vm2 dump addr-prt room macro-name? hygienic-name? gensym flush sys-set-trace sys-set-untrace transfer debug profiler current-module sys-cont-room make-syntactic-closure symbol->identifier identifier->symbol syntactic-closure? identifier? identifier-bind! identifier-free? identifier-bound? identifier-bound global-bound? inspect lambda/asm system)) 2 (normal system) 1)
(38 (normal compile) ((export compile assemble compile-file map for-each and or let let* cond letrec do case call/cc call-with-current-continuation dynamic-wind call-with-values)) 2 (normal compile) 1)
(38 (scheme inexact) ((export sin cos tan asin acos atan log exp sqrt infinity? finity? nan?)) 2 (scheme inexact) 1)
(38 (scheme base) ((import (normal system) (normal compile) (only (scheme inexact) sqrt) (scheme char)) (export car cdr cons caar cdar cddr cadr caaar cdaar cadar caadr cddar caddr cdadr cdddr caaaar cdaaar cadaar caadar caaadr cddaar caddar caaddr cdaadr cdadar cadddr cdaddr cddadr cdddar cddddr assq assv assoc memq memv member reverse reverse! list-tail list-ref list-set! append append! set-car! set-cdr! list make-list length newline write-char null? list? pair? atom? eq? eqv? equal? boolean? procedure? number? integer? real? rational? complex? exact? inexact? symbol? string? char? bignum? vector? macro? zero? error + - * / < <= > >= = expt not odd? even? floor ceiling truncate round numerator denominator positive? negative? abs max min exact->inexact inexact->exact remainder modulo quotient gcd lcm string-append number->string string->number exact inexact exact-integer-sqrt string=? string>? string>=? string<? string<=? string-ci=? string-ci>? string-ci>=? string-ci<? string-ci<=? string->symbol symbol->string string-length make-string string string-ref string-set! substring string->list list->string string-copy string-fill! make-vector vector-set! vector vector-ref vector-length vector-fill! vector->list list->vector open-input-file open-output-file close-input-port close-output-port eof-object? input-port? output-port? current-input-port current-output-port read-char peek-char char-ready? apply gbc values flush-output-port square map for-each and or let let* cond letrec do case call/cc call-with-current-continuation dynamic-wind call-with-values exact-integer? when unless with-exception-handler raise raise-continuable bytevector? make-bytevector bytevector bytevector-length string-map vector-map bytevector-u8-set! bytevector-u8-ref bytevector-copy bytevector-copy! bytevector-append) (begin (define-macro when (lambda (pred . true) (cons 'if (cons pred (cons (cons 'begin (append true '())) '()))))) (define-macro unless (lambda (pred . else) (cons 'if (cons (cons 'not (cons pred '())) (cons (cons 'undefined '()) (cons (cons 'begin (append else '())) '())))))) (define *current-exception-handlers* (list (lambda (condition) (error "unhandled exception" condition)))) (define (with-exception-handler handler thunk) (with-exception-handlers (cons handler *current-exception-handlers*) thunk)) (define (with-exception-handlers new-handlers thunk) (let ((previous-handlers *current-exception-handlers*)) (dynamic-wind (lambda () (set! *current-exception-handlers* new-handlers)) thunk (lambda () (set! *current-exception-handlers* previous-handlers))))) (define (raise obj) (let ((handlers *current-exception-handlers*)) (with-exception-handlers (cdr handlers) (lambda () ((car handlers) obj) (error "handler returned" (car handlers) obj))))) (define (raise-continuable obj) (let ((handlers *current-exception-handlers*)) (with-exception-handlers (cdr handlers) (lambda () ((car handlers) obj))))) (define (string-map f . args) (list->string (reverse (string-map1 f (apply min (map string-length args)) args)))) (define (string-map1 f n args) (if (= n 0) '() (cons (apply f (string-nth (- n 1) args)) (string-map1 f (- n 1) args)))) (define (string-nth n args) (if (null? args) '() (cons (string-ref (car args) n) (string-nth n (cdr args))))) (define (vector-map f . args) (list->vector (reverse (vector-map1 f (apply min (map vector-length args)) args)))) (define (vector-map1 f n args) (if (= n 0) '() (cons (apply f (vector-nth (- n 1) args)) (vector-map1 f (- n 1) args)))) (define (vector-nth n args) (if (null? args) '() (cons (vector-ref (car args) n) (vector-nth n (cdr args))))) (define (exact-integer-sqrt k) (if (negative? k) (error "in exact-integer-sqrt negative " k)) (if (not (exact? k)) (error "in exact-integer-sqrt inexact " k)) (let* ((s (exact (floor (sqrt k)))) (r (- k (square s)))) (values s r))))) 2 (scheme base) 1)
(38 (scheme complex) ((export real-part imag-part magnitude angle make-rectangular make-polar)) 2 (scheme complex) 1)
(38 (scheme division) ((import (scheme base)) (export floor/ floor-quotient floor-remainder round/ round-quotient round-remainder truncate/ truncate-quotient truncate-remainder) (begin (define (floor/ n1 n2) (when (zero? n2) (error "in floor/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in floor/ not integer " n1 n2)) (let* ((q (floor (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (floor-quotient n1 n2) (when (zero? n2) (error "in floor-quotient devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in floor-quotient not integer " n1 n2)) (let* ((q (floor (/ n1 n2))) (r (- n1 (* n2 q)))) q)) (define (floor-remainder n1 n2) (when (zero? n2) (error "in floor-remainder devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in floor-remainder not integer " n1 n2)) (let* ((q (floor (/ n1 n2))) (r (- n1 (* n2 q)))) r)) (define (round/ n1 n2) (when (zero? n2) (error "in round/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in round/ not integer " n1 n2)) (let* ((q (round (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (round-quotient n1 n2) (when (zero? n2) (error "in round-quotient devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in round-quotient not integer " n1 n2)) (let* ((q (round (/ n1 n2))) (r (- n1 (* n2 q)))) q)) (define (round-remainder n1 n2) (when (zero? n2) (error "in round-remainder devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in round-remainder not integer " n1 n2)) (let* ((q (round (/ n1 n2))) (r (- n1 (* n2 q)))) r)) (define (truncate/ n1 n2) (when (zero? n2) (error "in truncate/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in truncate/ not integer " n1 n2)) (let* ((q (truncate (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (truncate-quotient n1 n2) (when (zero? n2) (error "in truncate-quotient devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in truncate-quotient not integer " n1 n2)) (let* ((q (truncate (/ n1 n2))) (r (- n1 (* n2 q)))) q)) (define (truncate-remainder n1 n2) (when (zero? n2) (error "in truncate-remainder devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in truncate-remainder not integer " n1 n2)) (let* ((q (truncate (/ n1 n2))) (r (- n1 (* n2 q)))) r)))) 2 (scheme division) 1)
(38 (scheme eval) ((export eval)) 2 (scheme eval) 1)
(38 (scheme load) ((export load)) 2 (scheme load) 1)
(38 (scheme read) ((export read)) 2 (scheme read) 1)
(38 (scheme write) ((export display write)) 2 (scheme write) 1)
(38 (scheme char) ((export char=? char>? char>=? char<? char<=? char-ci=? char-ci>? char-ci>=? char-ci<? char-ci<=? char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case? char->integer integer->char char-upcase char-downcase)) 2 (scheme char) 1)
(38 (scheme lazy) ((export delay force) (import (scheme base)) (begin (define-macro delay (lambda (expr) (cons 'make-promise (cons (cons 'lambda (cons '() (cons expr '()))) '())))) (define make-promise (lambda (p) (let ((val #f) (set? #f)) (lambda () (if (not set?) (let ((x (p))) (if (not set?) (begin (set! val x) (set! set? #t)) '())) '()) val)))) (define force (lambda (x) (if (procedure? x) (x) x))))) 2 (scheme lazy) 1)
(38 (scheme process-context) ((export command-line get-environment-variable exit)) 2 (scheme process-context) 1)
(38 (scheme time) ((import (normal system) (scheme base) (scheme write)) (export current-jiffy jiffies-per-second time) (begin (define-macro time (lambda (expr) (cons 'begin (cons (cons 'gbc '()) (cons (cons 'sys-timer-set '()) (cons (cons 'display (cons expr '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"total " '())) (cons (cons 'display (cons (cons 'sys-timer-get '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"GC    " '())) (cons (cons 'display (cons (cons 'sys-timer-gbc '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) '()))))))))))))))))) 2 (scheme time) 1)
(38 (scheme file) ((export call-with-input-file call-with-output-file with-input-from-file with-output-to-file file-exists? delete-file) (import (scheme base) (normal system)) (begin (define (call-with-input-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc p))) (close-input-port p) v))) (define (call-with-output-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc p))) (close-output-port p) v))) (define (with-input-from-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc))) (close-input-port p) v))) (define (with-output-to-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc))) (close-output-port p) v))) (define (delete-file x) (when (not (string? x)) (error "in delete-file require string " x)) (system (string-append "del " x))))) 2 (scheme file) 1)
(38 (normal test) ((import (scheme base) (scheme write)) (export test*) (begin (define-macro test* (lambda (name expected expr) (cons 'let (cons (cons (cons 'result (cons (cons 'quote (cons '() '())) '())) '()) (cons (cons 'display (cons '"test " '())) (cons (cons 'display (cons name '())) (cons (cons 'display (cons '", expects " '())) (cons (cons 'display (cons expected '())) (cons (cons 'display (cons '" ==> " '())) (cons (cons 'set! (cons 'result (cons expr '()))) (cons (cons 'if (cons (cons 'equal? (cons 'result (cons expected '()))) (cons (cons 'display (cons '"ok\n" '())) (cons (cons 'begin (cons (cons 'display (cons '"ERROR: GOT " '())) (cons (cons 'display (cons 'result '())) (cons (cons 'newline '()) '())))) '())))) '()))))))))))))) 2 (normal test) 1)
(38 (normal debug) ((import (normal system) (scheme base)) (export trace untrace debug step profiler) (begin (define-macro trace (lambda fn (cons 'sys-set-trace (append (map (lambda (x) (list 'quote x)) fn) '())))) (define-macro untrace (lambda fn (cons 'sys-set-untrace (append (map (lambda (x) (list 'quote x)) fn) '())))))) 2 (normal debug) 1)
(40 ((scheme base) (scheme load) (scheme write) (scheme read) (scheme eval) (scheme char) (scheme inexact) (only (scheme process-context) exit)) 1)
