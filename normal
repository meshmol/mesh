;;‰“™ŠÖ”ƒ‰ƒCƒuƒ‰ƒŠ


;;ƒŠƒXƒgls‚ÉŠÖ”f‚ğ“K—p‚µ‚½’l‚Ì‘˜a‚ğ‹‚ß‚éB
(define (sum f ls)
  (if (null? ls)
      0
      (+ (f (car ls)) (sum f (cdr ls)))))

;;ls‚ÌŠe—v‘f‚É‚Â‚¢‚ÄŠÖ”f‚ğ“K—p‚µ‚Ä‚»‚ÌÏ‚ğ‹‚ß‚éB
(define (product f ls)
  (if (null? ls)
      1
      (* (f (car ls)) (product f (cdr ls)))))


;;ƒŠƒXƒgls‚Ì—v‘f‚·‚×‚Ä‚É‚Â‚¢‚ÄŠÖ”‚†‚ª¬‚è—§‚Â‚©H
(define (for-all f ls)
  (cond ((null? ls) #t)
        ((not (f (car ls))) #f)
        (else (for-all f (cdr ls)))))

;;ƒŠƒXƒgls‚Ì­‚È‚­‚Æ‚à1‚Â‚ÉŠÖ”‚†‚ª¬‚è—§‚Â‚©H
(define (at-least f ls)
  (cond ((null? ls) #f)
        ((f (car ls)) #t)
        (else (at-least f (cdr ls)))))

;;ƒKƒEƒX‚Ì‘f”’è—‚É‚æ‚è‚wˆÈ‰º‚Ì‘f”‚ÌŠT”‚ğ•Ô‚·B
(define (gauss-primes x)
  (/ x (log x)))

;;‚‚Æ‚‚ªŒİ‚¢‚É‘f‚Å‚ ‚ê‚Î#t ‚»‚¤‚Å‚È‚¯‚ê‚Î#f
(define (coprime? m n)
  (= (gcd  m n) 1))

;;ƒIƒCƒ‰[‚ÌƒÓŠÖ”
;;’è‹`’Ê‚è‚É‘f–p‚ÉŒvZ‚µ‚Ä‚¢‚é‚Ì‚Å’x‚¢B
;;ŒŸZ—p
(define (phi2 n)
  (define (iter m x)
    (cond ((> m n) x)
          ((coprime? m n) (iter (+ m 1) (+ x 1)))
          (else (iter (+ m 1) x))))
  (iter 1 0))

;;ƒIƒCƒ‰[‚ÌƒÓŠÖ”
;;‚ˆÈ‰º‚Ì”‚Å‚‚ÆŒİ‚¢‚É‘f‚Å‚ ‚é‚à‚Ì‚ÌŒÂ”‚ğ•Ô‚·B
;;‘fˆö”•ª‰ğ‚É‚æ‚èŒvZ‚µ‚Ä‚¢‚éB ƒÓ(n=p^a q^b r^c) = n(1-1/p)(1-1/q)(1-1/r)
(define (phi n)
  (if (= n 1)
      1
      (inexact->exact
        (exact->inexact
          (* n (product (lambda (ls) (- 1 (/ 1 (car ls)))) (prime-factors n)))))))

;;‚‚ª‚‚ÅŠ„‚èØ‚ê‚é‚©‚Ç‚¤‚©BŠ„‚èØ‚ê‚ê‚Î#t ‚»‚¤‚Å‚È‚¯‚ê‚Î#f
;; n|m ‘Š“–
(define (divisible? m n)
  (= (modulo m n) 0))

;;‚‚ª‚‚ÅŠ„‚èØ‚ê‚é‚©‚Ç‚¤‚©BŠ„‚èØ‚ê‚ê‚Î#t ‚»‚¤‚Å‚È‚¯‚ê‚Î#f
;; n|m ‘Š“–
(define (divisible? m n)
  (= (modulo m n) 0))

;;‚‚Æ‚‚ª–@‚‚Å‡“¯‚©‚Ç‚¤‚©B‡“¯‚È‚ç#t ‚»‚¤‚Å‚È‚¯‚ê‚Î#f
(define (eqmod? m n a)
  (= (modulo m a) (modulo n a)))

;;n‚ğ‘fˆö”•ª‰ğ‚·‚éBw”Œ`®‚Å‚Í‚È‚­’Pƒ‚É‘f”‚ğ•À‚×‚½ƒŠƒXƒg‚Å•Ô‚·B
;;prime-factors‚Ì‰º¿‚¯
;;n‚ª‘å‚«‚È‘f”‚¾‚Á‚½ê‡‚É”õ‚¦A‘f””»’èiƒ~ƒ‰[ƒ‰ƒrƒ“j‚µ‚ÄƒŠƒXƒg‚É‚·‚éˆ—‚ğ‚µ‚Ä‚¢‚éB
;;n<0‚Ìê‡‚É‚Í#fAn=0,n=1‚Ìê‡‚É‚Í'(0),'(1)‚ğ•Ô‚·B
(define (prime-factors2 n)
  (define (iter p x ls z)
    (cond ((= x 1) ls)
          ((> p z) (cons x ls))
          ((divisible? x p) (iter1 p (/ x p) (cons p ls)))
          ((= p 2) (iter 3 x ls z))
          (else (iter (+ p 2) x ls z))))
  (define (iter1 p x ls)
    (if (divisible? x p)
        (iter1 p (/ x p) (cons p ls))
        (iter p x ls (sqrt x))))
  (cond ((< n 0) #f)
        ((= n 0) '(0))
        ((= n 1) '(1))
        ((prime? n) (list n))
        (else (iter 2 n '() (sqrt n)))))

;;n‚ğ‘fˆö”•ª‰ğ‚µ‚Ä•W€Œ`®‚É‚µ‚Ä•Ô‚·Bp^a + q^b + r^c ((p a)(q b)(r c))
(define (prime-factors n)
  (define (iter ls p n mult)
    (cond ((null? ls) (cons (list p n) mult))
          ((eq? (car ls) p) (iter (cdr ls) p (+ n 1) mult))
          (else (iter (cdr ls) (car ls) 1 (cons (list p n) mult)))))
  (let ((ls (prime-factors2 n)))
    (iter (cdr ls) (car ls) 1 '())))

;;‘f””»’è 10^11‚æ‚è¬‚³‚¯‚ê‚ÎŒˆ’è“I”»’èƒAƒ‹ƒSƒŠƒYƒ€A‘å‚«‚¯‚ê‚Îƒ‰ƒrƒ“ƒ~ƒ‰[–@‚Å”»’è
(define (prime? n)
  (if (< n 100000000000)
      (deterministic-prime? n)
      (rabin-miller? n)))


;;Œˆ’è“I•û–@‚Ån‚ª‘f”‚Å‚ ‚é‚©‚Ç‚¤‚©‚ğ•Ô‚·B
;;‘f”‚È‚ç‚Î#t ‚»‚¤‚Å‚È‚¯‚ê‚Î#f
;;‘å‚«‚È‘f”‚É‘Î‚µ‚Ä‚ÍŠÔ‚ª‚©‚©‚éB
(define (deterministic-prime? n)
  (define (iter x y)
    (cond ((> x y) #t)
          ((divisible? n x) #f)
          ((= x 2) (iter 3 y))
          (else (iter (+ x 2) y))))
  (if (< n 2)
      #f
      (iter 2 (sqrt n))))



;;ƒtƒFƒ‹ƒ}‚Ì¬’è—‚ğ—˜—p‚µ‚ÄŠm—¦“I‚É‘f””»’è‚ğ‚·‚éB
;;‘f”‚È‚ç#t ‚»‚¤‚Å‚È‚¯‚ê‚Î#f
;;’ê‚ğ2`n-1‚Ü‚Å—”¶¬‚µ‚Ä10‰ñs‚·‚éB
(define (fermat? n)
  (define (iter t)
    (cond ((< t 1) #t)
          ((not (= 1 (gaussmod (+ (random (- n 2)) 1) (- n 1) n))) #f)
          (else (iter (- t 1)))))
  (iter 10))

;;ƒƒ‹ƒZƒ“ƒk”(2^p-1)‚É‘Î‚·‚éƒ‹ƒJƒX-ƒeƒXƒg
;;‘f”‚È‚ç‚Î#t ‚»‚¤‚Å‚È‚¯‚ê‚Î#f
(define (lucas? p)
  (define (iter n i m)
    (cond ((and (= i (- p 1)) (zero? (modulo n m))) #t)
          ((and (= i (- p 1)) (not (zero? (modulo n m)))) #f)
          (else (iter (modulo (- (expt n 2) 2) m) (+ i 1) m))))
  (cond ((< p 2) #f)
        ((= p 2) #t)
        (else (iter 4 1 (mersenne p)))))

;;ƒtƒFƒ‹ƒ}[”
(define (fermat-number n)
  (+ (expt 2 (expt 2 n)) 1))

;;ƒ‰ƒrƒ“ƒ~ƒ‰[ƒeƒXƒg
;;ƒeƒXƒg‘ÎÛ‚Ì‚‚ğ n^k * q ‚É•ª‰ğ‚·‚éB
(define (rm1 n)
  (define (iter k q)
    (if (not (= (modulo q 2) 0))
        (list k q)
        (iter (+ k 1) (/ q 2))))
  (iter 0 (- n 1)))

;;ƒ‰ƒrƒ“ƒ~ƒ‰[ƒeƒXƒgğŒ‚P
;;‡¬”‚È‚ç#t ‘f”‚È‚ç#f
(define (rm2 a q n)
  (not (= (gaussmod a q n) 1)))

;;ƒ‰ƒrƒ“ƒ~ƒ‰[ƒeƒXƒgğŒ‚Q
;;‡¬”‚È‚ç#t ‘f”‚È‚ç#f
(define (rm3 a k q n)
  (define (iter i)
    (cond ((>= i k) #t)
          ((= (gaussmod a (* (expt 2 i) q) n) -1) #f)
          (else (iter (+ i 1)))))
  (iter 0))


;;ƒ‰ƒrƒ“ƒ~ƒ‰[ƒeƒXƒg
;;n‚É‚Â‚¢‚Ä’êa‚ÅğŒ‚PC‚Q‚ğƒeƒXƒg
;;‡¬”‚È‚ç#t ‘f”‚È‚ç#f
(define (rm4 n a)
  (let* ((ls (rm1 n))
         (k (car ls))
         (q (cadr ls)))
    (and (rm2 a q n)
         (rm3 a k q n))))

;;ƒ‰ƒrƒ“ƒ~ƒ‰[ƒeƒXƒg
;;ŠÖ”–{‘Ì
;;’ê‚ğ2`n-1‚Ü‚Å—”‚Å”­¶‚³‚¹10‰ñs‚·‚éB
;;‘f”‚È‚ç#t ‡¬”‚È‚ç#f
;;‹[‘f”‚Å‚ ‚éŠm—¦‚Í 0.25^10 ‚¨‚æ‚»0.000095% 
(define (rabin-miller? n)
  (define (iter t)
    (cond ((< t 1) #f)
          ((rm4 n (+ (random (- n 2)) 1)) #t)
          (else (iter (- t 1)))))
  (if (= n 2)
      #t
      (not (iter 10))))

(define (random n)
  (* (random-integer (quotient n 100000000000))
     100000000000))

;;sicp
;;ŒJ‚è•Ô‚µ“ñæ–@‚É‚æ‚émodŒvZB
;; a^n (mod m)‚ğŒvZ‚·‚éBSICP‚æ‚èØ—pB
(define (square n) (* n n))
(define (expmod a n m)
  (cond ((= 0 n) 1)
        ((even? n)
         (remainder (square (expmod a (/ n 2) m)) m))
        (else
         (remainder (* a (expmod a (- n 1) m)) m))))

;;ŒJ‚è•Ô‚µ“ñæ–@‚É‚æ‚émodŒvZ‚ÅŒ‹‰Ê‚ğ–@‚‚Æ‚µ‚½ê‡ -m/2`m/2 ‚Å•\‚·B
(define (gaussmod a k m)
  (let ((k1 (expmod a k m)))
    (cond ((and (> k1 0) (> k1 (/ m 2)) (< k1 m)) (- k1 m))
          ((and (< k1 0) (< k1 (- (/ m 2))) (> k1 (- m))) (+ k1 m))
          (else k1))))

;;ƒxƒ“ƒ`


(define tarai
  (lambda (x y z)
    (if (<= x y)
        y
        (tarai (tarai (- x 1) y z)
               (tarai (- y 1) z x)
               (tarai (- z 1) x y)))))

(define fact
  (lambda (n)
    (if (zero? n)
        1
        (* n (fact (- n 1))))))


(define fib
  (lambda (n)
    (if (< n 2)
        n
        (+ (fib (- n 2)) (fib (- n 1))))))

(define (ack m n)
  (cond ((= m 0) (+ n 1))
        ((= n 0) (ack (- m 1) 1))
        (else (ack (- m 1) (ack m (- n 1))))))

;;; BOYER -- Logic programming benchmark, originally written by Bob Boyer.
;;; Fairly CONS intensive.

(define (lookup key table)
  (let loop ((x table))
    (if (null? x)
      #f
      (let ((pair (car x)))
        (if (eq? (car pair) key)
          pair
          (loop (cdr x)))))))

(define properties '())

(define (get key1 key2)
  (let ((x (lookup key1 properties)))
    (if x
      (let ((y (lookup key2 (cdr x))))
        (if y
          (cdr y)
          #f))
      #f)))

(define (put key1 key2 val)
  (let ((x (lookup key1 properties)))
    (if x
      (let ((y (lookup key2 (cdr x))))
        (if y
          (set-cdr! y val)
          (set-cdr! x (cons (cons key2 val) (cdr x)))))
      (set! properties
        (cons (list key1 (cons key2 val)) properties)))))

(define unify-subst '())

(define (add-lemma term)
  (cond ((and (pair? term)
              (eq? (car term)
                   (quote equal))
              (pair? (cadr term)))
         (put (car (cadr term))
              (quote lemmas)
              (cons term (get (car (cadr term)) (quote lemmas)))))
        (else (fatal-error "ADD-LEMMA did not like term:  " term))))

(define (add-lemma-lst lst)
  (cond ((null? lst)
         #t)
        (else (add-lemma (car lst))
              (add-lemma-lst (cdr lst)))))

(define (apply-subst alist term)
  (cond ((not (pair? term))
         (cond ((assq term alist) => cdr)
               (else term)))
        (else (cons (car term)
                    (apply-subst-lst alist (cdr term))))))

(define (apply-subst-lst alist lst)
  (cond ((null? lst)
         '())
        (else (cons (apply-subst alist (car lst))
                    (apply-subst-lst alist (cdr lst))))))

(define (falsep x lst)
  (or (equal? x (quote (f)))
      (member x lst)))

(define (one-way-unify term1 term2)
  (begin (set! unify-subst '())
         (one-way-unify1 term1 term2)))

(define (one-way-unify1 term1 term2)
  (cond ((not (pair? term2))
         (cond ((assq term2 unify-subst) =>
                (lambda (x) (equal? term1 (cdr x))))
               (else (set! unify-subst (cons (cons term2 term1)
                                             unify-subst))
                     #t)))
        ((not (pair? term1))
         #f)
        ((eq? (car term1)
              (car term2))
         (one-way-unify1-lst (cdr term1)
                             (cdr term2)))
        (else #f)))

(define (one-way-unify1-lst lst1 lst2)
  (cond ((null? lst1)
         #t)
        ((one-way-unify1 (car lst1)
                         (car lst2))
         (one-way-unify1-lst (cdr lst1)
                             (cdr lst2)))
        (else #f)))

(define (rewrite term)
  (cond ((not (pair? term))
         term)
        (else (rewrite-with-lemmas (cons (car term)
                                         (rewrite-args (cdr term)))
                                   (get (car term)
                                        (quote lemmas))))))

(define (rewrite-args lst)
  (cond ((null? lst)
         '())
        (else (cons (rewrite (car lst))
                    (rewrite-args (cdr lst))))))

(define (rewrite-with-lemmas term lst)
  (cond ((or (not lst) (null? lst))
         term)
        ((one-way-unify term (cadr (car lst)))
         (rewrite (apply-subst unify-subst (caddr (car lst)))))
        (else (rewrite-with-lemmas term (cdr lst)))))

(define (setup)
  (add-lemma-lst
   (quote ((equal (compile form)
                  (reverse (codegen (optimize form)
                                    (nil))))
           (equal (eqp x y)
                  (equal (fix x)
                         (fix y)))
           (equal (greaterp x y)
                  (lessp y x))
           (equal (lesseqp x y)
                  (not (lessp y x)))
           (equal (greatereqp x y)
                  (not (lessp x y)))
           (equal (boolean x)
                  (or (equal x (t))
                      (equal x (f))))
           (equal (iff x y)
                  (and (implies x y)
                       (implies y x)))
           (equal (even1 x)
                  (if (zerop x)
                      (t)
                      (odd (_1- x))))
           (equal (countps- l pred)
                  (countps-loop l pred (zero)))
           (equal (fact- i)
                  (fact-loop i 1))
           (equal (reverse- x)
                  (reverse-loop x (nil)))
           (equal (divides x y)
                  (zerop (remainder y x)))
           (equal (assume-true var alist)
                  (cons (cons var (t))
                        alist))
           (equal (assume-false var alist)
                  (cons (cons var (f))
                        alist))
           (equal (tautology-checker x)
                  (tautologyp (normalize x)
                              (nil)))
           (equal (falsify x)
                  (falsify1 (normalize x)
                            (nil)))
           (equal (prime x)
                  (and (not (zerop x))
                       (not (equal x (add1 (zero))))
                       (prime1 x (_1- x))))
           (equal (and p q)
                  (if p (if q (t)
                              (f))
                        (f)))
           (equal (or p q)
                  (if p (t)
                        (if q (t)
                              (f))
                        (f)))
           (equal (not p)
                  (if p (f)
                        (t)))
           (equal (implies p q)
                  (if p (if q (t)
                              (f))
                        (t)))
           (equal (fix x)
                  (if (numberp x)
                      x
                      (zero)))
           (equal (if (if a b c)
                      d e)
                  (if a (if b d e)
                        (if c d e)))
           (equal (zerop x)
                  (or (equal x (zero))
                      (not (numberp x))))
           (equal (plus (plus x y)
                        z)
                  (plus x (plus y z)))
           (equal (equal (plus a b)
                         (zero))
                  (and (zerop a)
                       (zerop b)))
           (equal (difference x x)
                  (zero))
           (equal (equal (plus a b)
                         (plus a c))
                  (equal (fix b)
                         (fix c)))
           (equal (equal (zero)
                         (difference x y))
                  (not (lessp y x)))
           (equal (equal x (difference x y))
                  (and (numberp x)
                       (or (equal x (zero))
                           (zerop y))))
           (equal (meaning (plus-tree (append x y))
                           a)
                  (plus (meaning (plus-tree x)
                                 a)
                        (meaning (plus-tree y)
                                 a)))
           (equal (meaning (plus-tree (plus-fringe x))
                           a)
                  (fix (meaning x a)))
           (equal (append (append x y)
                          z)
                  (append x (append y z)))
           (equal (reverse (append a b))
                  (append (reverse b)
                          (reverse a)))
           (equal (times x (plus y z))
                  (plus (times x y)
                        (times x z)))
           (equal (times (times x y)
                         z)
                  (times x (times y z)))
           (equal (equal (times x y)
                         (zero))
                  (or (zerop x)
                      (zerop y)))
           (equal (exec (append x y)
                        pds envrn)
                  (exec y (exec x pds envrn)
                          envrn))
           (equal (mc-flatten x y)
                  (append (flatten x)
                          y))
           (equal (member x (append a b))
                  (or (member x a)
                      (member x b)))
           (equal (member x (reverse y))
                  (member x y))
           (equal (length (reverse x))
                  (length x))
           (equal (member a (intersect b c))
                  (and (member a b)
                       (member a c)))
           (equal (nth (zero)
                       i)
                  (zero))
           (equal (exp i (plus j k))
                  (times (exp i j)
                         (exp i k)))
           (equal (exp i (times j k))
                  (exp (exp i j)
                       k))
           (equal (reverse-loop x y)
                  (append (reverse x)
                          y))
           (equal (reverse-loop x (nil))
                  (reverse x))
           (equal (count-list z (sort-lp x y))
                  (plus (count-list z x)
                        (count-list z y)))
           (equal (equal (append a b)
                         (append a c))
                  (equal b c))
           (equal (plus (remainder x y)
                        (times y (quotient x y)))
                  (fix x))
           (equal (power-eval (big-plus1 l i base)
                              base)
                  (plus (power-eval l base)
                        i))
           (equal (power-eval (big-plus x y i base)
                              base)
                  (plus i (plus (power-eval x base)
                                (power-eval y base))))
           (equal (remainder y 1)
                  (zero))
           (equal (lessp (remainder x y)
                         y)
                  (not (zerop y)))
           (equal (remainder x x)
                  (zero))
           (equal (lessp (quotient i j)
                         i)
                  (and (not (zerop i))
                       (or (zerop j)
                           (not (equal j 1)))))
           (equal (lessp (remainder x y)
                         x)
                  (and (not (zerop y))
                       (not (zerop x))
                       (not (lessp x y))))
           (equal (power-eval (power-rep i base)
                              base)
                  (fix i))
           (equal (power-eval (big-plus (power-rep i base)
                                        (power-rep j base)
                                        (zero)
                                        base)
                              base)
                  (plus i j))
           (equal (gcd x y)
                  (gcd y x))
           (equal (nth (append a b)
                       i)
                  (append (nth a i)
                          (nth b (difference i (length a)))))
           (equal (difference (plus x y)
                              x)
                  (fix y))
           (equal (difference (plus y x)
                              x)
                  (fix y))
           (equal (difference (plus x y)
                              (plus x z))
                  (difference y z))
           (equal (times x (difference c w))
                  (difference (times c x)
                              (times w x)))
           (equal (remainder (times x z)
                             z)
                  (zero))
           (equal (difference (plus b (plus a c))
                              a)
                  (plus b c))
           (equal (difference (add1 (plus y z))
                              z)
                  (add1 y))
           (equal (lessp (plus x y)
                         (plus x z))
                  (lessp y z))
           (equal (lessp (times x z)
                         (times y z))
                  (and (not (zerop z))
                       (lessp x y)))
           (equal (lessp y (plus x y))
                  (not (zerop x)))
           (equal (gcd (times x z)
                       (times y z))
                  (times z (gcd x y)))
           (equal (value (normalize x)
                         a)
                  (value x a))
           (equal (equal (flatten x)
                         (cons y (nil)))
                  (and (nlistp x)
                       (equal x y)))
           (equal (listp (gopher x))
                  (listp x))
           (equal (samefringe x y)
                  (equal (flatten x)
                         (flatten y)))
           (equal (equal (greatest-factor x y)
                         (zero))
                  (and (or (zerop y)
                           (equal y 1))
                       (equal x (zero))))
           (equal (equal (greatest-factor x y)
                         1)
                  (equal x 1))
           (equal (numberp (greatest-factor x y))
                  (not (and (or (zerop y)
                                (equal y 1))
                            (not (numberp x)))))
           (equal (times-list (append x y))
                  (times (times-list x)
                         (times-list y)))
           (equal (prime-list (append x y))
                  (and (prime-list x)
                       (prime-list y)))
           (equal (equal z (times w z))
                  (and (numberp z)
                       (or (equal z (zero))
                           (equal w 1))))
           (equal (greatereqpr x y)
                  (not (lessp x y)))
           (equal (equal x (times x y))
                  (or (equal x (zero))
                      (and (numberp x)
                           (equal y 1))))
           (equal (remainder (times y x)
                             y)
                  (zero))
           (equal (equal (times a b)
                         1)
                  (and (not (equal a (zero)))
                       (not (equal b (zero)))
                       (numberp a)
                       (numberp b)
                       (equal (_1- a)
                              (zero))
                       (equal (_1- b)
                              (zero))))
           (equal (lessp (length (delete x l))
                         (length l))
                  (member x l))
           (equal (sort2 (delete x l))
                  (delete x (sort2 l)))
           (equal (dsort x)
                  (sort2 x))
           (equal (length (cons x1
                                (cons x2
                                      (cons x3 (cons x4
                                                     (cons x5
                                                           (cons x6 x7)))))))
                  (plus 6 (length x7)))
           (equal (difference (add1 (add1 x))
                              2)
                  (fix x))
           (equal (quotient (plus x (plus x y))
                            2)
                  (plus x (quotient y 2)))
           (equal (sigma (zero)
                         i)
                  (quotient (times i (add1 i))
                            2))
           (equal (plus x (add1 y))
                  (if (numberp y)
                      (add1 (plus x y))
                      (add1 x)))
           (equal (equal (difference x y)
                         (difference z y))
                  (if (lessp x y)
                      (not (lessp y z))
                      (if (lessp z y)
                          (not (lessp y x))
                          (equal (fix x)
                                 (fix z)))))
           (equal (meaning (plus-tree (delete x y))
                           a)
                  (if (member x y)
                      (difference (meaning (plus-tree y)
                                           a)
                                  (meaning x a))
                      (meaning (plus-tree y)
                               a)))
           (equal (times x (add1 y))
                  (if (numberp y)
                      (plus x (times x y))
                      (fix x)))
           (equal (nth (nil)
                       i)
                  (if (zerop i)
                      (nil)
                      (zero)))
           (equal (last (append a b))
                  (if (listp b)
                      (last b)
                      (if (listp a)
                          (cons (car (last a))
                                b)
                          b)))
           (equal (equal (lessp x y)
                         z)
                  (if (lessp x y)
                      (equal t z)
                      (equal f z)))
           (equal (assignment x (append a b))
                  (if (assignedp x a)
                      (assignment x a)
                      (assignment x b)))
           (equal (car (gopher x))
                  (if (listp x)
                      (car (flatten x))
                      (zero)))
           (equal (flatten (cdr (gopher x)))
                  (if (listp x)
                      (cdr (flatten x))
                      (cons (zero)
                            (nil))))
           (equal (quotient (times y x)
                            y)
                  (if (zerop y)
                      (zero)
                      (fix x)))
           (equal (get j (set i val mem))
                  (if (eqp j i)
                      val
                      (get j mem)))))))

(define (tautologyp x true-lst false-lst)
  (cond ((truep x true-lst)
         #t)
        ((falsep x false-lst)
         #f)
        ((not (pair? x))
         #f)
        ((eq? (car x)
              (quote if))
         (cond ((truep (cadr x)
                       true-lst)
                (tautologyp (caddr x)
                            true-lst false-lst))
               ((falsep (cadr x)
                        false-lst)
                (tautologyp (cadddr x)
                            true-lst false-lst))
               (else (and (tautologyp (caddr x)
                                      (cons (cadr x)
                                            true-lst)
                                      false-lst)
                          (tautologyp (cadddr x)
                                      true-lst
                                      (cons (cadr x)
                                            false-lst))))))
        (else #f)))

(define (tautp x)
  (tautologyp (rewrite x)
              '() '()))

(define (test alist term)
  (tautp
    (apply-subst alist term)))

(define (trans-of-implies n)
  (list (quote implies)
        (trans-of-implies1 n)
        (list (quote implies)
              0 n)))

(define (trans-of-implies1 n)
  (cond ((equal? n 1)
         (list (quote implies)
               0 1))
        (else (list (quote and)
                    (list (quote implies)
                          (- n 1)
                          n)
                    (trans-of-implies1 (- n 1))))))

(define (truep x lst)
  (or (equal? x (quote (t)))
      (member x lst)))

(setup)

(define (main . args)
  (run-benchmark
    "boyer"
    boyer-iters
    (lambda (result) (equal? result #t))
    (lambda (alist term) (lambda () (test alist term)))
    (quote ((x f (plus (plus a b)
                       (plus c (zero))))
            (y f (times (times a b)
                        (plus c d)))
            (z f (reverse (append (append a b)
                                  (nil))))
            (u equal (plus a b)
                     (difference x y))
            (w lessp (remainder a b)
                     (member a (length b)))))
    (quote (implies (and (implies x y)
                         (and (implies y z)
                              (and (implies z u)
                                   (implies u w))))
                    (implies x w)))))
;;; BROWSE -- Benchmark to create and browse through
;;; an AI-like data base of units.

(define (lookup key table)
  (let loop ((x table))
    (if (null? x)
      #f
      (let ((pair (car x)))
        (if (eq? (car pair) key)
          pair
          (loop (cdr x)))))))

(define properties '())

(define (get key1 key2)
  (let ((x (lookup key1 properties)))
    (if x
      (let ((y (lookup key2 (cdr x))))
        (if y
          (cdr y)
          #f))
      #f)))

(define (put key1 key2 val)
  (let ((x (lookup key1 properties)))
    (if x
      (let ((y (lookup key2 (cdr x))))
        (if y
          (set-cdr! y val)
          (set-cdr! x (cons (cons key2 val) (cdr x)))))
      (set! properties
        (cons (list key1 (cons key2 val)) properties)))))

(define *current-gensym* 0)

(define (generate-symbol)
  (set! *current-gensym* (+ *current-gensym* 1))
  (string->symbol (number->string *current-gensym*)))

(define (append-to-tail! x y)
  (if (null? x)
      y
      (do ((a x b)
           (b (cdr x) (cdr b)))
          ((null? b)
           (set-cdr! a y)
           x))))

(define (tree-copy x)
  (if (not (pair? x))
      x
      (cons (tree-copy (car x))
            (tree-copy (cdr x)))))

;;; n is # of symbols
;;; m is maximum amount of stuff on the plist
;;; npats is the number of basic patterns on the unit
;;; ipats is the instantiated copies of the patterns

(define *rand* 21)

(define (init n m npats ipats)
  (let ((ipats (tree-copy ipats)))
    (do ((p ipats (cdr p)))
        ((null? (cdr p)) (set-cdr! p ipats)))
    (do ((n n (- n 1))
         (i m (cond ((zero? i) m)
                    (else (- i 1))))
         (name (generate-symbol) (generate-symbol))
         (a '()))
        ((= n 0) a)
        (set! a (cons name a))
        (do ((i i (- i 1)))
            ((zero? i))
            (put name (generate-symbol) #f))
        (put name
             'pattern
             (do ((i npats (- i 1))
                  (ipats ipats (cdr ipats))
                  (a '()))
                 ((zero? i) a)
                 (set! a (cons (car ipats) a))))
        (do ((j (- m i) (- j 1)))
            ((zero? j))
            (put name (generate-symbol) #f)))))

(define (browse-random)
  (set! *rand* (remainder (* *rand* 17) 251))
  *rand*)

(define (randomize l)
  (do ((a '()))
      ((null? l) a)
      (let ((n (remainder (browse-random) (length l))))
        (cond ((zero? n)
               (set! a (cons (car l) a))
               (set! l (cdr l))
               l)
              (else
               (do ((n n (- n 1))
                    (x l (cdr x)))
                   ((= n 1)
                    (set! a (cons (cadr x) a))
                    (set-cdr! x (cddr x))
                    x)))))))

(define (my-match pat dat alist)
  (cond ((null? pat)
         (null? dat))
        ((null? dat) '())
        ((or (eq? (car pat) '?)
             (eq? (car pat)
                  (car dat)))
         (my-match (cdr pat) (cdr dat) alist))
        ((eq? (car pat) '*)
         (or (my-match (cdr pat) dat alist)
             (my-match (cdr pat) (cdr dat) alist)
             (my-match pat (cdr dat) alist)))
        (else (cond ((not (pair? (car pat)))
                     (cond ((eq? (string-ref (symbol->string (car pat)) 0)
                                 #\?)
                            (let ((val (assq (car pat) alist)))
                              (cond (val (my-match (cons (cdr val)
                                                      (cdr pat))
                                                dat alist))
                                    (else (my-match (cdr pat)
                                                 (cdr dat)
                                                 (cons (cons (car pat)
                                                             (car dat))
                                                       alist))))))
                           ((eq? (string-ref (symbol->string (car pat)) 0)
                                 #\*)
                            (let ((val (assq (car pat) alist)))
                              (cond (val (my-match (append (cdr val)
                                                        (cdr pat))
                                                dat alist))
                                    (else
                                     (do ((l '()
                                             (append-to-tail!
                                               l
                                               (cons (if (null? d)
                                                         '()
                                                         (car d))
                                                     '())))
                                          (e (cons '() dat) (cdr e))
                                          (d dat (if (null? d) '() (cdr d))))
                                         ((or (null? e)
                                              (my-match (cdr pat)
                                                       d
                                                       (cons
                                                        (cons (car pat) l)
                                                        alist)))
                                          (if (null? e) #f #t)))))))
                           (else #f))) ;;;; fix suggested by Manuel Serrano (cond did not have an else clause); this changes the run time quite a bit
                    (else (and
                           (pair? (car dat))
                           (my-match (car pat)
                                  (car dat) alist)
                           (my-match (cdr pat)
                                  (cdr dat) alist)))))))

(define database
   (randomize
    (init 100 10 4 '((a a a b b b b a a a a a b b a a a)
                     (a a b b b b a a
                                    (a a)(b b))
                     (a a a b (b a) b a b a)))))

(define (browse pats)
  (investigate
    database
    pats))

(define (investigate units pats)
  (do ((units units (cdr units)))
      ((null? units))
      (do ((pats pats (cdr pats)))
          ((null? pats))
          (do ((p (get (car units) 'pattern)
                  (cdr p)))
              ((null? p))
              (my-match (car pats) (car p) '())))))

(define (main . args)
  (run-benchmark
    "browse"
    browse-iters
    (lambda (result) #t)
    (lambda (pats) (lambda () (browse pats)))
    '((*a ?b *b ?b a *a a *b *a)
      (*a *b *b *a (*a) (*b))
      (? ? * (b a) * ? ?))))

(define a '((*a ?b *b ?b a *a a *b *a)
            (*a *b *b *a (*a) (*b))
            (? ? * (b a) * ? ?)))#include <setjmp.h>
#include <stdlib.h>
#include <string.h>
#include "norm.h"

int tolower(int c);


extern cell memory[];
extern int emem1[];
extern jmp_buf toplevel;
extern int pc;
extern int sp;
extern int env;
extern int head;
extern int tail;
extern int code[];
extern int stack[];
extern int code_pointer_end;
extern int code_pointer[1000][2];
extern int module_table[100][2];
extern int module_table_end;
extern int current_module;
extern int cont_count;



//---------cell initilize--------------------
void initcell(void){
	int addr,x,y;
    
    for(addr=0; addr <= CELLSIZE; addr++){
    	memory[addr].flag = FRE;
        SET_CDR(addr,addr+1);
    }
    
    cell_heap_p = 0;
    cell_free = CELLSIZE;
    
    for(x=0; x<HASHTBSIZE; x++)
    	for(y=0; y<MODULESIZE; y++) 
    		cell_hash_table[x][y] = NIL;
    
    //0address=nil, 1address=#t, 2address=#f
    make_NIL();
    make_bool("#t");
    make_bool("#f");
    undef	= make_sym("undef");
	end_of_file = make_sym("end_of_file");
    SET_TAG(end_of_file,EOFO);
	quote	= make_sym("quote");
    quasiquote = make_sym("quasiquote");
    unquote	= make_sym("unquote");
    unquote_splicing = make_sym("unquote-splicing");
    empty_set = make_empty_set(); //‹óW‡@‘½’l‚Å—˜—p‚·‚éB
/*    
//ˆÈ‰ºAƒRƒ“ƒpƒCƒ‰‚ªg‚¤’è”B
    make_int(0);
	make_int(1);
    make_int(2);
	make_int(-1);
    make_int(3);
    //subr‚ÌƒZƒ‹ƒAƒhƒŒƒX‚ğ‚¸‚ç‚³‚È‚¢‚½‚ß
    make_char("A");
    make_char("B");
    make_char("C");
    make_char("D");
    make_char("L");
    make_str("L");
    make_sym("tarai");
    make_sym("bar");
    make_sym("begin");
    make_sym("set!");
	make_sym("if");
    make_sym("lambda");
    make_sym("define");
    make_sym("define-macro");
    make_sym("define-syntax");
    make_sym("compile");
    make_sym("comp");
    make_sym("comp-begin");
    make_sym("comp-lambda");
    make_sym("comp-if");
    make_sym("gen");
    make_sym("gen-var");
    make_sym("gen-set");
    make_sym("gen-label");
    make_sym("seq");
    make_sym("comp-args");
    make_sym("in-env?");
    make_sym("in-env-iter");
    make_sym("in-args?");
    make_sym("nth-args");
    make_sym("label?");
    make_sym("args-count");
    make_sym("length=1?");
    make_sym("asm");
    make_sym("pass1");
    make_sym("pass1-iter");
    make_sym("pass2");
    make_sym("pass2-iter");
    make_sym("op-count");
    make_sym("op-code?");
    make_sym("op-code");
    make_sym("mnemonic->code");
	make_sym("mnemonic");
	make_sym("nop");
    make_sym("halt");
    make_sym("const");
    make_sym("lvar");
    make_sym("gvar");
    make_sym("lset");
    make_sym("gset");
    make_sym("pop");
    make_sym("jump");
    make_sym("tjump");
    make_sym("fjump");
    make_sym("return");
    make_sym("args");
    make_sym("call");
    make_sym("callj");
    make_sym("fn");
    make_sym("save");
    make_sym("prim");
    make_sym("def");
    make_sym("defm");
    make_sym("defh"); */
}

void initmodule(void){
	
    module_table[0][0] = list2(make_sym("normal"),make_sym("user"));
    module_table[1][0] = list2(make_sym("normal"),make_sym("system"));
    module_table[2][0] = list2(make_sym("normal"),make_sym("compile"));
    module_table[3][0] = list2(make_sym("scheme"),make_sym("base"));
    module_table[4][0] = list2(make_sym("scheme"),make_sym("inexact"));
    module_table[5][0] = list2(make_sym("scheme"),make_sym("complex"));
	module_table[6][0] = list2(make_sym("scheme"),make_sym("divistion"));
    module_table[7][0] = list2(make_sym("scheme"),make_sym("lazy"));
    module_table[8][0] = list2(make_sym("scheme"),make_sym("case-lambda"));
    module_table[9][0] = list2(make_sym("scheme"),make_sym("eval"));
    module_table[10][0] = list2(make_sym("scheme"),make_sym("repl"));
    module_table[11][0] = list2(make_sym("scheme"),make_sym("process-context"));
    module_table[12][0] = list2(make_sym("scheme"),make_sym("load"));
    module_table[13][0] = list2(make_sym("scheme"),make_sym("file"));
    module_table[14][0] = list2(make_sym("scheme"),make_sym("read"));
    module_table[15][0] = list2(make_sym("scheme"),make_sym("write"));
    module_table[16][0] = list2(make_sym("scheme"),make_sym("char"));
    module_table[17][0] = list3(make_sym("scheme"),make_sym("char"),make_sym("normalization"));
    module_table[18][0] = list2(make_sym("scheme"),make_sym("time"));
    
    module_table_end = 18;
}


int freshcell(void){
	int res;
    
    res = cell_heap_p;
    cell_heap_p =GET_CDR(cell_heap_p);
    SET_CDR(res,0);
    cell_free--;
    
    if(cell_free == 0)
    	exception("", LACK_CELL, NIL);
        
    return(res);
}

int get_tag(int addr){
	if(IS_INTEGER(addr))
    	return(INTN);
    else
    	return(memory[addr].tag);
}

int make_NIL(void){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,BIGBANG);
    return(addr);
}

int make_bool(char *name){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,BOL);
    SET_NAME(addr,name);
    return(addr);
}

int returnbool(char *name){
	if(name[1] == 't' || name[1] == 'T')
    	return(BOOLT);
    if(name[1] == 'f' || name[1] == 'F')
    	return(BOOLF);
    return(undef);
}


int make_int(int intn){
	int addr;
    
	if(intn < 0)
    	return(intn);
    else{
    	addr = INT_FLAG | intn;
        return(addr);
    }
}

int addr_to_int(int addr){
	if(addr < 0)
    	return(addr);
    else
        return(INT_MASK & addr);
}


//bignum -999999999~999999999
int make_big(char *bignum){
	char integer[15];
    int i,j,res,sign;
    

    i = 0;
    while(1){
    	if(bignum[i] == NUL)
        	return(make_int(0));
    	else
        if(bignum[i] != '0')
        	break;
        else
        	i++;
    }
    
    if(bignum[0] == '-')
    	sign = -1;
    else
    	sign = 1;
        
    res = make_NIL();
    i = laststr(bignum);
    while(i >= 0){
    	if(i > 9){
        	for(j=8; j>=0; j--){
            	integer[j] = bignum[i];
                i--;
        	}
            integer[9] = NUL;
        	res = cons(make_int(atoi(integer)*sign),res);
        }
        else{
        	if(bignum[0] == '+' || bignum[0] == '-'){
            	integer[i+1] = NUL;
            	while(i >= 0){
                	integer[i] = bignum[i];
                    i--;
                }
                res = cons(make_int(atoi(integer)),res);
            }
            else
            if(i == 9){
            	for(j=8; j>=0; j--){
                	integer[j] =bignum[i];
                    i--;
                }
                integer[9] = NUL;
                res = cons(make_int(atoi(integer)*sign),res);
            }
            else{
            	integer[i+1] = NUL;
            	while(i >= 0){
                	integer[i] = bignum[i];
                    i--;
                }
                res = cons(make_int(atoi(integer)*sign),res);
            }
        }	
    }
    res = reverse2(res);
    SET_TAG(res,BIG);
    return(res);    
}


int make_flt(double floatn){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,FLTN);
    SET_FLT(addr,floatn);
    return(addr);
}

int norm_rat(int x){
	int n,m,u;
    
    n = GET_CAR(x);
    m = GET_CDR(x);
    
    if(n == 0){
    	return(make_int(0));
    }	
    u = int_gcd(abs(n),abs(m));
    n = n/u;
    m = m/u;
    if((n % m) == 0){
    	return(make_int(n/m));
    }
    else{	
    	SET_CAR(x,n);
    	SET_CDR(x,m);
        return(x);
    }
}


int make_rat(int n, int d){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,RAT);
    SET_CAR(addr,n);
    SET_CDR(addr,d);
    return(norm_rat(addr));
}

void norm_comp(int x){
	double r;
	
	if(GET_IMAG_FLT(x) == (double)0){
    	r = GET_REAL_FLT(x);
        SET_TAG(x,FLTN);
        SET_FLT(x,r);
    }       
}


int make_comp(double real, double imag){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,COMP);
    SET_CAR(addr,make_flt(real));
    SET_CDR(addr,make_flt(imag));
    norm_comp(addr);
    return(addr);
}



int hash(char *name){
	int res;
    
    res = 0;
    while(*name != NUL){
    	res = res + (int)*name;
        name++;
    }
    return(res % HASHTBSIZE);
}

int findsym(char *name, int index){
	int addr;
    
    addr = cell_hash_table[index][current_module];
    
    while(addr != NIL){
    	if(strcmp(name,GET_NAME(car(addr))) == 0)
        	return(car(addr));
        else
        	addr = cdr(addr);
    }
    return(0);
}

int addsym(char *name, int index){
	int addr,res;
    
    addr = cell_hash_table[index][current_module];
    addr = cons(res=make_sym1(name),addr);
    cell_hash_table[index][current_module] = addr;
    return(res);
}



int make_sym(char *name){
	int index,res;
    
    index = hash(name);
    if((res=findsym(name, index)) != 0)
    	return(res);
    else
    	return(addsym(name,index));
}

int make_sym1(char *name){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,SYM);
    SET_NAME(addr,name);
    SET_CAR(addr,undef);
    SET_CDR(addr,0);
    SET_AUX(addr,-1);
    return(addr);
}

int make_clo(void){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,CLOS);
    SET_AUX(addr,-1);
    return(addr);
}

int make_macro(void){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,MAC);
    return(addr);
}

int make_hygienic(void){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,HYG);
    return(addr);
}

int make_synclo(char *name){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,SYNT);
    SET_NAME(addr,name);
    return(addr);
}

int make_cont(void){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,HCONT);
    return(addr);
}

int make_str(char *name){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,STR);
    SET_NAME(addr,name);
    return(addr);
}

int make_char(char *name){
	int addr,pos;
    char c, low_name[SYMSIZE];
	
    c = NUL;
    pos = 0;
    while(name[pos] != NUL){
    	low_name[pos] = tolower(name[pos]);
    	pos++;
    }
    low_name[pos] = NUL;
    
    if(strcmp(low_name,"space") == 0)
    	c = SPACE;
    else
    if(strcmp(low_name,"return") == 0)
    	c = RET;
    else
    if(strcmp(low_name,"newline") == 0)
    	c = EOL;
    else
    if(strcmp(low_name,"tab") == 0)
    	c = TAB;
    else 
    	if(strlen(name) != 1)
        	exception("make_char", NOT_CHAR, make_str(name));
        else
        	c = name[0];
    
    addr = freshcell();
    SET_TAG(addr,CHR);
    SET_CHAR(addr,c);
    return(addr);
}

//type 0=input_port, 1=output_port
int make_port(FILE *port, int type){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,PRT);
    SET_PORT(addr,port);
	SET_CDR(addr,type);
    return(addr);
}

int make_vector(int n, int obj){
	int res,i, *vec;
    
    res = freshcell();
	vec = (int *)malloc(sizeof(int)*n);
    if(vec == NULL)
    	exception("make_vector", MALLOC_OVERF, NIL);
    else
    	SET_VEC(res,vec);
    for(i=0; i<n; i++)
    	SET_VEC_ELT(res,i,obj);
    SET_TAG(res,VEC);
    SET_CDR(res,n);
    return(res);
}

void vector_set(int v, int n, int obj){
	
    SET_VEC_ELT(v,n,obj);
}

int vector_ref(int v, int n){
	
    return(GET_VEC_ELT(v,n));
}

int vector_length(int v){
	
    return(GET_CDR(v));
}

int vector(int lis){
	int len,i,res;
    
    len = length(lis);
    i = 0;
    res = make_vector(len,undef);
    while(!nullp(lis)){
    	vector_set(res,i,car(lis));
        i++;
        lis = cdr(lis);
    }
    
    return(res);
}

int make_ident(char *name){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,IDNT);
    SET_NAME(addr,name);
    SET_AUX(addr,NIL);
    return(addr);
}


//“®“I‚Éms*n—ñ@s—ñ‚ğ¶¬‚·‚éB—v‘f‚Í‚O‚©‚çn‚Ü‚é‚±‚Æ‚É’ˆÓB
int make_env(int m, int n){
	int addr,x;
    
    addr = freshcell();
    SET_TAG(addr,ENV);
    if(m == 0 && n == 0)
    	goto exit;
            
    x = n + 1;
    SET_CAR(addr,ealloc(x));
       	
    exit:
    SET_CDR(addr,m);
    SET_AUX(addr,n);   
    return(addr);
}

int make_code(int i){
	int addr, *vec;
    
    addr = freshcell();
    SET_TAG(addr,CODE);
	vec = (int *)malloc(sizeof(int)*i);
    if(vec == NULL)
    	exception("make_code", MALLOC_OVERF, NIL);
    else
    	SET_VEC(addr,vec);
        
	SET_CDR(addr,i);
	return(addr);
}

int make_stack(void){
	int addr,i, *vec;
    
    //ƒXƒ^ƒbƒN‚Ìã‚Q‚Â‚Íœ‚¢‚Ä•Û‘¶‚·‚éBŠÂ‹«‚Æ–ß‚èƒAƒhƒŒƒXB
    addr = freshcell();
    SET_TAG(addr,STACK);
	vec = (int *)malloc(sizeof(int)*(sp - 2));
    if(vec == NULL)
    	exception("make_stack", MALLOC_OVERF, NIL);
    else
    	SET_VEC(addr,vec);
        
	for(i=0; i<(sp - 2); i++)
    	SET_VEC_ELT(addr,i,stack[i]);
	SET_CDR(addr,sp-2);
    return(addr);
}

int make_memory(void){
	int addr,i,j,*vec,end;
    
    /*
    Œp‘±—p‚ÌmemoryƒIƒuƒWƒFƒNƒg‚ÉŠ„‚è“–‚Ä‚ç‚ê‚½“®“I”z—ñ‚ª1ç–œ‚ğ’´‚¦‚½‚Æ‚«‚É
    GC‚ğ‹N“®‚·‚éB(ctak 10 5 0)‚Å‚Í³í‚É“®‚­‚ª(ctak 12 6 0)‚Å‚Í“®ì‚µ‚È‚¢B
    ‚¨‚»‚ç‚­malloc‚Ì“à•”“I‚È–â‘è‚Å‚Í‚È‚¢‚©‚Æv‚¤B
    */
    if(cont_count > 10000000){
		gbc();
    }
    
    addr = freshcell();
    SET_TAG(addr,MEM);
    end = code_pointer[0][1];
    vec = (int *)malloc(sizeof(int)*(4 + (code_pointer_end * 2) + end));
	cont_count = cont_count + 4 + (code_pointer_end * 2) + end;
    if(vec == NULL)
    	exception("make_memory", MALLOC_OVERF, NIL);
    else
    	SET_VEC(addr,vec);
    
    SET_VEC_ELT(addr,0,SECOND_STACK);
    SET_VEC_ELT(addr,1,code_pointer_end);
    SET_VEC_ELT(addr,2,head);
    SET_VEC_ELT(addr,3,tail);
    j = 4;
    for(i=0; i<code_pointer_end; i++){
    	SET_VEC_ELT(addr,j,code_pointer[i][0]);	
    	SET_VEC_ELT(addr,j+1,code_pointer[i][1]);
        j = j + 2;
    }
    for(i=0; i<end; i++){
    	SET_VEC_ELT(addr,j,code[i]);
        j++;
    }
    cont_count++;
    //printf("%d\n", cont_count);
	
    return(addr);
}

int get_int(int x){
	return(GET_INT(x));
}

int make_multiple_values(int lis){
	int addr,n,i,v, *vec;
    
    n = length(lis);
    addr = freshcell();
    SET_TAG(addr,MUL);
    vec = (int *)malloc(sizeof(int)*(1 + n));
    if(vec == NULL)
    	exception("make_multiple_values", MALLOC_OVERF, NIL);
    else
    	SET_VEC(addr,vec);
    
    SET_VEC_ELT(addr,0,n);
    for(i=1; i<=n; i++){
    	v = car(lis);
    	SET_VEC_ELT(addr,i,v);
        lis = cdr(lis);
    }
    return(addr);
}

int make_empty_set(void){
	int addr;
    
    addr = freshcell();
    SET_TAG(addr,EMPSET);
    return(addr);
}



//----------operate environment------------------------

int get_lvar(int i, int j){
	int orgenv;
    
    orgenv = env;
    while(i >= 0){
    	if(i == 0)
        	return(GET_ENV_VEC_ELT(orgenv,j));
        else{
        	orgenv = GET_ENV_ORG(orgenv);
            i--;	
        }
    }
    return(undef);
}


void set_lvar(int i, int j, int val){
	int orgenv;
	
    orgenv = env;
    while(i >= 0){
		if(i == 0){
        	SET_ENV_VEC_ELT(orgenv,j,val);
            return;
        }
        else{
        	orgenv = GET_ENV_ORG(orgenv);
            i--;
        }
    }
}

//ƒVƒ“ƒ{ƒ‹‚ğƒJƒŒƒ“ƒgƒ‚ƒWƒ…[ƒ‹‚ÅƒŠƒƒCƒN‚µ‚Â‚ÂƒRƒs[‚·‚éB
int remake(int x){
	
    if(nullp(x))
    	return(x);
    else if(symbolp(x))
    	return(make_sym(GET_NAME(x)));
    else if(atomp(x))
    	return(x);
    else if(vectorp(x))
    	return(x);
    else
    	return(cons(remake(car(x)),remake(cdr(x))));
}L     ÎC  j     .text           ¼    t*      ]    0`.data                               @ 0À.bss                                € 0À.rdata          <  À               @ 0@.drectve        D  ü!              @ 0À/4              4  @#  B      ,   @ 0@ƒì,¡    ‰ÂÁâ‹Š   ‰    Ç‚       ‹    J‰    …Òu$ÇD$    ÇD$   Ç$    ‰D$è    ‹D$ƒÄ,Ã‹D$©   @t	¸   Ãv Áà‹€   Ãfƒì,¡    ‰ÂÁâ‹Š   ‰    Ç‚       ‹    J‰    …Òu$ÇD$    ÇD$   Ç$    ‰D$è    ‹D$‰ÂÁâÇ‚      ƒÄ,ÃVSƒì‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ŞÁæÇ†      Ç$@   è    ‰†   ‹T$ ‰T$‰$è    ‰ØƒÄ[^Ãf‹D$Š@<tt<Tt<ft<Ft¡    Ãv ¸   Ãf¸   Ãf¸   Ãf‹D$…Àx   @Ãf‹D$…Àx%ÿÿÿ?ÃfUWVSƒì<‹t$PŠ„Àt<0…  ‰ğë	v @€ú0uŠP„Òuó¸   @ƒÄ<[^_]ÃfÇD$   ‹-    ‰èÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰èÁàÇ€      ‰4$è    ‰Ã…ÀˆÇ   |$!ƒû	~zfŠˆD$)ŠDÿˆD$(ŠDşˆD$'ŠDıˆD$&ŠDüˆD$%ŠDûˆD$$ŠDúˆD$#ŠDùˆD$"ŠDøˆD$!ƒë	ÆD$* ‰<$è    ¯D$…Àx   @‰l$‰$è    ‰Åƒû	ˆŠ<+t^<-tZƒû	tyÆD" ŠˆKƒûÿuô‰<$è    ¯D$…Àx   @‰l$‰$è    ‰Å‰,$è    ‰ÂÁâÇ‚      ƒÄ<[^_]ÃÆD" v ŠˆKƒûÿuô‰<$è    …Ày­ë°fŠF	ˆD$)ŠFˆD$(ŠFˆD$'ŠFˆD$&ŠFˆD$%ŠFˆD$$ŠFˆD$#ŠFˆD$"ŠFˆD$!ÆD$* ‰<$è    ¯D$…Àx   @‰l$‰$è    ‰Å1Ûé	ÿÿÿ<-•À¶ÀD ÿ‰D$éşÿÿWVƒì$‹t$0‹|$4¡    ‰ÂÁâ‹Š   ‰    Ç‚       ‹    J‰    …Òu$ÇD$    ÇD$   Ç$    ‰D$è    ‹D$‰ÂÁâÇ‚      ‰²    ‰º   ƒÄ$^_ÃWVSƒì‹\$ ‰ØÁà‹¸    ‹°   …ÿu»   @‰ØƒÄ[^_Ãv ‰ğ…öxN‰D$‰ø…ÿxH‰$è    ‰Á‰ø™÷ù‰Ç‰ğ™÷ù‰Æ‰ø™÷ş…Òu‰Ã…Àx½Ë   @ëµ‰ØÁà‰¸    ‰°   ë¡÷Øë®÷Øë´WVSƒì‹|$ ‹t$$‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ÚÁâÇ‚      ‰º    ‰²   …ÿu»   @‰ØƒÄ[^_Ã‰ğ…öxN‰D$‰ø…ÿxH‰$è    ‰Á‰ø™÷ù‰Ç‰ğ™÷ù‰Æ‰ø™÷ş…Òu‰Ã…Àx¿Ë   @ë·‰ØÁà‰¸    ‰°   ë£÷Øë®÷Øë´WV‹T$Áâ‹‚   Áàİ€    ÙîÙÉÚéßà€äE€ô@u+‹‚    Áà‹°    ‹¸   Ç‚      ‰²    ‰º   ^_ÃfWVSƒì İD$0İ\$İD$8İ\$‹    ‰ß‰ØÁà‹˜   ‰    Ç€       ¡    H£    …Àu'ÇD$    ÇD$   Ç$    è    ‹    ¡    ‰úÁâÇ‚      ‰Ş‰ÚÁâ‹š   ‰    Ç‚       H£    …Àu'ÇD$    ÇD$   Ç$    è    ‹    ¡    ‰òÁâÇ‚      İD$İš    ‰úÁâ‰²    ‰ÚÁâ‹Š   ‰    Ç‚       H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ØÁàÇ€      İD$İ˜    ‰úÁâ‰š   İ€    ÙîÙÉÚéßà€äE€ô@u+‹‚    Áà‹˜    ‹°   Ç‚      ‰š    ‰²   ‰øƒÄ [^_ÃS‹\$Š„Ét1Àv ¾ÉÈCŠ„Éuô¹d   ™÷ù‰Ğ[Ã1ÒëøVSƒì‹t$ ‹D$$€€‹    ‚‹…    …ÛuëCv ‰$è    ‰Ã…Àt2‰$è    Áà‹€   ‰D$‰4$è    …ÀuÑ‰\$ ƒÄ[^é    v 1ÀƒÄ[^ÃUWVSƒì,‹t$D¶€‹    ƒ‹…    ‰D$‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰İÁåÇ…      Ç$@   è    ‰…   ‹T$@‰T$‰$è    ¡    ‰…    Ç…       Ç…   ÿÿÿÿ‹D$‰D$‰$è    ¶’‹    ‘‰•    ‰ØƒÄ,[^_]Ãv UWVSƒì,‹\$@Š„Ò„s  ‰Ù1Àv ¾ÒĞAŠ„Òuô¹d   ™÷ù‰Ö¶€‹-    D… ‹<…    …ÿué=  fè    ‰Ç…Àt9‰<$è    Áà‹€   ‰D$‰$è    ‰<$…ÀuÑè    ‰Ç…Àt
‰øƒÄ,[^_]Ã¶€‹=    ‡‹…    ‰D$‹=    ‰øÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰úÁâ‰T$‰ÕÇ‚      Ç$@   è    ‹T$‰‚   ‰\$‰$è    ¡    ‹T$‰‚    Ç…       Ç…   ÿÿÿÿ‹T$‰T$‰<$è    ¶’‹5    –‰•    ‰øƒÄ,[^_]Ã1öé£şÿÿÇD$    éÿÿÿVSƒìÇ$   èSşÿÿ‰ÃÇ$   èEşÿÿ‰\$‰$è    £    Ç$   è(şÿÿ‰ÃÇ$   èşÿÿ‰\$‰$è    £   Ç$   èııÿÿ‰ÃÇ$   èïıÿÿ‰\$‰$è    £   Ç$   èÒıÿÿ‰ÃÇ$!   èÄıÿÿ‰\$‰$è    £   Ç$(   è§ıÿÿ‰ÃÇ$!   è™ıÿÿ‰\$‰$è    £    Ç$0   è|ıÿÿ‰ÃÇ$!   ènıÿÿ‰\$‰$è    £(   Ç$8   èQıÿÿ‰ÃÇ$!   èCıÿÿ‰\$‰$è    £0   Ç$B   è&ıÿÿ‰ÃÇ$!   èıÿÿ‰\$‰$è    £8   Ç$G   èûüÿÿ‰ÃÇ$!   èíüÿÿ‰\$‰$è    £@   Ç$S   èĞüÿÿ‰ÃÇ$!   èÂüÿÿ‰\$‰$è    £H   Ç$X   è¥üÿÿ‰ÃÇ$!   è—üÿÿ‰\$‰$è    £P   Ç$]   èzüÿÿ‰ÃÇ$!   èlüÿÿ‰\$‰$è    £X   Ç$m   èOüÿÿ‰ÃÇ$!   èAüÿÿ‰\$‰$è    £`   Ç$r   è$üÿÿ‰ÃÇ$!   èüÿÿ‰\$‰$è    £h   Ç$w   èùûÿÿ‰ÃÇ$!   èëûÿÿ‰\$‰$è    £p   Ç$|   èÎûÿÿ‰ÃÇ$!   èÀûÿÿ‰\$‰$è    £x   Ç$‚   è£ûÿÿ‰ÃÇ$!   è•ûÿÿ‰\$‰$è    £€   Ç$‡   èxûÿÿ‰ÆÇ$‚   èjûÿÿ‰ÃÇ$!   è\ûÿÿ‰t$‰\$‰$è    £ˆ   Ç$•   è;ûÿÿ‰ÃÇ$!   è-ûÿÿ‰\$‰$è    £   Ç       ƒÄ[^ÃSƒìº   1ÀÇ    @‰BôƒÂ =-1uì1Òf1ÀfÇ„‚        @ƒøduïÂ  ú@œ  uİ‹   Ç       Ç      Áã‹“   ‰    Çƒ       Ç    ş,1Çƒ      Ç$@   è    ‰ƒ   fÇ #tÆ@ ‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …À„å   ÁãÇƒ      Ç$@   è    ‰ƒ   fÇ #fÆ@ Ç$š   èûùÿÿ£    Ç$    èêùÿÿ£    ÁàÇ€      Ç$¬   èÌùÿÿ£    Ç$²   è»ùÿÿ£    Ç$½   èªùÿÿ£    Ç$Å   è™ùÿÿ£    ‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …Àt;‰ØÁàÇ€      ‰    ƒÄ[ÃÇD$    ÇD$   Ç$    è    éúşÿÿÇD$    ÇD$   Ç$    è    ë§v WVSƒì‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ßÁçÇ‡      Ç$@   è    ‰‡   ‹T$ ‰T$‰$è    ¡    ‰‡    Ç‡       Ç‡   ÿÿÿÿ‰ØƒÄ[^_Ãƒì,¡    ‰ÂÁâ‹Š   ‰    Ç‚       ‹    J‰    …Òu$ÇD$    ÇD$   Ç$    ‰D$è    ‹D$‰ÂÁâÇ‚      Ç‚   ÿÿÿÿƒÄ,Ãv ƒì,¡    ‰ÂÁâ‹Š   ‰    Ç‚       ‹    J‰    …Òu$ÇD$    ÇD$   Ç$    ‰D$è    ‹D$‰ÂÁâÇ‚      ƒÄ,Ãƒì,¡    ‰ÂÁâ‹Š   ‰    Ç‚       ‹    J‰    …Òu$ÇD$    ÇD$   Ç$    ‰D$è    ‹D$‰ÂÁâÇ‚      ƒÄ,ÃVSƒì‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ŞÁæÇ†      Ç$@   è    ‰†   ‹T$ ‰T$‰$è    ‰ØƒÄ[^Ãfƒì,¡    ‰ÂÁâ‹Š   ‰    Ç‚       ‹    J‰    …Òu$ÇD$    ÇD$   Ç$    ‰D$è    ‹D$‰ÂÁâÇ‚      ƒÄ,ÃVSƒì‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ŞÁæÇ†      Ç$@   è    ‰†   ‹T$ ‰T$‰$è    ‰ØƒÄ[^ÃfUWVSƒìl‹¬$€   ŠU ˆT$„Ò„Ğ  ˆĞ1ö\$ v ¾À‰$è    ˆ3FŠD5 „ÀuéÆD4  ¿Ö   ¹   ‰Şó¦„V  ¿Ü   ¹   ‰Şó¦„¼   ¿ã   ¹   ‰Şó¦„B  ¿ë   ¹   ‰Şó¦„$  1À¹ÿÿÿÿ‰ïò®ƒùı„…   ‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …À„ğ   ‰ŞÁæÇ†      Ç$@   è    ‰†   ‰l$‰$è    ‰\$ÇD$   Ç$ï   è    ÆD$ ëÆD$‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ŞÁæÇ†      Ç$   è    ‰†   ŠT$ˆÆ@ ‰ØƒÄl[^_]ÃÆD$ éuÿÿÿÆD$	ékÿÿÿÆD$
éaÿÿÿÇD$    ÇD$   Ç$    è    éïşÿÿ1ö\$ éGşÿÿSƒì(¡    ‰ÂÁâ‹Š   ‰    Ç‚       ‹    J‰    …Òu$ÇD$    ÇD$   Ç$    ‰D$è    ‹D$‰ÁÁá‘    Ç      ‹\$0‰™    ‹L$4‰JƒÄ([ÃWVSƒì‹\$ ‹t$$‹=    ‰øÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è        ‰$è    …ÀtC‰úÁâ‰‚    …Û~1À‰ùÁá‹‘    ‰4‚@9Øuò‰øÁàÇ€   	   ‰˜   ‰øƒÄ[^_ÃÇD$    ÇD$+   Ç$ù   è    ëªf‹D$Áà‹€    ‹L$‹T$‰Ãv ‹D$Áà‹€    ‹T$‹Ãv ‹D$Áà‹€   ÃfUWVSƒì‹\$0‰$è    ‰Æ‹=    ‹-    ‰èÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    µ    ‰$è    …Àtr‰êÁâ‰‚    …ö~1À‰éÁá‹‘    ‰<‚@9ğuò‰ïÁçÇ‡   	   ‰·   1öë‰$è    ‹—    ‰2‰$è    ‰ÃƒÆ‰$è    …ÀtÖ‰èƒÄ[^_]ÃÇD$    ÇD$+   Ç$ù   è    éxÿÿÿv WVSƒì‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ßÁçÇ‡      Ç$@   è    ‰‡   ‹T$ ‰T$‰$è    Ç‡       ‰ØƒÄ[^_ÃfWVSƒì‹|$ ‹t$$‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ØÁàÇ€      …ÿu…ötF‰$è    ‰ÚÁâ‰‚    ‰ØÁà‰¸   ‰°   ‰ØƒÄ[^_Ãv WVSƒì‹t$ ‹    ‰ØÁà‹   ‰    Ç€       ¡    H£    …ÀuÇD$    ÇD$   Ç$    è    ‰ßÁçÇ‡   ;;ƒeƒXƒgƒvƒƒOƒ‰ƒ€@ƒ‰ƒ}ƒkƒWƒƒƒ“‚Ìƒ^ƒNƒV[ƒiƒ“ƒo[‚ÌŒŸØ

;;g‚¢•û‚Í
;;; Norm> (filter taxi (combination 2 '(1 2 3 4 5 6 7 8 9 10 11 12)))
;;; ((1 12) (9 10))
;;; Norm> 

;;‘g‚İ‡‚í‚¹‚Ívallog‚³‚ñ‚Ì‘‚¢‚½‚à‚Ì‚ğƒRƒsƒy‚³‚¹‚Ä‚¢‚½‚¾‚«‚Ü‚µ‚½B
(define combination 
  (lambda (r l) 
    (cond 
      ((null? l) '()) 
      ((or (zero? r)(> r (length l))) '()) 
      ((= r 1)(map list l)) 
      ((= r (length l))(list l)) 
      (else (append (map (lambda (n)(cons (car l) n)) 
                         (combination (- r 1)(cdr l))) 
                    (combination r (cdr l)))))))

(define (filter f ls)
  (cond ((null? ls) '())
        ((f (car ls)) (cons (car ls) (filter f (cdr ls))))
        (else (filter f (cdr ls)))))

(define (taxi x)
  (= (+ (expt (car x) 3) (expt (cadr x) 3))
     1729));;––”öÄ‹AÅ“K‰»ƒRƒ“ƒpƒCƒ‰
;;has-lambda? “ü‚êq‚Ìlambda®‚ğ‚à‚Â‚©‚Ç‚¤‚©B
;;in-lambda?@lambda®‚Ì’†‚Ì®‚©‚Ç‚¤‚©H
;;tail?@––”öÄ‹AÅ“K‰»‚ğ‚·‚é‚×‚«‚©‚Ç‚¤‚©H
;;define-macro‚Ì‚Æ‚«‚É‚Í#f‚É‚·‚éB
;;--------------------------------- 

(define (compile x)
  (append (comp (transfer x) '() #t #t #f #f #t) (list (list 'halt))))


(define (comp x env val? more? has-lambda? in-lambda? tail?)
  (cond ((null? x) (comp-const x val? more?))
        ((boolean? x) (comp-const x val? more?))
        ((symbol? x) (comp-var x env val? more?))
        ((atom? x ) (comp-const x val? more?))
        ((vector? x) (comp-const x val? more?))
        ((macro-name? (car x))
         (comp (macroexpand-1 x) env val? more? has-lambda? in-lambda? tail?))
        ((eq? (car x) 'quote)
         (args-count-check x 1 1)
         (comp-const (cadr x) val? more?))
        ((eq? (car x) 'begin)
         (comp-begin (cdr x) env val? more? has-lambda? in-lambda? tail?))
        ((eq? (car x) 'set!)
         (args-count-check x 2 2)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? tail?)
              (gen-set (cadr x) env)
              (if (not val?) (gen 'pop) '())
              (if (not more?) (gen 'return) '())))
        ((eq? (car x) 'if)
         (args-count-check x 3 3)
         (comp-if (cadr x) (caddr x) (cadddr x)
                   env val? more? has-lambda? in-lambda? tail?))
        ((eq? (car x) 'lambda)
         (if val?
             (let ((f (comp-lambda (cadr x) (cddr x) env tail?)))
               (seq (gen 'fn (args-count (cadr x))f)
                    (if (not more?) (gen 'return) '())))
             #f))
        ((eq? (car x) 'define)
         (args-type-check x 1 symbol? "require symbol ")
         (args-type-check x 1 (lambda (y) (not (primitive-name? y)))
                          "can't overwrite primitive name ")
         (seq (comp (caddr x) env val? more? has-lambda? in-lambda? tail?) 
              (gen 'def (cadr x))))
        ((eq? (car x) 'define-macro)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env val? more? has-lambda? in-lambda? #f)
              (gen 'defm (cadr x))))
        (else
          (comp-funcall (car x) (cdr x) env val? more? has-lambda? in-lambda? tail?))))
        

(define (comp-const x val? more?)
  (if val? 
      (seq (gen 'const x)
                (if (not more?)
                    (gen 'return)
                    '()))
      '()))

(define (comp-var x env val? more?)
  (if val?
      (seq (gen-var x env)
           (if (not more?)
               (gen 'return)
               '()))
      '()))

(define (comp-begin exps env val? more? has-lambda? in-lambda? tail?)
  (cond ((null? exps) (comp-const '() val? more?))
        ((length=1? exps) (comp (car exps) env val? #f has-lambda? in-lambda? tail?))
        (else (seq (comp (car exps) env #f #t has-lambda? in-lambda? tail?)
                   (comp-begin  (cdr exps) env val? more? has-lambda? in-lambda? tail?)))))

(define (comp-list exps env has-lambda? in-lambda? tail?)
  (if (null? exps)
      '()
      (seq (comp (car exps) env #t #t has-lambda? in-lambda? tail?)
           (comp-list (cdr exps) env has-lambda? in-lambda? tail?))))

(define (comp-if pred then else env val? more? has-lambda? in-lambda? tail?)
  (cond ((not pred)
         (comp else env val? more? has-lambda? in-lambda? tail?))
        ((and (atom? pred) (not (symbol? pred)) (not (not pred)))
         (comp then env val? more? has-lambda? in-lambda? tail?))
        ((and (list? pred)
              (length=1? (cdr pred))
              (eq? (car pred) 'not))
         (comp-if (cadr pred) else then env val? more? has-lambda? in-lambda? tail?))
        (else 
          (let ((pcode (comp pred env #t #t has-lambda? in-lambda? tail?))
                (tcode (comp then env val? more? has-lambda? in-lambda? tail?))
                (ecode (comp else env val? more? has-lambda? in-lambda? tail?)))
            (cond ((equal? tcode ecode)
                   (seq (comp pred env #f #t has-lambda? in-lambda? tail?) ecode))
                  ((not tcode)
                   (let ((L2 (gen-label)))
                     (seq pcode (gen 'tjump L2) ecode (list L2)
                          (if (not more?) (gen 'return) '()))))
                  (else
                    (let ((L1 (gen-label))
                          (L2 (if more? (gen-label) #f)))
                      (seq pcode (gen 'fjump L1) tcode
                           (if more? (gen 'jump L2) '())
                           (list L1) ecode (if more? (list L2) '())))))))))


(define (comp-funcall f args env val? more? has-lambda? in-lambda? tail?)
  (let ((prim (primitive? f env)))
    (cond (prim
            (args-count-check (cons f args) (prim-min prim) (prim-max prim))
            (cond ((and (not val?) (not (prim-side-effect? prim)))
                   (comp-begin args env #f more? has-lambda? in-lambda? tail?))
                  ((eq? f 'call/cc);;call/cc‚Ì‚Æ‚«‚ÍCALL–½—ß‚ğ¶¬‚·‚éB
                    (seq (comp-list args env has-lambda? in-lambda? #f)
                         (gen 'prim f (length args))
                         (if (not val?) (gen 'pop) '())
                         (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (memq f '(= < <= > >=))(= (length args) 2));;2€”äŠr‰‰Zq
                   (seq (comp-list args env has-lambda? in-lambda? tail?)
                             (gen (cadr (assq f binomial-op)))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eq? f 'zero?)(= (length args) 1));;(zero? n)->(zerop)
                   (seq (comp-list args env has-lambda? in-lambda? tail?)
                             (gen 'zerop)
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eq? f '-)(= (length args) 2)
                        (or (eq? (cadr args) 1) (eq? (cadr args) 2))) ;;(- x 1or2)->(sub1or2)
                   (seq (comp-list (butlast args) env has-lambda? in-lambda? tail?)
                             (if (= (cadr args) 1) (gen 'sub1) (gen 'sub2))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eq? f '+)(= (length args) 2)
                        (or (eq? (cadr args) 1) (eq? (cadr args) 2))) ;;(+ x 1or2)->(add1or2)
                   (seq (comp-list (butlast args) env has-lambda? in-lambda? tail?)
                             (if (= (cadr args) 1) (gen 'add1) (gen 'add2))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))
                  (else (seq (comp-list args env has-lambda? in-lambda? tail?)
                             (gen 'prim f (length args))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))))
          ((and (list? f) (eq? (car f) 'lambda) (null? (cadr f)))
           (if (not (null? args)) (error "too many arguments: " args) '())
           (comp-begin (cddr r) env val? more? has-lambda? in-lambda? tail?))
          ((and (not more?)(not has-lambda?) tail?)
           (seq (comp-list args env has-lambda? in-lambda? tail?)
                (comp f env #t #t has-lambda? in-lambda? tail?)
                (gen 'callj (length args))))
          (else
            (seq (comp-list args env has-lambda? in-lambda? tail?)
                 (comp f env #t #t has-lambda? in-lambda? tail?)
                 (gen 'call (length args))
                 (if (not val?) (gen 'pop) '())
                 (if (not more?) (gen 'return) '()))))))

;;; 
;;; (define binomial-op
;;;   '((= neqp) (< smlp) (<= esmlp)
;;;     (> grtp) (>= egrtp)))
;;; 

;;; (define (prim-always? x)
;;;   (cadddr x))
;;; 
;;; (define (prim-side-effect? x)
;;;   (cadr (cdddr x)))
;;; 
;;; (define (prim-min x)
;;;   (cadr x))
;;; 
;;; (define (prim-max x)
;;;   (caddr x))
;;; 
;;; ;;(symbol-name args-min args-max always side-effect)
;;; (define *primitive*
;;;   '((car 1 1 #t #f)
;;;     (cdr 1 1 #t #f)
;;;     (cons 2 2 #t #f)
;;;     (caar 1 1 #t #f)
;;;     (cdar 1 1 #t #f)
;;;     (cddr 1 1 #t #f)
;;;     (cadr 1 1 #t #f)
;;;     (caaar 1 1 #t #f)
;;;     (cdaar 1 1 #t #f)
;;;     (cadar 1 1 #t #f)
;;;     (caadr 1 1 #t #f)
;;;     (cddar 1 1 #t #f)
;;;     (caddr 1 1 #t #f)
;;;     (cdadr 1 1 #t #f)
;;;     (cdddr 1 1 #t #f)
;;;     (caaaar 1 1 #t #f)
;;;     (cdaaar 1 1 #t #f)
;;;     (cadaar 1 1 #t #f)
;;;     (caadar 1 1 #t #f)
;;;     (caaadr 1 1 #t #f)
;;;     (cddaar 1 1 #t #f)
;;;     (caddar 1 1 #t #f)
;;;     (caaddr 1 1 #t #f)
;;;     (cdaadr 1 1 #t #f)
;;;     (cdadar 1 1 #t #f)
;;;     (cadddr 1 1 #t #f)
;;;     (cdaddr 1 1 #t #f)
;;;     (cddadr 1 1 #t #f)
;;;     (cdddar 1 1 #t #f)
;;;     (cddddr 1 1 #t #f)
;;;     (assq 2 2 #t #f)
;;;     (assv 2 2 #t #f)
;;;     (assoc 2 2 #t #f)
;;;     (memq 2 2 #t #f)
;;;     (memv 2 2 #t #f)
;;;     (member 2 2 #t #f)
;;;     (reverse 1 1 #t #f)
;;;     (reverse! 1 1 #t #t)
;;;     (list-tail 1 1 #t #f)
;;;     (list-ref 2 2 #t #f)
;;;     (append 2 2 #t #f)
;;;     (append! 2 infinity #t #ft)
;;;     (set-car! 2 2 #t #f)
;;;     (set-cdr! 2 2 #t #f)
;;;     (list 0 infinity #t #f)
;;;     (length 1 1 #t #f)
;;;     (pair-length 1 1 #t #f)
;;;     (last 1 1 #t #f)
;;;     (butlast 1 1 #t #f)
;;;     (newline 0 1 #t #t)
;;;     (display 1 2 #t #t)
;;;     (write 1 2 #t #t)
;;;     (write-char 1 1 #t #t)
;;;     (null? 1 1 #t #f)
;;;     (list? 1 1 #t #f)
;;;     (pair? 1 1 #t #f)
;;;     (atom? 1 1 #t #f)
;;;     (eq? 1 infinity #t #f)
;;;     (eqv? 1 infinity #t #f)
;;;     (equal? 1 infinity #t #f)
;;;     (boolean? 1 1 #t #f)
;;;     (procedure? 1 1 #t #f)
;;;     (number? 1 1 #t #f)
;;;     (integer? 1 1 #t #f)
;;;     (real? 1 1 #t #f)
;;;     (rational? 1 1 #t #f)
;;;     (complex? 1 1 #t #f)
;;;     (exact? 1 1 #t #f)
;;;     (inexact? 1 1 #t #f)
;;;     (symbol? 1 1 #t #f)
;;;     (string? 1 1 #t #f)
;;;     (char? 1 1 #t #f)
;;;     (bignum? 1 1 #t #f)
;;;     (vector? 1 1 #t #f)
;;;     (macro? 1 1 #t #f)
;;;     (macro-name? 1 1 #t #f)
;;;     (hygienic-name? 1 1 #t #f)
;;;     (zero? 1 1 #t #f)
;;;     (+ 0 infinity #t #f)
;;;     (- 1 infinity #t #f)
;;;     (* 0 infinity #t #f)
;;;     (/ 1 infinity #t #f)
;;;     (< 1 infinity #t #f)
;;;     (<= 1 infinity #t #f)
;;;     (> 1 infinity #t #f)
;;;     (>= 1 infinity #t #f)
;;;     (= 1 infinity #t #f)
;;;     (sin 1 1 #t #f)
;;;     (cos 1 1 #t #f)
;;;     (tan 1 1 #t #f)
;;;     (asin 1 1 #t #f)
;;;     (acos 1 1 #t #f)
;;;     (atan 1 2 #t #f)
;;;     (log 1 1 #t #f)
;;;     (exp 1 1 #t #f)
;;;     (sqrt 1 1 #t #f)
;;;     (expt 2 2 #t #f)
;;;     (not 1 1 #t #f)
;;;     (odd? 1 1 #t #f)
;;;     (even? 1 1 #t #f)
;;;     (floor 1 1 #t #f)
;;;     (ceiling 1 1 #t #f)
;;;     (truncate 1 1 #t #f)
;;;     (round 1 1 #t #f)
;;;     (numerator 1 1 #t #f)
;;;     (denominator 1 1 #t #f)
;;;     (positive? 1 1 #t #f)
;;;     (negative? 1 1 #t #f)
;;;     (abs 1 1 #t #f)
;;;     (max 1 infinity #t #f)
;;;     (min 1 infinity #t #f)
;;;     (real-part 1 1 #t #f)
;;;     (imag-part 1 1 #t #f)
;;;     (magnitude 1 1 #t #f)
;;;     (angle 1 1 #t #f)
;;;     (make-rectangular 2 2 #t #f)
;;;     (make-polar 2 2 #t #f)
;;;     (exact->inexact 1 1 #t #f)
;;;     (inexact->exact 1 1 #t #f)
;;;     (remainder 2 2 #t #f)
;;;     (modulo 2 2 #t #f)
;;;     (quotient 2 2 #t #f)
;;;     (gcd 0 2 #t #f)
;;;     (lcm 0 2 #t #f)
;;;     (char=? 1 1 #t #f)
;;;     (char>? 1 1 #t #f)
;;;     (char>=? 1 1 #t #f)
;;;     (char<? 1 1 #t #f)
;;;     (char<=? 1 1 #t #f)
;;;     (char-ci=? 1 1 #t #f)
;;;     (char-ci>? 1 1 #t #f)
;;;     (char-ci>=? 1 1 #t #f)
;;;     (char-ci<? 1 1 #t #f)
;;;     (char-ci<=? 1 1 #t #f)
;;;     (char-alphabetic? 1 1 #t #f)
;;;     (char-numeric? 1 1 #t #f)
;;;     (char-whitespace? 1 1 #t #f)
;;;     (char-upper-case? 1 1 #t #f)
;;;     (char-lower-case? 1 1 #t #f)
;;;     (char->integer 1 1 #t #f)
;;;     (integer->char 1 1 #t #f)
;;;     (char-upcase 1 1 #t #f)
;;;     (char-downcase 1 1 #t #f)
;;;     (string-append 1 1 #t #f)
;;;     (number->string 1 1 #t #f)
;;;     (string->number 1 1 #t #f)
;;;     (string=? 1 1 #t #f)
;;;     (string>? 1 1 #t #f)
;;;     (string>=? 1 1 #t #f)
;;;     (string<? 1 1 #t #f)
;;;     (string<=? 1 1 #t #f)
;;;     (string-ci=? 1 1 #t #f)
;;;     (string-ci>? 1 1 #t #f)
;;;     (string-ci>=? 1 1 #t #f)
;;;     (string-ci<? 1 1 #t #f)
;;;     (string-ci<=? 1 1 #t #f)
;;;     (string->symbol 1 1 #t #f)
;;;     (symbol->string 1 1 #t #f)
;;;     (string-length 1 1 #t #f)
;;;     (make-string 1 1 #t #f)
;;;     (string 1 1 #t #f)
;;;     (string-ref 1 1 #t #f)
;;;     (string-set! 1 1 #t #t)
;;;     (substring 1 1 #t #f)
;;;     (string->list 1 1 #t #f)
;;;     (list->string 1 1 #t #f)
;;;     (string-copy 1 1 #t #f)
;;;     (string-fill! 1 1 #t #t)
;;;     (make-vector 2 2 #t #f)
;;;     (vector-set! 3 3 #t #f)
;;;     (vector 1 infinity #t #f)
;;;     (vector-ref 2 2 #t #f)
;;;     (vector-length 1 1 #t #f)
;;;     (vector-fill! 2 2 #t #f)
;;;     (vector->list 1 1 #t #f)
;;;     (list->vector 1 1 #t #f)
;;;     (read 0 1 #t #f)
;;;     (load 1 1 #t #f)
;;;     (open-input-file 1 1 #t #t)
;;;     (open-output-file 1 1 #t #t)
;;;     (close-input-port 1 1 #t #t)
;;;     (close-output-port 1 1 #t #t)
;;;     (eof-object? 1 1 #t #f)
;;;     (input-port? 1 1 #t #f)
;;;     (output-port? 1 1 #t #f)
;;;     (current-input-port 1 1 #t #f)
;;;     (current-output-port 1 1 #t #f)
;;;     (read-char 1 1 #t #f)
;;;     (peek-char 1 1 #t #f)
;;;     (char-ready? 1 1 #t #f)
;;;     (call/cc 1 1 #t #t)
;;;     (exit 0 0 #t #t)
;;;     (gensym 0 1 #t #f)
;;;     (apply 2 infinity #t #f)
;;;     (primitive-name? 1 1 #t #f)
;;;     (macroexpand-1 1 1 #t #f)
;;;     (macroexpand 1 1 #t #f)
;;;     (addr 1 1 #t #f)
;;;     (entity-addr 1 1 #t #f)
;;;     (undefined 0 0 #t #f)
;;;     (step 1 1 #t #t)
;;;     (vm2-step 1 1 #t #t)
;;;     (vm1 1 1 #t #t)
;;;     (vm2 1 1 #t #t)
;;;     (dump 1 2 #t #t)
;;;     (addr-prt 1 1 #t #t)
;;;     (gbc 0 1 #t #t)
;;;     (room 0 0 #t #f)
;;;     (vmcode 1 1 #t #f)
;;;     (env 1 1 #t #f)
;;;     (timer-set 0 0 #t #t)
;;;     (timer-get 0 0 #t #t)
;;;     (timer-gbc 0 0 #t #t)
;;;     (eval 1 1 #t #f)
;;;     (load 1 1 #t #t)
;;;     (error 2 2 #t #t)
;;;     (flush 0 1 #t #t)
;;;     (map 1 infinity #t #f)
;;;     (for-each 1 infinity #t #t)
;;;     (set-trace 0 infinity #t #t)
;;;     (set-untrace 0 infinity #t #t)
;;;     (set-export 1 infinity #t #t)
;;;     (get-module 2 2 #t #f)
;;;     (set-module 2 infinity #t #t)
;;;     (current-module 0 0 #t #f)
;;;     (sel-module 1 1 #t #t)
;;;     (add1 1 1 #t #f)
;;;     (sub1 1 1 #t #f)
;;;     (transfer 1 1 #t #f)
;;;     (randome-integer 1 1 #t #f)
;;;     (debug 1 1 #t #t)
;;;     (prof 1 1 #t #t)
;;;     ))
;;; 
;;; 
;;; (define (primitive? x env)
;;;   (and (not (in-env? x env))
;;;        (assoc x *primitive*)))
;;; 
;;; ;;macro‚Å‚Ítail?=#f‚É‚µ‚Ä––”öÄ‹AÅ“K‰»‚Í‚µ‚È‚¢B
;;; (define (comp-lambda args body env tail?)
;;;   (if tail?
;;;       (seq (gen 'args (args-count args))
;;;            (comp-begin body
;;;                        (cons args env) #t #t 
;;;                        (inner-lambda? (macroexpand body)) #t tail?))
;;;       (seq (gen 'args (args-count args))
;;;            (comp-begin body
;;;                        (cons args env) #t #t #f #t tail?))))
;;;       
;;;       
;;; 
;;; (define (args-count x)
;;;   (cond ((symbol? x) -1)
;;;         ((list? x)(length x))
;;;         (else (- (pair-length x)))))
;;; 
;;; (define (length=1? x)
;;;   (and (list? x)
;;;        (= (length x) 1)))
;;; 
;;; (define (lambda-args? x)
;;;   (cond ((null? x) #t)
;;;         ((symbol? x) #t)
;;;         ((atom? x) #f)
;;;         ((not (symbol? (car x))) #f)
;;;         (else (lambda-args? (cdr x)))))
;;; 
;;; (define (symbol-or-list? x)
;;;   (or (symbol? x)
;;;       (list? x)))
;;; 
;;; (define (args-count-check x min max)
;;;   (let ((n (length (cdr x))))
;;;     (cond ((and (>= n min) (eq? max 'infinity)) #t)
;;;           ((and (>= n min) (<= n max)) #t)
;;;           (else (error "incorrect argument count " x)))))
;;;                  
;;; (define (args-type-check x n pred msg)
;;;   (if (pred (list-ref x n))
;;;       #t
;;;       (error msg x)))
;;; 
;;; (define (gen opcode . args)
;;;   (list (cons opcode args)))
;;; 
;;; (define (gen-var var env)
;;;   (let ((p (in-env? var env)))
;;;     (if p
;;;         (gen 'lvar (car p) (cadr p))
;;;         (gen 'gvar var))))
;;; 
;;; (define (gen-set var env)
;;;   (let ((p (in-env? var env)))
;;;     (if p
;;;         (gen 'lset (car p) (cadr p))
;;;         (gen 'gset var))))
;;; 
;;; (define (seq . code)
;;;   (apply append code))
;;; 
;;; (define (gen-label)
;;;   (gensym "L"))
;;; 
;;; (define (label? x)
;;;   (and (symbol? x)
;;;        (char=? (string-ref (symbol->string x) 2) #\L)))
;;; 
;;; 
;;; (define (in-env? symbol env)
;;;   (in-env-iter symbol env 0))
;;; 
;;; (define (in-env-iter symbol env i)
;;;   (cond ((null? env) #f)
;;;         ((in-args? symbol (car env)) (list i (nth-args symbol (car env))))
;;;         (else (in-env-iter symbol (cdr env) (+ i 1)))))
;;; 
;;; (define (in-args? symbol args)
;;;   (cond ((null? args) #f)
;;;         ((and (symbol? args) (eq? symbol args)) #t)
;;;         ((symbol? args) #f)
;;;         ((eq? symbol (car args)) #t)
;;;         (else (in-args? symbol (cdr args)))))
;;; 
;;; 
;;; (define (nth-args symbol args)
;;;   (cond ((and (symbol? args) (eq? symbol args)) 0)
;;;         ((eq? symbol (car args)) 0)
;;;         (else (+ 1 (nth-args symbol (cdr args))))))
;;; 
;;; 
;;; (define (inner-lambda? x)
;;;   (cond ((null? x) #f)
;;;         ((atom? x) #f)
;;;         ((vector? x) #f)
;;;         ((eq? (car x) 'lambda) #t)
;;;         (else (or (inner-lambda? (car x))
;;;                   (inner-lambda? (cdr x))))))
;;; 
;;; 
;;; ;;ƒAƒZƒ“ƒuƒ‰
;;; ;;ƒAƒZƒ“ƒuƒ‰
;;; 
;;; (define (asm ls)
;;;   (pass2 ls (pass1 ls))) 
;;; 
;;; 
;;; (define (pass1 x)
;;;   (pass1-iter x 1 '()))
;;; 
;;; (define (pass1-iter ls pc labels)
;;;   (cond ((null? ls) labels)
;;;         ((label? (car ls))
;;;          (pass1-iter (cdr ls) pc (cons (cons (car ls) pc) labels)))
;;;         (else
;;;           (pass1-iter (cdr ls) (+ pc (op-count (car ls))) labels))))
;;; 
;;; (define (pass2 x labels)
;;;   (pass2-iter x 1 '() labels))
;;; 
;;; (define (pass2-iter ls pc obj labels)
;;;   (cond ((null? ls) (reverse obj))
;;;         ((label? (car ls)) (pass2-iter (cdr ls) pc obj labels))
;;;         (else
;;;           (pass2-iter (cdr ls)
;;;                       (+ pc (op-count (car ls)))
;;;                       (append (reverse (mnemonic->code (car ls) labels pc))
;;;                               obj)
;;;                       labels))))
;;; 
;;; (define (mnemonic->code x labels pc)
;;;   (cond ((eq? (car x) 'halt) (list (op-code (car x))))
;;;         ((eq? (car x) 'const) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'lvar) (list (op-code (car x)) (cadr x) (caddr x)))
;;;         ((eq? (car x) 'gvar) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'lset) (list (op-code (car x)) (cadr x) (caddr x)))
;;;         ((eq? (car x) 'gset) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'pop) (list (op-code (car x))))
;;;         ((eq? (car x) 'jump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
;;;         ((eq? (car x) 'tjump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
;;;         ((eq? (car x) 'fjump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
;;;         ((eq? (car x) 'return) (list (op-code (car x))))
;;;         ((eq? (car x) 'args) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'call) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'callj) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'fn) (list (op-code (car x)) (cadr x) (asm (caddr x))))
;;;         ((eq? (car x) 'save) (list (op-code (car x))))
;;;         ((eq? (car x) 'prim) (list (op-code (car x)) (entity-addr (cadr x)) (caddr x)))
;;;         ((eq? (car x) 'def) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'defm) (list (op-code (car x)) (cadr x)))
;;;         ((eq? (car x) 'neqp) (list (op-code (car x))))
;;;         ((eq? (car x) 'smlp) (list (op-code (car x))))
;;;         ((eq? (car x) 'esmlp) (list (op-code (car x))))
;;;         ((eq? (car x) 'grtp) (list (op-code (car x))))
;;;         ((eq? (car x) 'egrtp) (list (op-code (car x))))
;;;         ((eq? (car x) 'zerp) (list (op-code (car x))))
;;;         ((eq? (car x) 'add1) (list (op-code (car x))))
;;;         ((eq? (car x) 'sub1) (list (op-code (car x))))
;;;         ((eq? (car x) 'add2) (list (op-code (car x))))
;;;         ((eq? (car x) 'sub2) (list (op-code (car x))))))
;;; 
;;; (define (op-count x) 
;;;   (length x))
;;; 
;;; 
;;; (define (op-code? x)
;;;   (member x mnemonic))
;;; 
;;; (define (op-code x)
;;;   (- (length mnemonic) (length (member x mnemonic))))
;;; 
;;; 
;;; (define mnemonic 
;;;   (list 'nop 'halt 'const 'lvar 'gvar 'lset 'gset 'pop 'jump 'tjump 'fjump
;;;         'return 'args 'call 'callj 'fn 'save 'prim 'def 'defm 'defh
;;;         'neqp 'smlp 'esmlp 'grtp 'egrtp 'zerop 
;;;         'add1 'sub1 'add2 'sub2))

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include <limits.h>
#include <math.h>
#include "norm.h"

extern cell memory[];
extern jmp_buf toplevel;


//-------------------------------------------------
int integerp(int x){
	if(IS_INTEGER(x))
    	return(1);
    else
    	return(0);
}

int mathematical_integerp(int x){
	double f;
    
	if(IS_INTEGER(x))
    	return(1);
    else if(IS_BIGNUM(x))
    	return(1);
    else{
    	f = GET_FLT(x);
        if(IS_FLOAT(x) && (ceil(f) == floor(f)))
        	return(1);
    }
    return(0);
}

int positivep(int x){
	
    if(integerp(x) && get_int(x) > 0)
        return(1);
    else if(bignump(x) && big_positivep(x))
        return(1);
    else if(floatp(x) && GET_FLT(x) > 0)
    	return(1);
    else if(rationalp(x) && GET_CAR(x) > 0)
    	return(1);
    else
    	return(0);
}

int negativep(int x){
	
    if(integerp(x) && get_int(x) < 0)
    	return(1);
    else if(bignump(x) && big_negativep(x))
    	return(1);
    else if(floatp(x) && GET_FLT(x) < 0)
    	return(1);
    else if(rationalp(x) && GET_CAR(x) < 0)
    	return(1);
    else
    	return(0);
}

int exactp(int x){
	if(integerp(x) || bignump(x) || rationalp(x))
    	return(1);
    else
    	return(0);
}

int inexactp(int x){
	if(exactp(x))
    	return(0);
    else
    	return(1);
}

int bignump(int x){
	if(!IS_INTEGER(x) && IS_BIGNUM(x))
    	return(1);
    else
    	return(0);
}

int floatp(int x){
	if(!IS_INTEGER(x) && IS_FLOAT(x))
    	return(1);
    else
    	return(0);
}	

int numberp(int x){	
    if(IS_INTEGER(x) || (IS_FLOAT(x)) || IS_RATIONAL(x) || IS_BIGNUM(x) ||(IS_COMPLEX(x)))
    	return(1);
    else
    	return(0);
}

int realp(int x){
	if(IS_INTEGER(x) || (IS_FLOAT(x)) || IS_RATIONAL(x) || IS_BIGNUM(x))
    	return(1);
    else
    if(IS_COMPLEX(x) && (GET_IMAG_FLT(x) == 0))
    	return(1);
    else
    	return(0);
}

int rationalp(int x){
	if(!IS_INTEGER(x) && IS_RATIONAL(x))
    	return(1);
    else
    	return(0);
}

int complexp(int x){
	if(!IS_INTEGER(x) && IS_COMPLEX(x))
    	return(1);
    else
    	return(0);
}

//”äŠr
int zerop(int x){
	int arg;
    
    if(integerp(x) && get_int(x) == 0)
    	return(1);
    
	arg = realtocomp(x);
    if(GET_REAL_FLT(arg) == 0 && GET_IMAG_FLT(arg) == 0)
    	return(1);
    else
    	return(0);
}


int numeqp(int x, int y){
	int arg1,arg2;
    //®”Œ^‚Å‚ ‚Á‚ÄƒAƒhƒŒƒX‚ª“¯‚¶‚È‚ç‚Î“™‚µ‚¢B
    if(IS_INTEGER(x) && IS_INTEGER(y)){
     	if(x == y)
    		return(1);
        else
        	return(0);
    }
	//bignum‚Å‚ ‚Á‚Ä‘S•”‚ÌƒZƒ‹‚ª“¯‚¶”‚È‚ç‚Î“™‚µ‚¢B
    if(bignump(x) && bignump(y)){
    	if(big_eqp(x,y))
        	return(1);
        else
        	return(0);
    }
    //‚»‚¤‚Å‚È‚¯‚ê‚Î•¡‘f”‚É•ÏŠ·‚µ‚ÄÀ•”A‹••”‚Æ‚à‚É“™‚µ‚¢‚È‚ç‚Î“™‚µ‚¢B	
    arg1 = realtocomp(x);
    arg2 = realtocomp(y);
    if((GET_REAL_FLT(arg1) == GET_REAL_FLT(arg2)) &&
       (GET_IMAG_FLT(arg1) == GET_IMAG_FLT(arg2)))
       	return(1);
    else
    	return(0);
}

int eqp(int x1, int x2){
	//”Ô’n‚ª“¯‚¶‚È‚ç“™‚µ‚¢
    if(x1 == x2)
    	return(1);
    if(!integerp(x1) && !integerp(x2)){
	//”’l‚Å‚ ‚Á‚Ä‚È‚ç‚Î“™‚µ‚¢
    	if(numberp(x1) && numberp(x2) && IS_SAME_TYPE(x1,x2) && (numeqp(x1,x2)))
        	return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}


int eqvp(int x1, int x2){
	//”Ô’n‚ª“¯‚¶‚È‚ç“™‚µ‚¢B
    if(x1 == x2)
    	return(1);
	//ˆóš–¼‚ª“¯‚¶•¶š—ñ‚È‚ç“™‚µ‚¢
    if(stringp(x1) && stringp(x2) && (SAME_NAME(x1,x2)))
		return(1);
    //ˆóš–¼‚ª“¯‚¶•¶š‚È‚ç“™‚µ‚¢B
    if(charp(x1) && charp(x2) && (SAME_NAME(x1,x2)))
    	return(1);
    //”’l‚Å‚ ‚Á‚Ä‚È‚ç‚Î“™‚µ‚¢
    if(numberp(x1) && numberp(x2) && IS_SAME_TYPE(x1,x2) && (numeqp(x1,x2)))
        return(1);
    //ƒVƒ“ƒ{ƒ‹‚ ‚é‚¢‚Í¯•Êq‚Å‚ ‚Á‚Äˆóš–¼‚ª“¯‚¶‚È‚ç“™‚µ‚¢BiƒRƒ“ƒpƒCƒ‰‚Ì“s‡j
    if((symbolp(x1) || IS_IDENTIFIER(x1)) && (symbolp(x2) || IS_IDENTIFIER(x2)) 
    	&& (SAME_NAME(x1,x2)))
        return(1);
    
    else
    	return(0);

}


int smallerp(int x1, int x2){
	int arg1,arg2;
	if(IS_INTEGER(x1) && IS_INTEGER(x2)){
    	if(x1 < x2)
    		return(1);
        else
        	return(0);
    }
    if(integerp(x1) && bignump(x2))
    	return(1);

	if(bignump(x1) && bignump(x2)){
    	if(big_smallerp(x1,x2))
    		return(1);
        else
        	return(0);
    }
    if(realp(x1) && realp(x2)){
    	arg1 = exact_to_inexact(x1);
        arg2 = exact_to_inexact(x2);
        if(GET_FLT(arg1) < GET_FLT(arg2))
        	return(1);
    }
    if(complexp(x1))
    	exception("<",ILLEGAL_ARGUMENT, x1);
    if(complexp(x2))
    	exception("<", ILLEGAL_ARGUMENT, x2);
    
    return(0);

}

int eqsmallerp(int x1, int x2){
	int arg1,arg2;
	if(IS_INTEGER(x1) && IS_INTEGER(x2)){
    	if(x1 <= x2)
    		return(1);
        else
        	return(0);
    }
    if(integerp(x1) && bignump(x2))
    	return(1);
    if(bignump(x1) && bignump(x2)){
    	 if(big_smallerp(x1,x2) || big_eqp(x1,x2))
    		return(1);
         else
         	return(0);
    }
    if(realp(x1) && realp(x2)){
    	arg1 = exact_to_inexact(x1);
        arg2 = exact_to_inexact(x2);
        if(GET_FLT(arg1) <= GET_FLT(arg2))
        	return(1);
    }
    if(complexp(x1))
    	exception("<=", ILLEGAL_ARGUMENT, x1);
    if(complexp(x2))
    	exception("<=", ILLEGAL_ARGUMENT, x2);
    return(0);
}

int greaterp(int x1, int x2){
	if(smallerp(x2,x1))
    	return(1);
    else
    	return(0);
}

int eqgreaterp(int x1, int x2){
	if(eqsmallerp(x2,x1))
    	return(1);
    else
    	return(0);
}

//-------------------------------------------------
//”’lŒ^•ÏŠ·
double bignumtofloat(int x){
	double val;
    int i,sgn,rev;
    
    rev = reverse(x);
	val = sgn = GET_INT(car(rev));
    rev = cdr(rev);
    while(!nullp(rev)){
    	i = GET_INT(car(rev));
        if(sgn > 0)
    		val = val * BIGNUM_BASE + (double)i;
        else
        	val = val * BIGNUM_BASE - (double)i;
        rev = cdr(rev);
    }
    return(val);
}



int exact_to_inexact(int x){
	int m,n,res,tag;
    double val;
    
    tag = GET_TAG(x);
    switch(tag){
    	case INTN: 	res = freshcell();
    				SET_TAG(res,FLTN);
        			val = (double)GET_INT(x);
        			SET_FLT(res,val);
        			return(res);
        case BIG:  	res = freshcell();
    				SET_TAG(res,FLTN);
        			val = bignumtofloat(x);
        			SET_FLT(res,val);
                    return(res);
        case FLTN: 	return(x);
        case RAT:  	res = freshcell();
    				SET_TAG(res,FLTN);
        			n = GET_CAR(x);
        			m = GET_CDR(x);
                    val = (double)n/m;
                    SET_FLT(res,val);
                    return(res);
    
        case COMP: 	return(x);
    }
    return(undef);
}

int flttorat(int x){
	double flt;
    int numer,denom,digit;
    
    flt = GET_FLT(x);
    denom = 1;
    digit = 0;
    while((fabs(flt) - floor(fabs(flt))) > 0.000000001){
    	if(digit > 8)
        	break;
        flt = flt * 10;
        denom = denom * 10;
        digit++;
    }
    numer = (int)floor(flt);
    return(make_rat(numer,denom));
}

int flttobig(int x){
	double flt;
    int big,res;
    
    flt = GET_FLT(x);
    res = NIL;
    while(fabs(flt) >= BIGNUM_BASE){
    	big = (int)fmod(fabs(flt),BIGNUM_BASE);
        if(flt >= 0)
        	flt = floor(flt / BIGNUM_BASE);
        else
        	flt = ceil(flt / BIGNUM_BASE);
    	res = cons(make_int(big),res);    
    }
    res = cons(make_int((int)flt),res);
    res = reverse2(res);
    SET_TAG(res,BIG);
    return(res);  
}

int inexact_to_exact(x){
	int tag;
    
    tag = GET_TAG(x);
	switch(tag){
    	case INTN:
        case BIG:
        case RAT:
        case COMP:	return(x);
        case FLTN:	if(fabs(GET_FLT(x)) < BIGNUM_BASE)
        				return(flttorat(x));
        			else
                    	return(flttobig(x));
    }
    return(undef);
}

int realtocomp(int x){
	int m,n,res,tag;
    double val;
    
	res = make_comp(0,0);
    tag = GET_TAG(x);
	switch(tag){
    	case INTN: {SET_REAL_FLT(res,(double)GET_INT(x));
                    SET_IMAG_FLT(res,0);
                    break;}
        case BIG:  {val = bignumtofloat(x);
        			SET_REAL_FLT(res,val);
                    SET_IMAG_FLT(res,0);
                    break;}
        case FLTN: {SET_REAL_FLT(res,GET_FLT(x));
        			SET_IMAG_FLT(res,0);
        			break;}
        case RAT:  {n = GET_CAR(x);
        			m = GET_CDR(x);
                    val = (double)n/m;
                    SET_REAL_FLT(res,val);
                    SET_IMAG_FLT(res,0);
                    break;}
        case COMP:	return(x);
	}
    return(res);
}


//-----------------------------------
//l‘¥‰‰Z

int plus(int arg1, int arg2){
	int n,m,s,t,u,tag1,tag2,i;
    double x1,y1,x2,y2;
    
    if(integerp(arg1) && integerp(arg2)){
    	i = GET_INT(arg1) + GET_INT(arg2);
        if(SMALL_INT_MIN < i && i < SMALL_INT_MAX)
        	return(make_int(i));
        else
        	return(big_plus(inttobignum(arg1),inttobignum(arg2)));    
    }

    tag1 = GET_TAG(arg1);
    tag2 = GET_TAG(arg2);
	switch(tag1){
    	case INTN:
        	switch(tag2){
                case FLTN: {n = GET_INT(arg1);
                			x1 = (double)n;
                            y1 = GET_FLT(arg2);
                            return(make_flt(x1+y1));}
                            
                case RAT:  {n = GET_INT(arg1);
                			s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            return(make_rat(n*t+s,t));}
                            
                case BIG:  return(big_plus(inttobignum(arg1),arg2));
                
                case COMP: {n = GET_INT(arg1);
                			x1 = (double)n;
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1+x2,y2));}   
            }
        case BIG:
        	switch(tag2){
            	case INTN:	if(get_int(arg2) != 0)
                				return(big_plus(arg1,inttobignum(arg2)));
                			else
                            	return(arg1);
                                
            	case BIG: 	return(big_plus(arg1,arg2));
            }
        case FLTN:
        	switch(tag2){
            	case INTN: {x1 = GET_FLT(arg1);
                			s = GET_INT(arg2);
                            x2 = (double)s;
                            return(make_flt(x1+x2));}
                case FLTN: {x1 = GET_FLT(arg1);
                			x2 = GET_FLT(arg2);
                            return(make_flt(x1+x2));}
                case RAT:  {x1 = GET_FLT(arg1);
                			s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            x2 = (double)s/t;
                            return(make_flt(x1+x2));}
                case BIG:	return(BOOLF);
                case COMP: {x1 = GET_REAL_FLT(arg1);
                			x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1+x2,y2));}
        	}
        case RAT:
        	switch(tag2){
            	case INTN: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            s = GET_INT(arg2);
                            return(make_rat(n+s*m,m));}
                case FLTN: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            x1 = (double)n/m;
                            x2 = GET_FLT(arg2);
                            return(make_flt(x1+x2));}
                case RAT:  {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            u = int_lcm(m,t);
                            n = n*(u/m);
                            s = s*(u/t);
                            return(make_rat(n+s,u));}
                case BIG:	return(BOOLF);
                case COMP: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            x1 = (double)n/m;
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1+x2,y2));}
        }
        case COMP:
        	switch(tag2){
            	case INTN: {x1 = GET_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            n = GET_INT(arg2);
                            x2 = (double)n;
                            return(make_comp(x1+x2,y1));}
                            
                case FLTN: {x1 = GET_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            x2 = GET_FLT(arg2);
                            return(make_comp(x1+x2,y1));}
                            
                case RAT:  {x1 = GET_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            x2 = (double)s/t;
                            return(make_comp(x1+x2,y1));}
                            
                case BIG:	return(BOOLF);
                
                case COMP: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1+x2,y1+y2));}
            }               
    }
    return(undef);
}


int minus(int arg1, int arg2){
	int n,m,s,t,u,tag1,tag2,i;
    double x1,y1,x2,y2;
    
    if(integerp(arg1) && integerp(arg2)){
    	i = GET_INT(arg1) - GET_INT(arg2);
        if(SMALL_INT_MIN < i && i < SMALL_INT_MAX)
        	return(make_int(i));
        else
        	return(big_minus(inttobignum(arg1),inttobignum(arg2)));    
    }
    	
    tag1 = GET_TAG(arg1);
    tag2 = GET_TAG(arg2);
	switch(tag1){
    	case INTN:
        	switch(tag2){
                case FLTN: {n = GET_INT(arg1);
                			x1 = (double)n;
                            y1 = GET_FLT(arg2);
                            return(make_flt(x1-y1));}
                
                case RAT:  {n = GET_INT(arg1);
                			s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            return(make_rat(n*t-s,t));}
				
                case BIG:  return(big_minus(inttobignum(arg1),arg2));
                
                case COMP: {n = GET_INT(arg1);
                			x1 = (double)n;
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1-x2,-y2));}   
            }
        case BIG:
        	switch(tag2){
            	case INTN:	if(get_int(arg2) != 0)
                				return(big_minus(arg1,inttobignum(arg2)));
                			else
                            	return(arg1);
                                
            	case BIG:	return(big_minus(arg1,arg2));
            }
        case FLTN:
        	switch(tag2){
            	case INTN: {x1 = GET_FLT(arg1);
                			s = GET_INT(arg2);
                            x2 = (double)s;
                            return(make_flt(x1-x2));}
                case FLTN: {x1 = GET_FLT(arg1);
                			x2 = GET_FLT(arg2);
                            return(make_flt(x1-x2));}
                case RAT:  {x1 = GET_FLT(arg1);
                			s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            x2 = (double)s/t;
                            return(make_flt(x1-x2));}
                case BIG:	return(BOOLF);
                case COMP: {x1 = GET_REAL_FLT(arg1);
                			x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1-x2,-y2));}
        	}
        case RAT:
        	switch(tag2){
            	case INTN: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            s = GET_INT(arg2);
                            return(make_rat(n-s*m,m));}
                case FLTN: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            x1 = (double)n/m;
                            x2 = GET_FLT(arg2);
                            return(make_flt(x1-x2));}
                case RAT:  {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            u = int_lcm(m,t);
                            n = n*(u/m);
                            s = s*(u/t);
                            return(make_rat(n-s,u));}
                case BIG:	return(BOOLF);
                case COMP: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            x1 = (double)n/m;
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1-x2,y2));}
        }
        case COMP:
        	switch(tag2){
            	case INTN: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            n = GET_INT(arg2);
                            x2 = (double)n;
                            y2 = 0;
                            return(make_comp(x1-x2,y2));}
                case FLTN: {x1 = GET_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            x2 = GET_FLT(arg2);
                            return(make_comp(x1-x2,y1));}
                case RAT:  {x1 = GET_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            x2 = (double)s/t;
                            return(make_comp(x1-x2,y1));}
                case BIG:	return(BOOLF);
                case COMP: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1-x2,y1-y2));}
            }               
    }
    return(undef); 
}


int mult(int arg1, int arg2){
	int n,m,s,t,tag1,tag2;
    long long int l,l1,l2;
    double x1,y1,x2,y2;
    
    tag1 = GET_TAG(arg1);
    tag2 = GET_TAG(arg2);
    
	switch(tag1){
    	case INTN:
        	switch(tag2){
        		case INTN: {l1 = (long long int)GET_INT(arg1);
                			l2 = (long long int)GET_INT(arg2);
                            l = l1 * l2;
                            if(l < SMALL_INT_MAX && l > SMALL_INT_MIN)
                            	return(make_int((int)l));
                            else
                            	return(big_mult(inttobignum(arg1),inttobignum(arg2))); }
                                
                case FLTN: {n = GET_INT(arg1);
                			x1 = (double)n;
                            y1 = GET_FLT(arg2);
                            return(make_flt(x1*y1));}
                            
                case RAT:  {n = GET_INT(arg1);
                			s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            return(make_rat(n*s,t));}
                            
                case BIG:   if(get_int(arg1) != 0)
                				return(big_int_mult(arg2,arg1));
                			else
                            	return(arg1); //int 0
            
                case COMP: {n = GET_INT(arg1);
                			x1 = (double)n;
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1*x2,x1*y2));}   
            }
        case BIG:
        	switch(tag2){
            	case INTN:	if(get_int(arg2) != 0)
                				return(big_int_mult(arg1,arg2));
                			else
                            	return(arg2); //int 0
                                
            	case BIG:	return(big_mult(arg1,arg2));
            }
        
        case FLTN:
        	switch(tag2){
            	case INTN: {x1 = GET_FLT(arg1);
                			s = GET_INT(arg2);
                            x2 = (double)s;
                            return(make_flt(x1*x2));}
                case FLTN: {x1 = GET_FLT(arg1);
                			x2 = GET_FLT(arg2);
                            return(make_flt(x1*x2));}
                case RAT:  {x1 = GET_FLT(arg1);
                			s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            x2 = (double)s/t;
                            return(make_flt(x1*x2));}
                case BIG:	return(BOOLF);
                case COMP: {x1 = GET_REAL_FLT(arg1);
                			x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1*x2,x1*y2));}
        	}
        case RAT:
        	switch(tag2){
            	case INTN: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            s = GET_INT(arg2);
                            return(make_rat(n*s,m));}
                case FLTN: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            x1 = (double)n/m;
                            x2 = GET_FLT(arg2);
                            return(make_flt(x1*x2));}
                case RAT:  {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            return(make_rat(n*s,m*t));}
                case BIG:	return(BOOLF);
                case COMP: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            x1 = (double)n/m;
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1*x2,x1*y2));}
        }
        case COMP:
        	switch(tag2){
            	case INTN: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            n = GET_INT(arg2);
                            x2 = (double)n;
                            return(make_comp(x1*x2,y1*x2));}
                case FLTN: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            x2 = GET_FLT(arg2);
                            return(make_comp(x1*x2,y1*x2));}
                case RAT:  {x1 = GET_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            x2 = (double)s/t;
                            return(make_comp(x1*x2,y1*x2));}
                case BIG:	return(BOOLF);
                case COMP: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1*x2-y1*y2,x1*y2+y1*x2));}
            }               
    }
    return(undef);  
}


int divide(int arg1, int arg2){
	int n,m,s,t,tag1,tag2;
    double x1,y1,x2,y2;
    
    tag1 = GET_TAG(arg1);
    tag2 = GET_TAG(arg2);
	switch(tag1){
    	case INTN:
        	switch(tag2){
        		case INTN: {n = GET_INT(arg1);
                			s = GET_INT(arg2);
                            return(make_rat(n,s));}
                case FLTN: {n = GET_INT(arg1);
                			x1 = (double)n;
                            y1 = GET_FLT(arg2);
                            return(make_flt(x1/y1));}
                case RAT:  {n = GET_INT(arg1);
                			s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            return(make_rat(n*t,s));}
                case BIG:   exception("/", ILLEGAL_ARGUMENT, arg2);
            
                case COMP: {n = GET_INT(arg1);
                			x1 = (double)n;
                            y1 = 0;
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1*x2/(y1*y1+y2*y2),-x1*y2/(y1*y1+y2*y2)));}   
            }
		case BIG:
        	switch(tag2){
            	case INTN:	exception("/", ILLEGAL_ARGUMENT, arg1);
                case BIG:	exception("/", ILLEGAL_ARGUMENT, arg1);
        
        	}
        case FLTN:
        	switch(tag2){
            	case INTN: {x1 = GET_FLT(arg1);
                			s = GET_INT(arg2);
                            x2 = (double)s;
                            return(make_flt(x1/x2));}
                case FLTN: {x1 = GET_FLT(arg1);
                			x2 = GET_FLT(arg2);
                            return(make_flt(x1/x2));}
                case RAT:  {x1 = GET_FLT(arg1);
                			s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            x2 = (double)s/t;
                            return(make_flt(x1/x2));}
                case BIG:	return(BOOLF);
                case COMP: {x1 = GET_FLT(arg1);
                			y1 = 0;
                			x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1*x2/(y1*y1+y2*y2),-x1*y2/(y1*y1+y2*y2)));}
        	}
        case RAT:
        	switch(tag2){
            	case INTN: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            s = GET_INT(arg2);
                            return(make_rat(n,m*s));}
                case FLTN: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            x1 = (double)n/m;
                            x2 = GET_FLT(arg2);
                            return(make_flt(x1/x2));}
                case RAT:  {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            return(make_rat(n*t,m*s));}
                case BIG:	return(BOOLF);
                case COMP: {n = GET_CAR(arg1);
                			m = GET_CDR(arg1);
                            x1 = (double)n/m;
                            y1 = 0;
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp(x1*x2/(y1*y1+y2*y2),-x1*y2/(y1*y1+y2*y2)));}
        }
        
        case COMP:
        	switch(tag2){
            	case INTN: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            n = GET_INT(arg2);
                            x2 = (double)n;
                            return(make_comp(x1/x2,y1/x2));}
                case FLTN: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            x2 = GET_FLT(arg2);
                            return(make_comp(x1/x2,y1/x2));}
                case RAT:  {x1 = GET_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            s = GET_CAR(arg2);
                            t = GET_CDR(arg2);
                            x2 = (double)s/t;
                            return(make_comp(x1/x2,y1/x2));}
                case BIG:	return(BOOLF);
                case COMP: {x1 = GET_REAL_FLT(arg1);
                			y1 = GET_IMAG_FLT(arg1);
                            x2 = GET_REAL_FLT(arg2);
                            y2 = GET_IMAG_FLT(arg2);
                            return(make_comp((x1*x2+y1*y2)/(x2*x2+y2*y2),(y1*x2-x1*y2)/(x2*x2+y2*y2)));}
            }               
    }
    return(undef);  
}



int s_remainder(int x, int y){
	if(integerp(x) && integerp(y))
    	return(make_int(get_int(x) % get_int(y)));
    if(bignump(x) && integerp(y))
    	return(big_int_remainder(x,y));
    if(integerp(x) && bignump(y))
    	return(x);
	if(bignump(x) && bignump(y))
    	return(minus(x,mult(quotient(x,y),y)));
    
    exception("remainder", ILLEGAL_ARGUMENT, NIL);
    return(undef);
}


int quotient(int x, int y){
	if(integerp(x) && integerp(y))
    	return(make_int(get_int(x) / get_int(y)));
    
    if(bignump(x) && integerp(y)){
    	if(big_positivep(x))
    		return(big_int_quotient(x,y));
        else
        	return(big_rev(big_int_quotient(big_rev(x),y)));
    }
    
    if(bignump(x) && bignump(y))
    	return(big_quotient(x,y));
    
    if(integerp(x) && bignump(y))
    	return(make_int(0));
    
    exception("quotient", ILLEGAL_ARGUMENT, NIL);
    return(undef);
}

//®”‚ÌÅ‘åŒö–ñ”
int int_gcd(int x, int y){
	int r;
	
    if(y == 0)
    	return(x);
        
	while(y != 0){
		r = x % y;
        x = y;
        y = r;
	}
	return(x);
}

//bignum‚ğŠÜ‚Ş®”‚ÌÅ‘åŒö–ñ”
int gcd(int x, int y){
	int r;
    
	if(integerp(x) && integerp(y))
    	return(make_int(abs(int_gcd(get_int(x),get_int(y)))));
    
    if(floatp(x) && integerp(y))
    	return(make_flt((double)abs(int_gcd((int)GET_FLT(x),get_int(y)))));
    
    if(integerp(x) && floatp(y))
    	return(make_flt((double)abs(int_gcd(get_int(x),(int)GET_FLT(y)))));
    
    if(floatp(x) && floatp(y))
    	return(make_flt((double)abs(int_gcd(GET_FLT(x),(int)GET_FLT(y)))));
    
    while(!zerop(y)){
    	r = s_remainder(x,y);
        x = y;
        y = r;
        
    }
    return(s_abs(x));
}

//®”‚Ìê‡‚ÌÅ‘åŒö–ñ”
int int_lcm(int m, int n){
	if (m == 0 || n == 0)
		return(0);
        
	return ((m / int_gcd(m, n)) * n);
}
//bignum‚ğŠÜ‚Ş®”‚ÌÅ‘åŒö–ñ”
int lcm(int x, int y){
	int g,d,res;
	if(integerp(x) && integerp(y) &&
    	abs(get_int(x)) < 10000 && abs(get_int(y)) < 10000)// ‚È‚º‚È‚çx,y < sqrt(BIGNUM_BASE)
    	return(make_int(abs(int_lcm(get_int(x),get_int(y)))));
    
    if(floatp(x) && integerp(y))
    	return(make_flt((double)abs(int_lcm((int)GET_FLT(x),get_int(y)))));
    
    if(integerp(x) && floatp(y))
    	return(make_flt((double)abs(int_lcm(get_int(x),(int)GET_FLT(y)))));
    
    if(floatp(x) && floatp(y))
    	return(make_flt((double)abs(int_lcm(GET_FLT(x),(int)GET_FLT(y)))));
    
    else{
    	g = gcd(x,y);
        d = quotient(s_abs(x),g);
        res = mult(d,s_abs(y));
    	return(res); 
    }   
}

int s_abs(int x){
    
	if(integerp(x))
    	return(make_int(abs(get_int(x))));
    if(bignump(x)){
    	if(big_positivep(x))
        	return(x);
        if(big_negativep(x))
        	return(big_rev(x));
    }
    if(floatp(x)){
        return(make_flt(fabs(GET_FLT(x))));
    }
    if(rationalp(x))
    	return(make_rat(abs(GET_CAR(x)),GET_CDR(x)));
    exception("abs", ILLEGAL_ARGUMENT, x);
    return(undef);
}


//---------bignumŒ^‚Ì‰‰Z----------------
int big_plus(int arg1, int arg2){
	int res;
    if(big_positivep(arg1) && big_negativep(arg2))
    	return(big_minus(arg1,big_rev(arg2)));
    if(big_negativep(arg1) && big_positivep(arg2))
    	return(big_minus(arg2,big_rev(arg1)));
    
    res = big_plus1(arg1,arg2);
    if(big_integerizep(res))
    	return(bignumtoint(res));
    else
    	return(res);
}



//ğŒ arg1>0 arg2>0
int big_plus1(int arg1, int arg2){
	int x,y,z,c,q,res;
    
    res = NIL;
    c = 0;
    while(1){
    	if(nullp(arg1) && nullp(arg2)){
        	if(c != 0)
        		res = reverse(cons(make_int(c),res));
            else
            	res = reverse(res);
            SET_TAG(res,BIG);
            return(res);
        }
       	
        if(nullp(arg1) && !nullp(arg2)){
        	x = 0;
            y = GET_INT(car(arg2));
        }
        else if(!nullp(arg1) && nullp(arg2)){
        	x = GET_INT(car(arg1));
        	y = 0;
        }
        else {
        	x = GET_INT(car(arg1));
        	y = GET_INT(car(arg2));
        }
        
        z = x + y + c;
        c = z / BIGNUM_BASE;
        q = z - (c * BIGNUM_BASE);
        res = cons(make_int(q),res);
        arg1 = cdr(arg1);
        arg2 = cdr(arg2);
    }
}


//•„†”½“]
int big_rev(int arg){
	int res;
    
    res = NIL;
    while(!nullp(arg)){
        res = cons(make_int(get_int(car(arg)) * -1),res);
        arg = cdr(arg);
    }
    res = reverse2(res);
    SET_TAG(res,BIG);
    return(res);
}

int big_minus(int arg1, int arg2){
	int x,y,res;
    
    res = undef;
    
    if(big_positivep(arg1) && big_negativep(arg2))
    	return(big_plus(arg1,big_rev(arg2)));
    if(big_negativep(arg1) && big_positivep(arg2))
    	return(big_rev(big_plus(big_rev(arg1),arg2)));
    if(big_positivep(arg1) && big_positivep(arg2)){
		if(big_greaterp(arg1,arg2))
    		res = big_minus1(arg1,arg2);
    	else
    		res = big_rev(big_minus1(arg2,arg1));
    }
            
    if(big_negativep(arg1) && big_negativep(arg1)){
    	x = big_rev(arg1);
        y = big_rev(arg2);
        if(big_greaterp(x,y))
    		res = big_rev(big_minus1(x,y));
    	else
    		res = (big_minus1(y,x));
    }
    

    if(big_integerizep(res))
        	return(bignumtoint(res));
        else
        	return(res); 
}

// ğŒ@arg1>0 arg2>0 arg1>arg2
int big_minus1(int arg1, int arg2){
	int x,y,z,c,res;
    
    res = NIL;
    c = 0;
    while(1){
        if(nullp(arg2)){
        	while(!nullp(arg1)){
        		x = get_int(car(arg1));
                if((x + c) < 0){
                	x = x + BIGNUM_BASE + c;
                    c = -1;
                	res = cons(make_int(x),res);
                }
                else{
                    x = x + c;
                    c = 0;
                    res = cons(make_int(x),res);
                }
                arg1 = cdr(arg1);
            }
            res= norm_bignum(reverse(res));
            SET_TAG(res,BIG);
            return(res);
    	}
        x = get_int(car(arg1));
        y = get_int(car(arg2));
        if((x + c - y) < 0){
        	z = (x + BIGNUM_BASE + c) - y;
            c = -1;
        }
        else{
        	z = (x + c) - y;
        	c = 0;
        }
        res = cons(make_int(z),res);
        arg1 = cdr(arg1);
        arg2 = cdr(arg2);
    }
}

//bignum‚Æbignum‚Æ‚ÌæZ
int big_mult(int arg1, int arg2){
	//”íæ”‚Ì•û‚ª‘å‚«‚¢•û‚ªƒƒ‚ƒŠŒø—¦‚ª‚¢‚¢‚½‚ßB
	if(big_greaterp(arg1,arg2))
    	return(big_mult1(arg1,arg2));
    else
    	return(big_mult1(arg2,arg1));
}

int	big_mult1(int arg1, int arg2){
	int org_arg1,n,acc,res;
    long long int l,l1,l2,c,r;
    
    org_arg1 = arg1;
    n = 0;
    res = list1(make_int(0));
    acc = NIL;
    while(!nullp(arg2)){
    	l2 = (long long int)get_int(car(arg2));
        c = 0;
        while(!nullp(arg1)){
        	l1 = (long long int)get_int(car(arg1));
            l = l1 * l2 + c;
            c = l / BIGNUM_BASE;
            r = l % BIGNUM_BASE;
            acc = cons(make_int((int)r),acc);
            arg1 = cdr(arg1);
    	}
        if(c != 0)
        	acc = cons(make_int((int)c),acc);
        
        acc = big_sift(reverse2(acc),n);
        res = big_plus1(res,acc);
        n++;
        acc = NIL;
        arg1 = org_arg1;
        arg2 = cdr(arg2);
    }
    SET_TAG(res,BIG);
    return(res);
}

//bignum(arg1)‚Æint(arg2)‚Æ‚ÌæZ
int big_int_mult(int arg1, int arg2){
	int res;
    long long int l,l1,l2,c,r;
    
    res = NIL;
    l2 = (long long int)get_int(arg2);
    c = 0;
    while(!nullp(arg1)){
    	l1 = (long long int)get_int(car(arg1));
        l = l1 * l2 + c;
        c = l / BIGNUM_BASE;
        r = l % BIGNUM_BASE;
        res = cons(make_int((int)r),res);
        arg1 = cdr(arg1);
    }
    if(c != 0)
    	res = cons(make_int((int)c),res);
    
    res = reverse2(res);
    SET_TAG(res,BIG);
    return(res);
}


//ƒNƒk[ƒX@‘æ4Šª@88ƒy[ƒWQÆ
int	big_quotient(int arg1, int arg2){
	if(big_positivep(arg1) && big_positivep(arg2))
    	return(big_quotient1(arg1,arg2));    
    if(big_positivep(arg1) && big_negativep(arg2))
    	return(big_rev(big_quotient(arg1,big_rev(arg2))));
    if(big_negativep(arg1) && big_positivep(arg2))
    	return(big_rev(big_quotient(big_rev(arg1),arg2)));
    if(big_negativep(arg1) && big_negativep(arg2))
    	return(big_quotient(big_rev(arg1),big_rev(arg2)));
    return(undef);
}

//”íœ”bignum‚Æœ”bignum‚Ìê‡‚Ì¤
int	big_quotient1(int arg1, int arg2){
	int s,ds,p,res; //s=siftŒ…‡‚í‚¹, dsœ”,p=plus‘«‚µ–ß‚µ
    long long int d,u,v,q;
    
    //”íœ”‚ªœ”‚æ‚è¬‚³‚¯‚ê‚Î‚O‚Æ‚·‚éB
    if(smallerp(arg1,arg2))
    	return(make_int(0));
    
    //”íœ”‚ªœ”‚Ì2”{‚æ‚è¬‚³‚¯‚ê‚Î‚P‚Æ‚·‚éB
    //¤‚ª1‚É‚È‚éê‡‚É‚Í’è—‚Í¬‚è—§‚½‚È‚¢‚Í‚¸B
    s = mult(arg2,make_int(2));
    if(smallerp(arg1,s))
    	return(make_int(1));
    
    res = NIL;
    //œ”‚ª¬‚³‚¯‚ê‚Î’è—‚ª¬‚è—§‚Â‚æ‚¤‚É‘å‚«‚­‚·‚éB
    v = (long long int)get_int(last(arg2));
    if(v < (BIGNUM_BASE / 2)){
        	d = BIGNUM_BASE / (v + 1);
        	arg1 = mult(arg1,make_int((int)d));
            arg2 = mult(arg2,make_int((int)d));
        }
    	
    
    while(1){
        u = (long long int)get_int(last(arg1)) * BIGNUM_BASE +
            	(long long int)get_int(last(butlast(arg1)));
        v = (long long int)get_int(last(arg2));
        //q = min(u/v,BIGNUM_BASE-1)
        q = u / v;
        if(q > BIGNUM_BASE-1)
        	q = BIGNUM_BASE-1;
        
        ds = mult(arg2,make_int((int)q));
        s = length(arg1) - length(ds);
        ds = big_sift(ds,s);
        p = big_sift(arg2,s); 
        arg1 = minus(arg1,ds);
        
        
        if(big_negativep(arg1)){
        	arg1 = plus(arg1,p);
            q--;
        }
        if(big_negativep(arg1)){
        	arg1 = plus(arg1,p);
            q--;
        }
        
        res = cons(make_int((int)q),res);
        
        if(smallerp(arg1,arg2))
        	break;
              
    }
    SET_TAG(res,BIG);
    if(big_integerizep(res))
    	return(bignumtoint(res));
    else
    	return(res);
}

//”íœ”bignum‚Æœ”int‚Ìê‡‚Ì¤
int big_int_quotient(int arg1, int arg2){
	int res;
    long long int u,v,q,r;
    
    res = NIL;
	
    v = (long long int)get_int(arg2);
    if(v == 0)
    	exception("quotient", ILLEGAL_ARGUMENT, arg2);
	
    u = (long long int)get_int(last(arg1));
    if(u < v){
    	r = u;
        arg1 = butlast(arg1);
    }
    else
    	r = 0;
    
    while(!nullp(arg1)){
    	u = (long long int)get_int(last(arg1));
        q = (r * BIGNUM_BASE + u) / v;
        r = (r * BIGNUM_BASE + u) % v;
        res = cons(make_int((int)q),res);
        arg1 = butlast(arg1);
    }

    SET_TAG(res,BIG);
    if(big_integerizep(res)){
    	return(bignumtoint(res));
	}
    return(res);	
}

//ãˆÊŒ…‚Ì‚O‚ğƒJƒbƒg‚·‚éB
int norm_bignum(int arg){
	int car_addr,lis,res;
    
	res = NIL;
    lis = reverse2(arg);
	while(!nullp(lis)){
    	car_addr = car(lis);
        if(GET_INT(car_addr) != 0){
        	res = reverse2(lis);
            SET_TAG(res,BIG);	
            return(res);
        }
        else
        	lis = cdr(lis);	
    }
    return(make_int(0));
}

int inttobignum(int x){
	int res;
    
    res = list1(make_int(get_int(x)));
    SET_TAG(res,BIG);
    return(res);    
}

int bignumtoint(int x){
	
    return(make_int(get_int(car(x))));	
}

//”äŠr
int big_eqp(int arg1, int arg2){
	int l1,l2;
    
    l1 = length(arg1);
    l2 = length(arg2);
    

	if(l1 != l2)
    	return(0);
    else{
    	while(!nullp(arg1)){
        	if(get_int(car(arg1)) != get_int(car(arg2)))
    			return(0);
            
            arg1 = cdr(arg1);
            arg2 = cdr(arg2);
        }
    }	
    return(1);	
}

int big_greaterp(int arg1, int arg2){
	int l1,l2,a1,a2;
    
    l1 = length(arg1);
    l2 = length(arg2);
    

	if(l1 > l2)
    	return(1);
    else
    if(l1 == l2){
    	a1 = reverse(arg1);
    	a2 = reverse(arg2);
    	while(!nullp(a1)){
        	if(get_int(car(a1)) > get_int(car(a2)))
    			return(1);
            if(get_int(car(a1)) < get_int(car(a2)))
    			return(0);
            a1 = cdr(a1);
            a2 = cdr(a2);
        }
        return(0);
    }	
    else
    	return(0);	
}

int big_smallerp(int arg1, int arg2){
	int l1,l2,a1,a2;
    
    l1 = length(arg1);
    l2 = length(arg2);
    

	if(l1 < l2)
    	return(1);
    else
    if(l1 == l2){
    	a1 = reverse(arg1);
    	a2 = reverse(arg2);
    	while(!nullp(a1)){
        	if(get_int(car(a1)) < get_int(car(a2)))
    			return(1);
            
            if(get_int(car(a1)) > get_int(car(a2)))
            	return(0);
                
            a1 = cdr(a1);
            a2 = cdr(a2);
        }
        return(0);
    }	
    else
    	return(0);	
}



//intŒ^‚É•ÏŠ·‰Â”\‚©
int big_integerizep(int x){
    int y;
    
    y = cdr(x);
    while(!nullp(y)){
    	if(get_int(car(y)) != 0)
        	return(0);
        else
        	y = cdr(y);
    }
    return(1);	
}

//ƒvƒ‰ƒX‚©
int big_positivep(int x){

    while(!nullp(cdr(x)))
    	x = cdr(x);
    
	if(get_int(car(x)) > 0)
    	return(1);
    else
    	return(0);
}
//ƒ}ƒCƒiƒX‚©
int big_negativep(int x){
	
    while(!nullp(cdr(x)))
    	x = cdr(x);
    
	if(get_int(car(x)) < 0)
    	return(1);
    else
    	return(0);
}

int	big_abs(int x){
	if(big_positivep(x))
    	return(x);
    else
    	return(big_rev(x));
}



//‚ŒÂ•ª‚O‚ÌƒZƒ‹‚ğ•t‰ÁBƒrƒbƒgƒVƒtƒg‚Ì‚æ‚¤‚ÈŠ´‚¶B
int	big_sift(int x, int n){
	int res;
    
    if(n == 0)
    	return(x);
        
    res = x;
    while(n > 0){
    	res = cons(make_int(0),res);
        n--;
    }
    SET_TAG(res,BIG);
    return(res);
}

//bignum‚Æint‚Æ‚Ìè—]‚ğŒvZ‚·‚éB
int	big_int_remainder(int x, int y){
	int big,sign1,sign2;
    long long int i,j,r;
    
    if(big_negativep(x)){
    	big = reverse(big_rev(x));
    	sign1 = -1;
    }
    else{
    	big = reverse(x);
    	sign1 = 1;
    }
    
    j = get_int(y);
    if(j < 0){
    	j = abs(j);
        sign2 = -1;
    }
    else{
    	sign2 = 1;
    }
    	
    r = 0;
    
    while(!nullp(big)){
    	i = get_int(car(big));
        i = i + r * BIGNUM_BASE;
        if(i >= j)
        	r = i % j;
        else
        	r = i + r;
        big = cdr(big);
    }
    return(make_int((int)r*sign1*sign2));
}



L     æ¡  w     .text           (T    ti      Ú    0`.data                               @ 0À.bss                                € 0À.rdata          €  ,U  ø™      Œ   @ @@.drectve        D  ¬W              @ 0À/4              „  ğX  pŸ      ?   @ 0@WVSƒì‰Ö‰$è    ‰Ã‰4$è    ‰Æëbf‰$è    ‰$è    ‰Ç‰4$è    ‰$è    9ÇR‰$è    ‰$è    ‰Ç‰4$è    ‰$è    9Ç| ‰$è    ‰Ã‰4$è    ‰Æ‰$è    …Àt”1ÀƒÄ[^_Ãv ¸   ƒÄ[^_ÃWVSƒì‰Ö‰$è    ‰Ã‰4$è    ‰Æëbf‰$è    ‰$è    ‰Ç‰4$è    ‰$è    9Ç|R‰$è    ‰$è    ‰Ç‰4$è    ‰$è    9Ç ‰$è    ‰Ã‰4$è    ‰Æ‰$è    …Àt”1ÀƒÄ[^_Ãv ¸   ƒÄ[^_Ã1À÷D$   @•ÀÃfWVƒì$‹D$0©   @u(Áà‹   ƒút;;Œp‘±ƒeƒXƒgƒR[ƒh

;;‡“¡‚³‚ñ‚Ì‰ğàƒR[ƒh‚æ‚è,ˆê•”‰ü•Ò

(import (normal test))

(define (find-leaf obj tree)
  (call/cc
    (lambda (cc)
      (letrec ((iter
                 (lambda (tree)
                   (cond
                     ((null?  tree) #f)
                     ((pair? tree)
                      (iter (car tree))
                      (iter (cdr tree)))
                     (else
                       (if (eqv? obj tree)
                           (cc obj)
                           #t))))))
        (iter tree)))))
  

   
(test* "cont1" 9 (* 3 (call/cc (lambda (k) (+ 1 2)))))
(test* "cont2" 6 (* 3 (call/cc (lambda (k)  (+ 1 (k 2))))))
(test* "cont3" 7 (find-leaf 7 '(1 (2 3) 4 (5 (6 7)))))
(test* "cont4" #f (find-leaf 8 '(1 (2 3) 4 (5 (6 7)))))

(define cont #f)
(test* "cont5" 6 (+ 5 (call/cc (lambda (c) (begin (set! cont c) 1)))))
(test* "cont5-1" 16 (cont 11))
(test* "cont5-2" 21 (cont 16))
(test* "cont6" 65 (+ 20 30 (call/cc (lambda (cont) (+ 5 10)))))

(define cc 0)
(* 3 (call/cc (lambda (k)
                 (set! cc k)
                 (+ 1 2))))


(define cc1 0)

(define (bar)
  (call/cc 
    (lambda (c)
      (display "foo ")
      (set! cc1 c)
      (display "bar "))))

(define (loop)
  (call/cc 
    (lambda (esc)
      (letrec ((iter (lambda (s)
                       (display s) 
                       (if (eq? s 'end)
                           (esc #t)
                           (iter (read))))))
        (iter (read))))))


(define cont #f)
(define a
  (lambda ()
    (if (call/cc (lambda (c) (set! cont c) #f))
        (display 1)
        (display 0))
    (display 9)))

(define foo
  (lambda ()
    (let ((a (call/cc (lambda (c) c))))
      (let ((b (call/cc (lambda (c) c))))
        (a not)))))
      

(define product
  (lambda (ls)
    (call/cc
      (lambda (break)
        (let f ((ls ls))
          (cond ((null? ls) 1)
                ((= (car ls) 0) (break 0))
                (else (* (car ls)(f (cdr ls))))))))))

(((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!")

(let ((x (call/cc (lambda (k) k))))
  (x (lambda (ignore) "hi")))

(define retry #f)

(define factorial
  (lambda (x)
    (if (= x 0)
        (call/cc (lambda (k) (set! retry k) 1))
        (* x (factorial (- x 1))))))

(define cc #f)

(define (foo)
  (display "a\n")
  (call/cc (lambda (c) (set! cc c)))
  (display "b\n")
  (display "c\n"))
;;continuation test
;; Scheme ‚É‚æ‚é‹L†ˆ—“ü–å by ’–ŒÒrŒõA‰vè^¡@‹¤’˜


(define cont1 '())

(define (cont)
  (display "foo ")
  (call/cc (lambda (exit) (set! cont1 exit)))
  (display "bar ")(display "baz "))

;;; Simp> (cont)
;;; foo bar baz #<undef>
;;; Simp> (cont1 #t)
;;; bar baz #<undef>

(define (read-eval-print)
  (call/cc
    (lambda (c)
      (letrec ((loop
                 (lambda (x)
                   (if (eq? x  'end)
                       (c 'bye)
                       (display x))
                   (newline)
                   (flush)
                   (loop (read)))))
        (loop (read))))))

;;ƒIƒŠƒWƒiƒ‹‚Ìc=exit ‚¾‚Æ“®ì•s—Ç

(define (node-expand n lst)
  (if (zero? n)
      '()
      (cons (cons n lst) (node-expand (- n 1) lst))))


(define n 8)

(define (safe? lst)
  (let ((new (car lst))
        (hlst (cdr lst)))
    (if (null? hlst)
        #t
        (safe-aux? new (+ new 1) (- new 1) hlst))))


(define (safe-aux? new up down hlst)
  (if (null? hlst)
      #t
      (let ((pos (car hlst)))
        (and (not (= pos new))
             (not (= pos up))
             (not (= pos down))
             (safe-aux? new (+ up 1) (- down 1) (cdr hlst))))))

(define (goal? x n) (= (length x) n))

(define resume '())


(define (queens-cont n)
  (call/cc (lambda (exit)
             (letrec
               ((lst (node-expand n '()))
                (x '())
                (pop (lambda () (let ((y (car lst)))
                                  (set! lst (cdr lst)) y)))
                (push (lambda (y) (set! lst (append y lst))))
                (search
                  (lambda ()
                    (set! x (pop))
                    (if (null? lst) '()
                        (begin
                          (if (safe? x)
                              (if (goal? x n)
                                  (call/cc (lambda (cont)
                                                    (set! resume (lambda () (cont #t)))
                                                    (exit x)))
                                  (push (node-expand n x)))
                              #f)
                          (search))))))
               (search)))))




;;; Simp> (define resume '())
;;; resume
;;; Simp> (queens-cont 8)
;;; (5 7 2 6 3 1 4 8)
;;; Simp> (resume)
;;; (4 7 5 2 6 1 3 8)
;;; Simp> (resume)
;;; (6 4 7 1 3 5 2 8)
;;; Simp> 

(define (increase n k)
  (if (> n 10)
      '()
      (begin (display " i:")(display n)
             (increase (+ n 1) (call/cc k)))))

(define (decrease n k)
  (if (< n 0)
      '()
      (begin (display " d:")(display n)
             (decrease (- n 1) (call/cc k)))))
;;‡“¡‚³‚ñ‚ÌƒR[ƒh
;;; This function is re-assigned in `choose' and `fail' itself.
(define fail #f)

;;; function for nondeterminsm
(define (choose . ls)
  (if (null? ls)
      (fail)
      (let ((fail0 fail))
        (call/cc
          (lambda (cc)
            (set! fail
                  (lambda ()
                    (set! fail fail0)
                    (cc (apply choose (cdr ls)))))
            (cc (car ls)))))))

;;; write following at the end of file
;;; to initialize the value of the fail.
(call/cc
  (lambda (cc)
    (set! fail
          (lambda ()
            (cc 'no-choise)))))


(define yield #f)
 
;ƒWƒFƒlƒŒ[ƒ^‚ÌÀ‘•
(define (make-generator thunk)
  (define state (cons thunk '()))
  (define (run-generator)
    (set! state (call/cc (lambda (return)
      (set! yield (lambda x (call/cc (lambda (c) (return (cons c x))))))
      (apply (car state) (cdr state))
      (return (cons values '(#f))))))
    (apply values (cdr state)))
  run-generator)
 
;ƒnƒmƒC‚Ì“ƒ‚Ì‰~”Õ‚ğAfrom‚©‚çto‚ÖnŒÂ“®‚©‚·B
;towers‚Í“ƒ‚ÌƒŠƒXƒg‚ÅA“ƒ‚Íã‚©‚ç‡‚É•À‚×‚½‰~”Õ‚ÌƒŠƒXƒg‚Å‚ ‚éB
(define (hanoi n from to tmp towers)
  (if (= n 0)
      towers
      (let* ((t1 (hanoi (- n 1) from tmp to towers));‚Ü‚¸n-1ŒÂ‚Ì‰~”Õ‚ğfrom‚©‚çtmp‚É“®‚©‚·B
             (t2 (yield (move t1 from to))))        ;nŒÂ–Ú‚Ì‰~”Õ‚ğfrom‚©‚çto‚Ö“®‚©‚µAˆê’U’†’f‚·‚éB
            (hanoi (- n 1) tmp to from t2))))       ;‚»‚ÌŒãAn-1ŒÂ‚Ì‰~”Õ‚ğtmp‚©‚çto‚Ö“®‚©‚·B
 
;ƒnƒmƒC‚Ì“ƒ‚Ìˆê”Ôã‚Ì‰~”Õ‚ğfrom‚©‚çto‚ÉˆÚ“®‚·‚éB
(define (move lis from to)
  (define (moved-tower lis from to index)
    (cond
      ((= index from) (cdr  (list-ref lis from)))
      ((= index to)   (cons (car (list-ref lis from)) (list-ref lis to)))
      (else (list-ref lis index))))
  (let loop ((n 0))
    (if (= n (length lis)) '()
      (cons (moved-tower lis from to n) (loop (+ n 1))))))
 
(define hanoi-generator (make-generator (lambda () (hanoi 5 0 1 2 '((0 1 2 3 4) () ())))))

(define (fail) #f)
(define (amb-proc . x)
  (define former-fail fail)
  (if (null? x)
    (fail)
    (call/cc (lambda (return) ; •ªŠò“_
      (set! fail (lambda () ; ‘I‚Î‚È‚©‚Á‚½‘I‘ğˆ‚ğ•Û‘¶
        (set! fail former-fail)
        (return (apply amb-proc (cdr x)))))
      (return ((car x))))))) ; ˆê‚Â‚Ì‘I‘ğˆ‚ğ•Ô‚·
;;’x‰„•]‰¿‚ÌƒeƒXƒg

(import (scheme lazy))

(define (tarai x y z)
  (if (<= (force x) (force y))
      (force y)
      (tarai (delay (tarai (- x 1) y z))
             (delay (tarai (- y 1) z x))
             (delay (tarai (- z 1) x y)))))


Unnamed repository; edit this file 'description' to name the repository.
;;‹³ˆç—pLISPƒCƒ“ƒ^[ƒvƒŠƒ^@Ver0.3 for Normal
;;u‚Ü‚Á‚½‚­‚Í‚¶‚ß‚Ä‚Ìl‚Ì‚½‚ß‚ÌSchemev‚ÌŒã•Ò‚Åì‚Á‚½Pure Lisp‚ğ
;;Normal‚Å“®‚­‚æ‚¤‚Éè’¼‚µ‚µ‚½‚à‚Ì‚Å‚·B

(import (normal system))

(define *env* '((T T)(NIL NIL)))


(define (lisp)
  (init)
  (let loop ((e (read)))
    (if (equal? e '(exit))
        'good-bye
        (begin (print (ed-eval e *env*))
               (prompt)
               (loop (read))))))

(define (init)
  (begin 
    (display "Pure LISP for education")(newline)
    (prompt)))

(define (print s)
  (display s)
  (newline))

(define (prompt)
  (display "L> ")
  (flush))


(define (pair x y)
  (cond ((and (null? x)(null? y)) '())
        ((and (not (atom? x))(not (atom? y))) 
         (cons (list (car x) (car y))
               (pair (cdr x) (cdr y))))))


(define (ed-assoc x y)
  (cond ((null? y) 'NIL) 
        ((eq? (caar y) x) (cadar y))
        (else (ed-assoc x (cdr y)))))


(define (ed-eval e a)
  (cond ((atom? e)
         (cond ((number? e) e)
               ((string? e) e)
               ((symbol? e) (ed-assoc e a))))
        ((atom? (car e))
         (cond ((special-form? (car e)) (special-form e a))
               ((function? (car e)) (apply (function (car e)) (evlis (cdr e) a)))
               (else (ed-eval (cons (ed-assoc (car e) a)
                                    (evlis (cdr e) a))
                              a))))
        ((eq? (caar e) 'lambda) (ed-eval (caddar e)
                                         (append (pair (cadar e)
                                                       (evlis (cdr e) a))
                                                       a))))
        )


(define (special-form? e)
  (member e '(quote set! if define cond)))

(define (special-form e a)
  (cond ((eq? (car e) 'quote) (cadr e))
        ((eq? (car e) 'cond) (evcon (cdr e) a))
        ((eq? (car e) 'set!) (ed-set! (cadr e) (ed-eval (caddr e) a)))
        ((eq? (car e) 'define) (ed-define! (cadr e) (caddr e)))
        ((eq? (car e) 'if) (evif (cdr e) a))))

(define (function? e)
  (assoc e func-symbol))

(define (function e)
  (eval (cdr (assoc e func-symbol)))) 

(define func-symbol
  '((+ . +)
    (- . -)
    (* . *)
    (/ . /)
    (sin . sin)
    (cos . cos)
    (tan . tan)
    (asin . asin)
    (acos . acos)
    (atan . atan)
    (car . car)
    (cdr . ed-cdr)
    (cons . cons)
    (atom? . ed-atom)
    (eq? . ed-eq)))


(define (evcon c a)
  (cond ((not (eq? (ed-eval (caar c) a) 'NIL)) (ed-eval (cadar c) a))
        (else (evcon (cdr c) a))))

(define (evif c a)
  (if (not (eq? (ed-eval (car c) a) 'NIL))
      (ed-eval (cadr c) a)
      (ed-eval (caddr c) a)))

(define (evlis m a)
  (cond ((null? m) ())
        (else (cons (ed-eval (car m) a)
                    (evlis (cdr m) a)))))


(define (ed-cdr m)
  (cond ((null? m) 'NIL)
        ((null? (cdr m))'NIL)
        (else (cdr m))))
 
(define (ed-atom x)
  (if (atom? x)
      'T
      'NIL))

(define (ed-eq x y)
  (if (eq? x y)
      'T
      'NIL))

(define (ed-set! x y)
  (set! *env* (cons (list x y) *env*))
  y)

(define (ed-define! x y)
  (cond ((symbol? x) (ed-set! x y))
        ((pair? x) (ed-set! (car x)
                           (list 'lambda
                                 (cdr x))))))



;; ’áƒŒƒxƒ‹‚È—áŠOƒƒJƒjƒYƒ€‚ÌŠT”O“I‚ÈÀ‘•
;; %xh‚Í—áŠOƒnƒ“ƒhƒ‰‚ÌƒŠƒXƒg

(define (current-exception-handler) (car %xh))

(define (raise exn)
  (receive r ((car %xh) exn)
    (when (uncontinuable-exception? exn)
      (set! %xh (cdr %xh))
      (raise (make-error "returned from uncontinuable exception")))
    (apply values r)))

(define (with-exception-handler handler thunk)
  (let ((prev %xh))
    (dynamic-wind
      (lambda () (set! %xh (cons handler %xh)))
      thunk
      (lambda () (set! %xh prev)))))
ï»¿//Normal Scheme 


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>
#include <limits.h>
#include <setjmp.h>
#include <time.h>
#include <windows.h>
#include "norm.h"

 

int toupper(int c);
int tolower(int c);
int islower(int c);
int isupper(int c);
int isalpha(int c);
int isdigit(int c);
jmp_buf loadloop;

extern cell memory[];
extern int emem1[];
extern int emem2[];
extern jmp_buf toplevel;
extern clock_t gctime;
extern clock_t start_time;
extern clock_t end_time;
extern FILE *input_port;
extern FILE *output_port;
extern int loadflag;
extern int contflag;
extern token stok;
extern int genint;
extern int compflag;
extern int gbcflag;
extern int asmflag;
extern int profflag;
extern int stepflag;
extern int contflag;
extern int debugflag;
extern int step_on;
extern int prof_on;
extern int head;
extern int tail;
extern int code[];
extern int stack[];
extern int pc;
extern int sp;
extern int env;
extern int n_args;
extern int code_pointer[1000][2];
extern int code_pointer_end;
extern int trace_list;
extern int module_table[MODULESIZE][2];
extern int module_table_end;
extern int current_module;
extern int back_trace[TRACE_DEPTH][2];
extern int back_trace_end;


extern int s_head;
extern int s_tail;
extern int s_code[];
extern int s_stack[];
extern int s_pc;
extern int s_sp;
extern int s_env;
extern int s_n_args;
extern int s_code_pointer[1000][2];
extern int s_code_pointer_end;

//--------ãƒªã‚¹ãƒˆ-----
int f_car(int n){
	int arg;
    
    arg = pop_s();
    return(scm_car(arg));
}

int f_cdr(int n){
	int arg;
    
	arg = pop_s();
    return(scm_cdr(arg));
}

int f_cons(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
	return(cons(arg1,arg2));
}

int f_caar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caar",NOT_PAIR,arg);
    return(scm_car(scm_car(arg)));
}

int f_cdar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdar",NOT_PAIR,arg);
    return(scm_cdr(scm_car(arg)));
}

int f_cddr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cddr",NOT_PAIR,arg);
    return(scm_cdr(scm_cdr(arg)));
}

int f_cadr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cadr",NOT_PAIR,arg);
    return(scm_car(scm_cdr(arg)));
}


int f_caaar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caaar",NOT_PAIR,arg);
    return(scm_car(scm_car(scm_car(arg))));
}

int f_cdaar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdaar",NOT_PAIR,arg);
    return(scm_cdr(scm_car(scm_car(arg))));
}

int f_cadar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cadar",NOT_PAIR,arg);
    return(scm_car(scm_cdr(scm_car(arg))));
}

int f_caadr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caadr",NOT_PAIR,arg);
    return(scm_car(scm_car(scm_cdr(arg))));
}

int f_cddar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cddar",NOT_PAIR,arg);
    return(scm_cdr(scm_cdr(scm_car(arg))));
}

int f_caddr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caddr",NOT_PAIR,arg);
    return(scm_car(scm_cdr(scm_cdr(arg))));
}

int f_cdadr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdadr",NOT_PAIR,arg);
    return(scm_cdr(scm_car(scm_cdr(arg))));
}


int f_cdddr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdddr",NOT_PAIR,arg);
    return(scm_cdr(scm_cdr(scm_cdr(arg))));
}

int f_caaaar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caaaar",NOT_PAIR,arg);
    return(scm_car(scm_car(scm_car(scm_car(arg)))));
}

int f_cdaaar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdaaar",NOT_PAIR,arg);
    return(scm_cdr(scm_car(scm_car(scm_car(arg)))));
}

int f_cadaar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cadaar",NOT_PAIR,arg);
    return(scm_car(scm_cdr(scm_car(scm_car(arg)))));
}

int f_caadar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caadar",NOT_PAIR,arg);
    return(scm_car(scm_car(scm_cdr(scm_car(arg)))));
}

int f_caaadr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caaadr",NOT_PAIR,arg);
    return(scm_car(scm_car(scm_car(scm_cdr(arg)))));
}

int f_cddaar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cddaar",NOT_PAIR,arg);
    return(scm_cdr(scm_cdr(scm_car(scm_car(arg)))));
}

int f_caddar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caddar",NOT_PAIR,arg);
    return(scm_car(scm_cdr(scm_cdr(scm_car(arg)))));
}

int f_caaddr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("caaddr",NOT_PAIR,arg);
    return(scm_car(scm_car(scm_cdr(scm_cdr(arg)))));
}

int f_cdaadr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdaadr",NOT_PAIR,arg);
    return(scm_cdr(scm_car(scm_car(scm_cdr(arg)))));
}

int f_cdadar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdadar",NOT_PAIR,arg);
    return(scm_cdr(scm_car(scm_cdr(scm_car(arg)))));
}

int f_cadadr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cadadr",NOT_PAIR,arg);
    return(scm_car(scm_cdr(scm_car(scm_cdr(arg)))));
}

int f_cadddr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cadddr",NOT_PAIR,arg);
    return(scm_car(scm_cdr(scm_cdr(scm_cdr(arg)))));
}

int f_cdaddr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdaddr",NOT_PAIR,arg);
    return(scm_cdr(scm_car(scm_cdr(scm_cdr(arg)))));
}

int f_cddadr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cddadr",NOT_PAIR,arg);
    return(scm_cdr(scm_cdr(scm_car(scm_cdr(arg)))));
}

int f_cdddar(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cdddar",NOT_PAIR,arg);
    return(scm_cdr(scm_cdr(scm_cdr(scm_car(arg)))));
}

int f_cddddr(int n){
	int arg;
    
    arg = pop_s();
    if(!pairp(arg))
    	exception("cddddr",NOT_PAIR,arg);
    return(scm_cdr(scm_cdr(scm_cdr(scm_cdr(arg)))));
}

int f_assq(int n){
	int arg1,arg2,res;
    
    arg2 = pop_s();
    arg1 = pop_s();
    res = assq(arg1,arg2);
    return(res);
}

int f_assv(int n){
	int arg1,arg2,res;
    
    arg2 = pop_s();
    arg1 = pop_s();
    res = assv(arg1,arg2);
    return(res);
}

int f_assoc(int n){
	int arg1,arg2,res;
    
    arg2 = pop_s();
    arg1 = pop_s();
    res = assoc(arg1,arg2);
    return(res);
}


int f_memq(int n){
	int arg1,arg2,res;
    
    arg2 = pop_s();
    arg1 = pop_s();
    res = memq(arg1,arg2);
    return(res);
}

int f_memv(int n){
	int arg1,arg2,res;
    
    arg2 = pop_s();
    arg1 = pop_s();
    res = memv(arg1,arg2);
    return(res);
}

int f_member(int n){
	int arg1,arg2,res;
   	
    arg2 = pop_s();
    arg1 = pop_s();
    res = member(arg1,arg2);
    return(res);
}

	

int f_reverse(int n){
	int arg;
    
    arg = pop_s();
    return(reverse(arg));
}

//ç ´å£Šçš„ãƒªãƒãƒ¼ã‚¹
int f_reverse2(int n){
	int arg;
	
    arg = pop_s();
    return(reverse2(arg));
}

int f_setcar(int n){
	int arg1,arg2;
	
    arg2 = pop_s();
    arg1 = pop_s();
	return(setcar(arg1,arg2));
}    

int f_setcdr(int n){
	int arg1,arg2;
 	
    arg2 = pop_s();
    arg1 = pop_s();
	return(setcdr(arg1,arg2));
}


int f_append(int n){
	int arg1,arg2;
	
    arg2 = pop_s();
    n--;
    if(!pairp(arg2) && !nullp(arg2))
    	exception("append", NOT_LIST, arg2);

    while(n > 0){
    	arg1 = pop_s();
        n--;
        if(!listp(arg1) && !nullp(arg1))
        	exception("append", NOT_LIST, arg1);
        arg2 = append(arg1,arg2);
    }
    return(arg2);
}

int f_append2(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    return(append2(arg1,arg2));
}

int f_list(int n){
	int res;
	
    res = NIL;
    while(n > 0){
    	res = cons(pop_s(),res);
        n--;
    }
	return(res);
}

int f_makelist(int n){
	int arg1,arg2,m,res;
    
    if(n == 2){
    	arg2 = pop_s();
    	arg1 = pop_s();
    }
    else{
    	arg1 = pop_s();
        arg2 = NIL;
    }
    if(!integerp(arg1))
    	exception("make-list", NOT_INTEGER, arg1);
    m = get_int(arg1);
    res = NIL;
    while(m > 0){
    	res = cons(arg2,res);
        m--;
    }
    return(res);
}	    

int f_length(int n){
	int arg,l;
    
    arg = pop_s();
    if(!(listp(arg)))
    	exception("length", NOT_PAIR, arg);
    l = length(arg);
    return(make_int(l));
}

int f_pair_length(int n){
	int arg,l;
    
    arg = pop_s();
    if(!(pairp(arg)))
    	exception("pair-length", NOT_PAIR, arg);
    l = length(arg);
    return(make_int(l));
}

int f_listtail(int n){
	int arg1,arg2,m;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!IS_INTEGER(arg2) || negativep(arg2))
    	exception("list-ref",NOT_EXACT,arg2);
    m = GET_INT(arg2);
    return(listtail(arg1,m));
}


int f_listref(int n){
	int arg1,arg2,m;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!IS_INTEGER(arg2) || negativep(arg2))
    	exception("list-ref",NOT_EXACT,arg2);
    m = GET_INT(arg2);
    return(listref(arg1,m));
}

int f_last(int n){
	int arg;
    
    arg = pop_s();
    return(last(arg));
}

int	f_butlast(int n){
	int arg;
    
    arg = pop_s();
    return(butlast(arg));
}


//----------è¿°èª-----------------
int f_nullp(int n){
	int arg;
    
	arg = pop_s();
	if(nullp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_listp(int n){
	int arg;
    
    arg = pop_s();
    if(listp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_pairp(int n){
	int arg;
    
    arg = pop_s();
    if(pairp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_boolp(int n){
	int arg;
    
    arg = pop_s();
    if(!IS_INTEGER(arg) && IS_BOOL(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_symbolp(int n){
	int arg;
    
    arg = pop_s();
    if(symbolp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_procedurep(int n){
	int arg;
    
    arg = pop_s();
    if(procedurep(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_atomp(int n){
	int arg;
    
    arg = pop_s();
    if(atomp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_eqp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(eqp(arg1,arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_eqvp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(eqvp(arg1,arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_equalp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    
    if(equalp(arg1,arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_numberp(int n){
	int arg;
    
    arg = pop_s();
    if(numberp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

//æµ®å‹•å°æ•°ç‚¹æ•°ã§ã‚ã£ã¦ã‚‚æ•°å­¦ä¸Šã®æ•´æ•°ãªã‚‰#tã‚’è¿”ã™ã€‚
int f_integerp(int n){
	int arg;
    double x;
    
    arg = pop_s();
    if(integerp(arg) || bignump(arg))
    	return(BOOLT);
    else
    if(floatp(arg)){
    	x = GET_FLT(arg);
        if(ceil(x) == floor(x))
        	return(BOOLT);
        else
        	return(BOOLF);
    } 
    else
    	return(BOOLF);
}

int f_realp(int n){
	int arg;
    
    arg = pop_s();
	if(realp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);	
}

int f_rationalp(int n){
	int arg;
    
    arg = pop_s();
	if(rationalp(arg) || integerp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

//Simpleã§ã¯è¤‡ç´ æ•°ã‚’ã“ãˆã‚‹ã‚‚ã®ã¯æ‰±ã‚ãªã„ã®ã§number? == complex?
int f_complexp(int n){
	int arg;
    
    arg = pop_s();
	if(numberp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int	f_exactp(int n){
	int arg;
    
    arg = pop_s();
    if(exactp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int	f_inexactp(int n){
	int arg;
    
    arg = pop_s();
    if(inexactp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_stringp(int n){
	int arg;
    
    arg = pop_s();
    if(stringp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int	f_characterp(int n){
	int arg;
    
    arg = pop_s();
    if(charp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_bignump(int n){
	int arg;
    
    arg = pop_s();
    if(!IS_INTEGER(arg) && IS_BIGNUM(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
    
}

int	f_vectorp(int n){
	int arg;
    
    arg = pop_s();
    if(IS_VECTOR(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_macrop(int n){
	int arg;
    
    arg = pop_s();
    if(IS_MACRO(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_macro_namep(int n){
	int arg;
    
    arg = pop_s();
    if(macro_namep(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}



int identifier_to_symbol(int x){
	
    return(make_sym(GET_NAME(x)));
}

int f_hygienic_namep(int n){
	int arg;
    
    arg = pop_s();
    if(hygienic_namep(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

//-------ãƒ™ã‚¯ã‚¿-----------------
int f_make_vector(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(nullp(arg2))
    	arg2 = undef;
    
    return(make_vector(get_int(arg1),arg2));
}

int f_vector_set(int n){
	int arg1,arg2,arg3;
    
    
    arg3 = pop_s();
    arg2 = pop_s();
    arg1 = pop_s();
    if(!vectorp(arg1))
    	exception("vector-set!",NOT_VECTOR, arg1);
    if(!IS_INTEGER(arg2) || negativep(arg2))
    	exception("vector-set!",NOT_EXACT, arg2);
    
    vector_set(arg1,get_int(arg2),arg3);
    return(undef);
}

int f_vector_ref(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!vectorp(arg1))
    	exception("vector-ref", NOT_VECTOR, arg1);
	if(!IS_INTEGER(arg2) || negativep(arg2))
    	exception("vector-ref",NOT_EXACT, arg2);
    
    return(vector_ref(arg1,get_int(arg2)));
}

int f_vector(int n){
	int i,res;
    
    res = make_vector(n,NIL);
    for(i=n; i>0; i--)
    	vector_set(res,i-1,pop_s());
    
	return(res);
}

int f_vector_length(int n){
	int arg;
    
    arg = pop_s();
    return(make_int(vector_length(arg)));
}

int f_vector_fill(int n){
	int arg1,arg2,len,i;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!vectorp(arg1))
    	exception("vector-fill!", NOT_VECTOR, arg1);
        
    len = vector_length(arg1);
    for(i=0; i<len; i++)
    	vector_set(arg1,i,arg2);
    
    return(undef);
}

int f_vector_to_list(int n){
	int arg,res,i;
    
    arg = pop_s();
    if(!vectorp(arg))
    	exception("vector->list", NOT_VECTOR, arg);
    i = vector_length(arg) - 1;
    res = NIL;
    while(i >= 0){
    	res = cons(vector_ref(arg,i),res);
        i--;
    }
    return(res);   
}

int	f_list_to_vector(int n){
	int arg,res,i;
    
    arg = pop_s();
    if(!listp(arg))
    	exception("list->vector", NOT_LIST, arg);
    res = make_vector(length(arg),undef);
    i = 0;
    while(!nullp(arg)){
    	vector_set(res,i,car(arg));
        arg = cdr(arg);
        i++;
    }
    return(res);
}


//-----------æ–‡å­—------------------------------
int f_char_eqp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char=?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char=?", NOT_CHAR, arg2);
    if(GET_CHAR(arg1) == GET_CHAR(arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_ci_eqp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char-ci=?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char-ci=?", NOT_CHAR, arg2);
    if(toupper(GET_CHAR(arg1)) == toupper(GET_CHAR(arg2)))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_greaterp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char>?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char>?", NOT_CHAR, arg2);
    if(GET_CHAR(arg1) > GET_CHAR(arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_ci_greaterp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char-ci>?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char-ci>?", NOT_CHAR, arg2);
    if(toupper(GET_CHAR(arg1)) > toupper(GET_CHAR(arg2)))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_eqgreaterp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char>=?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char>=?", NOT_CHAR, arg2);
    if(GET_CHAR(arg1) >= GET_CHAR(arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_ci_eqgreaterp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char-ci>=?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char-ci>=?", NOT_CHAR, arg2);
    if(toupper(GET_CHAR(arg1)) >= toupper(GET_CHAR(arg2)))
    	return(BOOLT);
    else
    	return(BOOLF);
}


int f_char_smallerp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char<?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char<?", NOT_CHAR, arg2);
    if(GET_CHAR(arg1) < GET_CHAR(arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_ci_smallerp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char-ci<?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char-ci<?", NOT_CHAR, arg2);
    if(toupper(GET_CHAR(arg1)) < toupper(GET_CHAR(arg2)))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_eqsmallerp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char<=?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char<=?", NOT_CHAR, arg2);
    if(GET_CHAR(arg1) <= GET_CHAR(arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_ci_eqsmallerp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!charp(arg1))
    	exception("char-ci<=?", NOT_CHAR, arg1);
    if(!charp(arg2))
    	exception("char-ci<=?", NOT_CHAR, arg2);
    if(toupper(GET_CHAR(arg1)) <= toupper(GET_CHAR(arg2)))
    	return(BOOLT);
    else
    	return(BOOLF);
}


int f_char_alphabeticp(int n){
	int arg;
    
    arg = pop_s();
    if(!charp(arg))
    	exception("char-alphabetic?", NOT_CHAR, arg);
    if(charp(arg) && isalpha(GET_CHAR(arg)))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_numericp(int n){
	int arg;
    
    arg = pop_s();
    if(!charp(arg))
    	exception("char-numeric?", NOT_CHAR, arg);
    if(charp(arg) && isdigit(GET_CHAR(arg)))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_whitespacep(int n){
	int arg;
    
    arg = pop_s();
    if(!charp(arg))
    	exception("char-whitespace?", NOT_CHAR, arg);
    if(charp(arg) && GET_CHAR(arg) == SPACE)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_upper_casep(int n){
	int arg;
    
    arg = pop_s();
    if(!charp(arg))
    	exception("char-upper-case?", NOT_CHAR, arg);
    if(charp(arg) && isupper(GET_CHAR(arg)))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_char_lower_casep(int n){
	int arg;
    
    arg = pop_s();
    if(!charp(arg))
    	exception("char-lower-case?", NOT_CHAR, arg);
    if(charp(arg) && islower(GET_CHAR(arg)))
    	return(BOOLT);
    else
    	return(BOOLF);
}


int f_char_to_integer(int n){
	int arg;
	
    arg = pop_s();
    if(!charp(arg))
    	exception("char->integer", NOT_CHAR, arg);
    return(make_int((int)GET_CHAR(arg)));
}

int f_integer_to_char(int n){
	int arg,res;
    
    arg = pop_s();
    if(!integerp(arg))
    	exception("integer->char", NOT_INTEGER, arg);
    res = make_char(" ");
    SET_CHAR(res,(char)get_int(arg));
    return(res);
}

int f_char_upcase(int n){
	int arg,res;
	
    arg = pop_s();
    if(!charp(arg))
    	exception("char-upcase", NOT_CHAR, arg);
    res = make_char(" ");
	SET_CHAR(res,toupper(GET_CHAR(arg)));
    return(res);
}


int f_char_downcase(int n){
	int arg,res;
	
    arg = pop_s();
    if(!charp(arg))
    	exception("char-downcase", NOT_CHAR, arg);
    res = make_char(" ");
	SET_CHAR(res,tolower(GET_CHAR(arg)));
    return(res);
}

//---------æ–‡å­—åˆ—---------------------
int f_string_eqp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string=?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string=?", NOT_STRING, arg2);
    if(SAME_NAME(arg1,arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_ci_eqp(int n){
	int arg1,arg2,i;
    char str1[SYMSIZE],str2[SYMSIZE];
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string-ci=?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string-ci=?", NOT_STRING, arg2);
    strcpy(str1,GET_NAME(arg1));
    strcpy(str2,GET_NAME(arg2));
    i = 0;
    while(str1[i] != NUL){
    	str1[i] = toupper(str1[i]);
        i++;
    }
    i = 0;
    while(str2[i] != NUL){
    	str2[i] = toupper(str2[i]);
        i++;
    }
    if(strcmp(str1,str2) == 0)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_greaterp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string>?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string>?", NOT_STRING, arg2);
    if(GREATER_NAME(arg1,arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_ci_greaterp(int n){
	int arg1,arg2,i;
    char str1[SYMSIZE],str2[SYMSIZE];
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string-ci>?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string-ci>?", NOT_STRING, arg2);
    strcpy(str1,GET_NAME(arg1));
    strcpy(str2,GET_NAME(arg2));
    i = 0;
    while(str1[i] != NUL){
    	str1[i] = toupper(str1[i]);
        i++;
    }
    i = 0;
    while(str2[i] != NUL){
    	str2[i] = toupper(str2[i]);
        i++;
    }
    if(strcmp(str1,str2) > 0)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_eqgreaterp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string>=?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string>=?", NOT_STRING, arg2);
    if(GREATER_NAME(arg1,arg2) || SAME_NAME(arg1,arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_ci_eqgreaterp(int n){
	int arg1,arg2,i;
    char str1[SYMSIZE],str2[SYMSIZE];
    
    arg1 = pop_s();
    arg2 = pop_s();
    if(!stringp(arg1))
    	exception("string>=?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string=?", NOT_STRING, arg2);
    strcpy(str1,GET_NAME(arg1));
    strcpy(str2,GET_NAME(arg2));
    i = 0;
    while(str1[i] != NUL){
    	str1[i] = toupper(str1[i]);
        i++;
    }
    i = 0;
    while(str2[i] != NUL){
    	str2[i] = toupper(str2[i]);
        i++;
    }
    if(strcmp(str1,str2) >= 0)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_smallerp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string<?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string=<", NOT_STRING, arg2);
    if(SMALLER_NAME(arg1,arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_ci_smallerp(int n){
	int arg1,arg2,i;
    char str1[SYMSIZE],str2[SYMSIZE];
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string-ci<?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string-ci<?", NOT_STRING, arg2);
    strcpy(str1,GET_NAME(arg1));
    strcpy(str2,GET_NAME(arg2));
    i = 0;
    while(str1[i] != NUL){
    	str1[i] = toupper(str1[i]);
        i++;
    }
    i = 0;
    while(str2[i] != NUL){
    	str2[i] = toupper(str2[i]);
        i++;
    }
    if(strcmp(str1,str2) < 0)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_eqsmallerp(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string<=?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string<=?", NOT_STRING, arg2);
    if(SMALLER_NAME(arg1,arg2) || SAME_NAME(arg1,arg2))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_string_ci_eqsmallerp(int n){
	int arg1,arg2,i;
    char str1[SYMSIZE],str2[SYMSIZE];
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string-ci<=?", NOT_STRING, arg1);
    if(!stringp(arg2))
    	exception("string-ci<=?", NOT_STRING, arg2);
    strcpy(str1,GET_NAME(arg1));
    strcpy(str2,GET_NAME(arg2));
    i = 0;
    while(str1[i] != NUL){
    	str1[i] = toupper(str1[i]);
        i++;
    }
    i = 0;
    while(str2[i] != NUL){
    	str2[i] = toupper(str2[i]);
        i++;
    }
    if(strcmp(str1,str2) <= 0)
    	return(BOOLT);
    else
    	return(BOOLF);
}


int	f_string_append(int n){
	int arg1,arg2;
    char str1[SYMSIZE],str2[SYMSIZE];
    
    arg2 = pop_s();
    n--;
    if(nullp(arg2))
    	return(make_str(""));
    if(!stringp(arg2))
    	exception("string-append", NOT_STRING, arg2);
    strcpy(str2,GET_NAME(arg2));
    while(n != 0){
    	arg1 = pop_s();
        n--;
        if(!stringp(arg1))
        	exception("string-append", NOT_STRING, arg1);
    	strcpy(str1,GET_NAME(arg1));
    	strcat(str1,str2);
        strcpy(str2,str1);
    }
    return(make_str(str1));
}

//ä»¥ä¸‹ã¾ã ç›´ã—ã¦ã„ãªã„ã€‚
int f_number_to_string(int n){
	int arg1,arg2,d,x;
    char str1[SYMSIZE],str2[2],str3[SYMSIZE],str4[2];
    
    if(n == 2){
    	arg2 = pop_s();
    	arg1 = pop_s();
    }
    else{
    	arg2 = NIL;
        arg1 = pop_s();
    }
    
    if(!numberp(arg1))
    	exception("number->string", NOT_NUMBER, arg1);
    if(!nullp(arg2) && !integerp(arg2))
    	exception("number->string", NOT_INTEGER, arg2);
    if(nullp(arg2))
    	d = 10;
    else
    	d = get_int(arg2);
    
    if(integerp(arg1))
    	itoa(get_int(arg1),str1,d);
    
    //ä¸å®Œå…¨ã€ï¼‘ï¼é€²æ•°ã®ã¿ã€‚
    if(bignump(arg1)){
    	x = reverse(arg1);
        str1[0] = NUL;
        itoa(get_int(car(x)),str3,10);
        strcat(str1,str3);
        x = cdr(x);
        while(!nullp(x)){
        	sprintf(str3,"%09d",get_int(car(x)));
            strcat(str1,str3);
            x = cdr(x); 
        }
        return(make_str(str1));
    }
    
    if(floatp(arg1))
    	sprintf(str1,"%0.16g",GET_FLT(arg1));
    
    if(rationalp(arg1)){
    	itoa(GET_CAR(arg1),str1,d);
        itoa(GET_CDR(arg1),str3,d);
        str2[0] = '/'; str2[1] = NUL;
        strcat(str1,str2);
        strcat(str1,str3);
    }
    
    if(complexp(arg1)){
    	sprintf(str1,"%f",GET_FLT(arg1));
        sprintf(str3,"%f",GET_IMAG_FLT(arg1));
        str4[0] = 'i'; str4[1] = NUL;
    	if(GET_IMAG_FLT(arg1) < 0){
        	strcat(str1,str3);
        	strcat(str1,str4);
        }
        else{
        	str2[0] = '+'; str2[1] = NUL;
            strcat(str1,str2);
            strcat(str1,str3);
            strcat(str1,str4);
        }
    }   	
    return(make_str(str1));
}

int f_string_to_number(int n){
	int arg1,arg2,d;
    char *e;
    
    if(n == 2){
    	arg2 = pop_s();
    	arg1 = pop_s();
    }
    else{
    	arg2 = NIL;
        arg1 = pop_s();
    }
    if(!stringp(arg1))
    	exception("string->number", NOT_STRING, arg1);
    if(!nullp(arg2) && !integerp(arg2))
    	exception("string->number", NOT_INTEGER, arg2);
	if(nullp(arg2))
    	d = 10;
    else
    	d = get_int(arg2);
    
    strcpy(stok.buf,GET_NAME(arg1));
    
	if(strcmp(stok.buf,"") == 0)
    	return(BOOLF);
        
    if(bignumtoken(stok.buf)){
    	if(d == 10)
			return(make_big(stok.buf));
    	else
        	return(BOOLF);
    }
    
    if(inttoken(stok.buf))
    	return(make_int(strtol(stok.buf,&e,d)));
    
    if(flttoken(stok.buf)){
    	if(d == 10)
    		return(make_flt(atof(stok.buf)));
    	else
        	return(BOOLF);
    }
    
    if(rattoken(stok.buf))
    	return(make_rat(strtol(stok.before,&e,d), strtol(stok.after,&e,d)));
            
    if(comptoken(stok.buf)){
    	if(d == 10)
			return(make_comp(atof(stok.before), atof(stok.after)));
        else
        	return(BOOLF);
	}
    
    return(BOOLF);
}

int f_string_to_symbol(int n){
	int arg,res;
    
    arg = pop_s();
    if(!stringp(arg))
    	exception("string->symbol", NOT_STRING, arg);
    
    res = make_sym(GET_NAME(arg));
    return(res);
}

int f_symbol_to_string(int n){
	int arg,res;
    
    arg = pop_s();
    if(!symbolp(arg))
    	exception("symbol->string", NOT_SYMBOL, arg);
    
    res = make_str(GET_NAME(arg));
    return(res);
}

int f_string_length(int n){
	int arg;
    
    arg = pop_s();
    if(!stringp(arg))
    	exception("string-length", NOT_STRING, arg);
    
    return(make_int(strlen(GET_NAME(arg))));
}

int f_make_string(int n){
	int arg1,arg2,i,j;
    char c;
    char str[SYMSIZE];
    
    if(n != 1 && n !=2)
    	exception("make-string", INCORRECT_ARG_CNT, NIL);
    if(n == 2){
    	arg2 = pop_s();
    	arg1 = pop_s();
    }
    else{
    	arg2 = NIL;
        arg1 = pop_s();
    }
    
    if(!integerp(arg1))
    	exception("make-string", NOT_INTEGER, arg1);
    if(!charp(arg2) && !nullp(arg2))
    	exception("make-string", NOT_CHAR, arg2);
 	
    i = get_int(arg1);
    
    if(nullp(arg2))
    	c = SPACE;
    else
    	c = GET_CHAR(arg2);
    
    str[0] = NUL;
    for(j=0; j<i; j++)
    	str[j] = c;
    str[i] = NUL;
    return(make_str(str));	
}

int f_string(int n){
	int arg;
    char str[SYMSIZE];
    
    str[n] = NUL;
    while(n != 0){
    	arg = pop_s();
        n--;
        if(!charp(arg))
        	exception("string", NOT_CHAR, arg);
        str[n] = GET_CHAR(arg);
    }
    return(make_str(str));
}

int	f_string_ref(int n){
	int arg1,arg2,i,res;
    char c;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string-ref", NOT_STRING, arg1);
    if(!integerp(arg2))
    	exception("string-ref", NOT_INTEGER, arg2);
    
    i = get_int(arg2);
    res = make_char(" ");
    c = STRING_REF(arg1,i);
    SET_CHAR(res,c);
    return(res);
}

int f_string_set(int n){
	int arg1,arg2,arg3,i;
    char c;
    
    arg3 = pop_s();
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string-set", NOT_STRING, arg1);
    if(!integerp(arg2))
    	exception("string-set", NOT_INTEGER, arg2);
    if(!charp(arg3))
    	exception("string-set", NOT_CHAR, arg2);
    
    i = get_int(arg2);
    c = GET_CHAR(arg3);
    STRING_SET(arg1,i,c);
    return(undef);
}

int f_substring(int n){
	int arg1,arg2,arg3,i,j,start,end,res;
    
    arg3 = pop_s();
    arg2 = pop_s();
    arg1 = pop_s();
	if(!stringp(arg1))
    	exception("substring", NOT_STRING, arg1);
    if(!integerp(arg2))
    	exception("substring", NOT_INTEGER, arg2);
    if(!integerp(arg3))
    	exception("substring", NOT_INTEGER, arg3);
    start = get_int(arg2);
    end   = get_int(arg3);
    if(end > strlen(GET_NAME(arg1)))
    	exception("substring",ILLEGAL_ARGUMENT, arg3);
    if(start < 0)
    	exception("substring",ILLEGAL_ARGUMENT, arg1);
    if(start > end)
    	exception("substring",ILLEGAL_ARGUMENT, arg2);
    i = 0;
    res = make_str("");
    for(j = start; j < end; j++){
    	STRING_SET(res,i,STRING_REF(arg1,j));
        i++;
    }
    STRING_SET(res,i,NUL);
    return(res);
}

int f_string_to_list(int n){
	int arg,i,chr,res;
    char c;
    
    arg = pop_s();
    if(!stringp(arg))
    	exception("string->list", NOT_STRING, arg);
    
    res = NIL;
    i = strlen(GET_NAME(arg)) - 1;
    while(i >= 0){
		c = STRING_REF(arg,i);
    	chr = make_char(" ");
        SET_CHAR(chr,c);
        res = cons(chr,res);
        i--;    
    }
    return(res);	
}

int f_list_to_string(int n){
	int arg,i,chr,res;
    char c;
    
	arg = pop_s();
    res = make_str("");
    i = 0;
    while(!nullp(arg)){
    	chr = car(arg);
        if(!charp(chr))
        	exception("list->string", NOT_CHAR, chr);
        c = GET_CHAR(chr);
        STRING_SET(res,i,c);
        i++;
        arg = cdr(arg);
    }
	STRING_SET(res,i,NUL);
    return(res);    
}

int f_string_copy(int n){
	int arg,res;
    
    arg = pop_s();
    if(!stringp(arg))
    	exception("string-copy", NOT_STRING, arg);
    res = make_str(GET_NAME(arg));
    return(res);
}

int f_string_fill(int n){
	int arg1,arg2,i;
    char c;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("string-fill", NOT_STRING, arg1);
    if(!charp(arg2))
    	exception("string-fill", NOT_CHAR, arg2);
    c = GET_CHAR(arg2);
    i = strlen(GET_NAME(arg1)) - 1;
    while(i >= 0){
    	STRING_SET(arg1,i,c);
        i--;
    }
    return(undef);
}
//---------æ•°å€¤è¨ˆç®—--------------------
int f_plus(int n){
	int arg,res,i=0;
    
    if(n == 2 && integerp(stack[sp-1]) && integerp(stack[sp-2])){
    	arg = pop_s();
        res = pop_s();

    	i = GET_INT(arg) + GET_INT(res);
        if(SMALL_INT_MIN < i && i < SMALL_INT_MAX)
        	return(make_int(i));
        else
        	return(big_plus(inttobignum(arg),inttobignum(res)));
    }
    
    if(n == 0)
    	return(make_int(0));
    res = pop_s();
    n--;
    if(!numberp(res))
    	exception("+", NOT_NUMBER, res);
    
    while(n > 0){
    	arg = pop_s();
        n--;
        if(!numberp(arg))
    		exception("+", NOT_NUMBER, arg);
        
        res = plus(arg,res);
    }
	return(res);   
}

int f_minus(int n){
	int arg,res;
    
    if(n == 2 && integerp(stack[sp-1]) && integerp(stack[sp-2])){
    	arg = pop_s();
        res = pop_s();
        return(minus(res,arg));
    }
    
    res = pop_s();
    n--;
    if(!numberp(res))
    	exception("-", NOT_NUMBER, res);
        
    if(n == 0)
    	return(mult(res,make_int(-1)));
    while(n > 1){
    	arg = pop_s();
        n--;
        if(!numberp(arg))
    		exception("-", NOT_NUMBER, arg);
        res = plus(arg,res);
    }
    arg = pop_s();
    if(!numberp(arg))
    	exception("-", NOT_NUMBER, arg);
    res = minus(arg,res);
	return(res);   
}

int f_mult(int n){
	int arg,res;
    
	if(n == 0)
    	return(make_int(1));
    
    res = pop_s();
    n--;
    
    if(!numberp(res))
    	exception("*", NOT_NUMBER, res);
        
    while(n > 0){
    	arg = pop_s();
        n--;
        if(!numberp(arg))
    		exception("*", NOT_NUMBER, arg);
        res = mult(arg,res);
    }
	return(res);   
}

int f_div(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    n--;
    if(!numberp(arg2))
    	exception("/", NOT_NUMBER, arg2);

	if(n == 0){
		if(zerop(arg2))
        	exception("/", DIVIDE_ZERO, arg2);
        else
    		return(divide(make_int(1),arg2));
    }    
    while(n > 1){
    	arg1 = pop_s();
        n--;
        	
        if(!numberp(arg1))
    		exception("/", NOT_NUMBER, arg1);
        if(zerop(arg1))
        	exception("/", DIVIDE_ZERO, arg1);
        
        arg2 = mult(arg1,arg2);
    }
    arg1 = pop_s();
	return(divide(arg1,arg2));   
}

int f_smallerp(int n){
	int arg1,arg2;
    
    if(n == 2 && integerp(stack[sp-1]) && integerp(stack[sp-1])){
    	arg2 = pop_s();
        arg1 = pop_s();
        if(arg1 < arg2)
        	return(BOOLT);
        else
        	return(BOOLF);	
    }
    arg2 = pop_s();
    n--;
    if(!numberp(arg2))
    	exception("<", NOT_NUMBER, arg2);

    while(n > 0){
    	arg1 = pop_s();
        n--;
        if(!numberp(arg1))
        	exception("<", NOT_NUMBER, arg1);
    	if(!smallerp(arg1,arg2))
    		return(BOOLF);
        arg2 = arg1;
    	}
    return(BOOLT);
}


int f_eqsmallerp(int n){
	int arg1,arg2;
    
    if(n == 2 && integerp(stack[sp-1]) && integerp(stack[sp-1])){
    	arg2 = pop_s();
        arg1 = pop_s();
        if(arg1 <= arg2)
        	return(BOOLT);
        else
        	return(BOOLF);	
    }
    arg2 = pop_s();
	n--;
    if(!numberp(arg2))
    	exception("<=", NOT_NUMBER, arg2);
    
    while(n > 0){
    	arg1 = pop_s();
        n--;
        if(!numberp(arg1))
        	exception("<=", NOT_NUMBER, arg1);
    	if(!eqsmallerp(arg1,arg2))
    		return(BOOLF);
        arg2 = arg1;
    	}
    return(BOOLT);
}

int f_greaterp(int n){
	int arg1,arg2;
    
    if(n == 2 && integerp(stack[sp-1]) && integerp(stack[sp-1])){
    	arg2 = pop_s();
        arg1 = pop_s();
        if(arg1 > arg2)
        	return(BOOLT);
        else
        	return(BOOLF);	
    }
    arg2 = pop_s();
	n--;
    if(!numberp(arg2))
    	exception(">", NOT_NUMBER, arg2);
    
    while(n > 0){
    	arg1 = pop_s();
        n--;
        if(!numberp(arg1))
        	exception(">", NOT_NUMBER, arg1);
    	if(!greaterp(arg1,arg2))
    		return(BOOLF);
        arg2 = arg1;
    	}
    return(BOOLT);
}

int f_eqgreaterp(int n){
	int arg1,arg2;
    
    if(n == 2 && integerp(stack[sp-1]) && integerp(stack[sp-1])){
    	arg2 = pop_s();
        arg1 = pop_s();
        if(arg1 >= arg2)
        	return(BOOLT);
        else
        	return(BOOLF);	
    }
    arg2 = pop_s();
    n--;
    if(!numberp(arg2))
    	exception(">=", NOT_NUMBER, arg2);
    
    while(n > 0){
    	arg1 = pop_s();
        n--;
        if(!numberp(arg1))
        	exception(">=", NOT_NUMBER, arg1);
    	if(!eqgreaterp(arg1,arg2))
    		return(BOOLF);
        arg2 = arg1;
    	}
    return(BOOLT);
}

int f_numeqp(int n){
	int arg1,arg2;
    
    if(n == 2 && integerp(stack[sp-1]) && integerp(stack[sp-1])){
    	arg2 = pop_s();
        arg1 = pop_s();
        if(arg1 == arg2)
        	return(BOOLT);
        else
        	return(BOOLF);	
    }
    arg2 = pop_s();
    n--;
    if(!(numberp(arg2)))
    	exception("=", NOT_NUMBER, arg2);
    
    while(n > 0){
    	arg1 = pop_s();
        n--;
        if(!numberp(arg1))
        	exception("=", NOT_NUMBER, arg1);
        if(!(numeqp(arg1,arg2)))
        	return(BOOLF);
        
        arg2 = arg1;
    }
    return(BOOLT);
}

int f_oddp(int n){
	int arg,x;
    
    arg = pop_s();
    if(!numberp(arg))
    	exception("odd?", NOT_NUMBER, arg);
    
    if(integerp(arg)){
    	x = abs(GET_INT(arg));
        if(x % 2 == 1)
        	return(BOOLT);
        else	
        	return(BOOLF);
    }
    if(bignump(arg)){
    	arg = car(arg);
    	x = GET_INT(arg);
        if(x % 2 == 1)
        	return(BOOLT);
        else
        	return(BOOLF);
    }
    else
    	return(BOOLF);
}

int f_evenp(int n){
	int arg,x;
    
    arg = pop_s();
    if(!numberp(arg))
    	exception("even?", NOT_NUMBER, arg);
    
    if(integerp(arg)){
    	x = abs(GET_INT(arg));
        if(x % 2 == 0)
        	return(BOOLT);
        else	
        	return(BOOLF);
    }
    if(bignump(arg)){
    	arg = car(arg);
    	x = GET_INT(arg);
        if(x % 2 == 0)
        	return(BOOLT);
        else
        	return(BOOLF);
    }
    else
    	return(BOOLF);
}

int f_positivep(int n){
	int arg;
    
    arg = pop_s();
    if(!realp(arg))
    	exception("positive?", NOT_REAL, arg);
    
    if(positivep(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_negativep(int n){
	int arg;
    
    arg = pop_s();
    if(complexp(arg))
    	exception("negative?", NOT_REAL, arg);
    
   	if(negativep(arg))
   		return(BOOLT);
    else
    	return(BOOLF);
}

int f_abs(int n){
	int arg;
    
    arg = pop_s();
    return(s_abs(arg));
}

int f_max(int n){
	int arg1,arg2;
    
    if(n == 0)
    	return(NIL);
    if(n == 1)
    	return(pop_s());
    
    arg2 = pop_s();
    n--;
    while(n > 0){
    	arg1 = pop_s();
        n--;
        if(greaterp(arg1,arg2))
        	arg2 = arg1;
    }
    return(arg2);  
}

int f_min(int n){
	int arg1,arg2;
    
    if(n == 0)
    	return(NIL);
    if(n == 1)
    	return(pop_s());
    
    arg2 = pop_s();
    n--;
    while(n > 0){
    	arg1 = pop_s();
        n--;
        if(smallerp(arg1,arg2))
        	arg2 = arg1;
    }
    return(arg2);  
}

int	f_remainder(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    
    if(!mathematical_integerp(arg1))
        exception("remainder",NOT_INTEGER,arg1);

    if(!mathematical_integerp(arg2))
        exception("remainder",NOT_INTEGER,arg2);
    
    if(exactp(arg1) && exactp(arg2))
    	return(s_remainder(arg1,arg2));
    else{
    	arg1 = inexact_to_exact(arg1);
    	arg2 = inexact_to_exact(arg2);
    	return(exact_to_inexact(s_remainder(arg1,arg2)));
	}
}

int f_modulo(int n){
	int arg1,arg2,res;
    
    arg2 = pop_s();
    arg1 = pop_s();
    
    if(!mathematical_integerp(arg1))
        exception("modulo",NOT_INTEGER,arg1);

    if(!mathematical_integerp(arg2))
        exception("modulo",NOT_INTEGER,arg2);
    
    
    if(exactp(arg1) && exactp(arg2)){
    	arg1 = inexact_to_exact(arg1);
   		arg2 = inexact_to_exact(arg2);
    }
    
    if(positivep(arg1) && positivep(arg2))
		res = s_remainder(arg1,arg2);	
    else if(positivep(arg1) && negativep(arg2))
        res = plus(s_remainder(arg1,s_abs(arg2)),arg2);
    else if(negativep(arg1) && positivep(arg2))
    	res = minus(arg2,s_remainder(s_abs(arg1),arg2));
    else
    	res = mult(s_remainder(s_abs(arg1),s_abs(arg2)),make_int(-1));
        
    if(exactp(arg1) && exactp(arg2))
    	return(res);
    else
    	return(exact_to_inexact(res));
}

int	f_quotient(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(zerop(arg2))
    	exception("quotient", DIVIDE_ZERO, NIL);
    
	if(exactp(arg1) && exactp(arg2))
    	return(quotient(arg1,arg2));
    else{
    	arg1 = inexact_to_exact(arg1);
        arg2 = inexact_to_exact(arg2);
        return(exact_to_inexact(quotient(arg1,arg2)));
    }
}

int f_gcd(int n){
	int arg1,arg2;
    
	if(n == 0)
    	return(make_int(0));
    
    arg2 = pop_s();
    if(!mathematical_integerp(arg2))
        exception("gcd",NOT_INTEGER,arg2);
    if(n == 1)
    	return(arg2);
	
    arg1 = pop_s();
    if(!mathematical_integerp(arg1))
        exception("gcd",NOT_INTEGER,arg1);
    
    if(exactp(arg1) && exactp(arg2))
    	return(gcd(arg1,arg2));
    else{
        arg1 = inexact_to_exact(arg1);
    	arg2 = inexact_to_exact(arg2);
    	return(exact_to_inexact(gcd(arg1,arg2)));
	}
}

int f_lcm(int n){
	int arg1,arg2;
    
    if(n == 0)
    	return(make_int(1));
        
    arg2 = pop_s();
    if(!mathematical_integerp(arg2))
        exception("lcm",NOT_INTEGER,arg2);
    if(n == 1)
    	return(arg2);
	
    arg1 = pop_s();
    if(!mathematical_integerp(arg1))
        exception("lcm",NOT_INTEGER,arg1);
    
    if(exactp(arg1) && exactp(arg2))
    	return(lcm(arg1,arg2));
    else{
    	arg1 = inexact_to_exact(arg1);
    	arg2 = inexact_to_exact(arg2);
    	return(exact_to_inexact(lcm(arg1,arg2)));
    }
}

int f_floor(int n){
	int arg,arg1;
    
    arg = pop_s();
    if(complexp(arg) || !numberp(arg))
    	exception("floor", NOT_REAL, arg);
        
    if(integerp(arg))
    	return(arg);
    if(bignump(arg))
    	return(arg);
    arg1 = exact_to_inexact(arg);
    if(rationalp(arg))
    	return(make_int((int)floor(GET_FLT(arg1))));
    if(floatp(arg))
    	return(make_flt(floor(GET_FLT(arg1))));
    return(undef);
}

int f_ceiling(int n){
	int arg,arg1;
    
    arg = pop_s();
    if(complexp(arg) || !numberp(arg))
    	exception("ceiling", NOT_REAL, arg);
        
    if(integerp(arg))
    	return(arg);
    if(bignump(arg))
    	return(arg);
    arg1 = exact_to_inexact(arg);
    if(rationalp(arg))
    	return(make_int((int)ceil(GET_FLT(arg1))));
    if(floatp(arg))
    	return(make_flt(ceil(GET_FLT(arg1))));
    return(undef);
}

int f_truncate(int n){
	int arg,arg1;
    double x;
    
    arg = pop_s();
    if(complexp(arg) || !numberp(arg))
    	exception("truncate", NOT_REAL, arg);
    
    if(integerp(arg))
    	return(arg);
    if(bignump(arg))
    	return(arg);
    arg1 = exact_to_inexact(arg);
    x = GET_FLT(arg1);
    if(rationalp(arg)){
    	if(x >= 0)
    		return(make_int((int)floor(x)));
    	else
    		return(make_int((int)ceil(x)));
    }
    if(floatp(arg)){
    	if(x >= 0)
    		return(make_flt(floor(x)));
    	else
    		return(make_flt(ceil(x)));
    }
    return(undef);
}


int f_round(int lvar){
	int arg,arg1;
    
    arg = pop_s();
    if(complexp(arg) || !numberp(arg))
    	exception("round", NOT_REAL, arg);
    
    if(integerp(arg))
    	return(arg);
    if(bignump(arg))
    	return(arg);
    arg1 = exact_to_inexact(arg);
	if(rationalp(arg))
    	return(make_int((int)round(GET_FLT(arg1))));
    if(floatp(arg))
    	return(make_flt(round(GET_FLT(arg1))));
    return(undef);
}

int f_numerator(int n){
	int arg;
    
    arg = pop_s();
    if(!realp(arg))
    	exception("numerator", NOT_REAL, arg);
    
    if(floatp(arg)){
    	arg = flttorat(arg);
    	return(make_flt((double)GET_CAR(arg)));
    }
    return(make_int(GET_CAR(arg)));
}

int f_denominator(int n){
	int arg;
    
    arg = pop_s();
    if(!realp(arg))
    	exception("denominator", NOT_REAL, arg);
    if(integerp(arg))
    	return(make_int(1));
    
    if(floatp(arg)){
    	arg = flttorat(arg);
		return(make_flt((double)GET_CDR(arg)));
    }
    return(make_int(GET_CDR(arg)));
}

int f_sin(int n){
	int arg;
    double x,x1,y,y1;
	double complex z,z1;
    
    arg = pop_s();
    
	if(!numberp(arg))
    	exception("sin", NOT_NUMBER, arg);
    
    if(realp(arg))
    	return(make_flt(sin(GET_FLT(exact_to_inexact(arg)))));
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
        z = x+y*I;
        z1 = csin(z);
        x1 = creal(z1);
        y1 = cimag(z1);
        return(make_comp(x1,y1));
    }
    return(undef);
}

int f_asin(int n){
	int arg;
    double x,x1,y,y1;
	double complex z,z1;
    
    arg = pop_s();
    
    if(!numberp(arg))
    	exception("asin", NOT_NUMBER, arg);
    
    if(realp(arg))
    	return(make_flt(asin(GET_FLT(exact_to_inexact(arg)))));
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
        z = x+y*I;
        z1 = casin(z);
        x1 = creal(z1);
        y1 = cimag(z1);
        return(make_comp(x1,y1));
    }
    return(undef);
}


int f_cos(int n){
	int arg;
    double x,x1,y,y1;
	double complex z,z1;
    
    arg = pop_s();
    
    if(!numberp(arg))
    	exception("cos", NOT_NUMBER, arg);
    
    if(realp(arg))
    	return(make_flt(cos(GET_FLT(exact_to_inexact(arg)))));
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
        z = x+y*I;
        z1 = ccos(z);
        x1 = creal(z1);
        y1 = cimag(z1);
        return(make_comp(x1,y1));
    }
    return(undef);
}

int f_acos(int n){
	int arg;
    double x,x1,y,y1;
	double complex z,z1;
    
    arg = pop_s();
    if(!numberp(arg))
    	exception("acos", NOT_NUMBER, arg);
    
    if(realp(arg))
    	return(make_flt(acos(GET_FLT(exact_to_inexact(arg)))));
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
        z = x+y*I;
        z1 = cacos(z);
        x1 = creal(z1);
        y1 = cimag(z1);
        return(make_comp(x1,y1));
    }
    return(undef);
}

int	f_tan(int n){
	int arg;
    double x,x1,y,y1;
	double complex z,z1;
    
    arg = pop_s();
    if(!numberp(arg))
    	exception("tan", NOT_NUMBER, arg);
    
    if(realp(arg))
    	return(make_flt(tan(GET_FLT(exact_to_inexact(arg)))));
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
        z = x+y*I;
        z1 = ctan(z);
        x1 = creal(z1);
        y1 = cimag(z1);
        return(make_comp(x1,y1));
    }
    return(undef);
}

double argz(double x, double y){
	double pi = 3.141592653589793;
    
	if(x == 0 && y == 0)
    	return(0);
	if(x > 0)
    	return(atan(y/x));
    if(x == 0 && y > 0)
    	return(pi/2);
    if(x == 0 && y < 0)
    	return(-pi/2);
    if(x < 0)
    	return(atan(y/x)+pi);
    return(0);
}

int f_atan(int n){
	int arg1,arg2;
    double x,x1,y,y1;
	double complex z,z1;
    
    if(n == 1){
		arg1 = pop_s();
        if(!numberp(arg1))
    		exception("atan", NOT_NUMBER, arg1);
    	
        if(realp(arg1))
    		return(make_flt(atan(GET_FLT(exact_to_inexact(arg1)))));
    	if(complexp(arg1)){
    		x = GET_REAL_FLT(arg1);
        	y = GET_IMAG_FLT(arg1);
        	z = x+y*I;
        	z1 = catan(z);
        	x1 = creal(z1);
        	y1 = cimag(z1);
        	return(make_comp(x1,y1));
    	}
    }
    else{
    	arg2 = pop_s();
        arg1 = pop_s();
    	y = GET_FLT(exact_to_inexact(arg1));
        x = GET_FLT(exact_to_inexact(arg2));
        return(make_flt(argz(x,y)));
    }
    return(undef);   
}


int f_log(int n){
	int arg;
    double x,x1,y,y1;
	double complex z,z1;
    
    arg = pop_s();
    if(!numberp(arg))
    	exception("log", NOT_NUMBER, arg);
    
    if(realp(arg) && GET_FLT(exact_to_inexact(arg)) > 0)
    	return(make_flt(log(GET_FLT(exact_to_inexact(arg)))));
    else{
		if(realp(arg))
        	arg = realtocomp(arg);
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
        z = x+y*I;
        z1 = clog(z);
        x1 = creal(z1);
        y1 = cimag(z1);
        return(make_comp(x1,y1));
    }
    return(undef);
}


int f_exp(int n){
	int arg;
    double x,x1,y,y1;
	double complex z,z1;
    
    arg = pop_s();
    if(!numberp(arg))
    	exception("exp", NOT_NUMBER, arg);
    
    if(realp(arg))
    	return(make_flt(exp(GET_FLT(exact_to_inexact(arg)))));
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
        z = x+y*I;
        z1 = cexp(z);
        x1 = creal(z1);
        y1 = cimag(z1);
        return(make_comp(x1,y1));
    }
    return(undef);
}	

int f_sqrt(int n){
	int arg;
    double x,x1,y,y1;
	double complex z,z1;
    
    arg = pop_s();
    
    if(!numberp(arg))
    	exception("sqrt", NOT_NUMBER, arg);
    
    if(realp(arg))
    	return(make_flt(sqrt(GET_FLT(exact_to_inexact(arg)))));
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
        z = x+y*I;
        z1 = csqrt(z);
        x1 = creal(z1);
        y1 = cimag(z1);
        return(make_comp(x1,y1));
    }
    return(undef);
}

int f_expt(int n){
	int arg1,arg2;
    double x,x1,x2,y,y1,y2;
	double complex z,z1,z2;
	
    
    arg2 = pop_s();
    arg1 = pop_s();
    
    if(!numberp(arg1))
    	exception("expt", NOT_NUMBER, arg1);
    
	if(numberp(arg2) && bignump(arg2))
    	exception("expt", TOO_BIG, arg2);
    
	if((integerp(arg1) || bignump(arg1)) && integerp(arg2) && get_int(arg2) == 0)
    	return(make_int(1));
    
    if((integerp(arg1) || bignump(arg1)) && integerp(arg2) && get_int(arg2) > 0)
    	return(expt(arg1,get_int(arg2)));
    
    if((integerp(arg1) || floatp(arg1) || rationalp(arg1)) &&
       (integerp(arg2) || floatp(arg2) || rationalp(arg2))){
       
    	arg1 = exact_to_inexact(arg1);
        arg2 = exact_to_inexact(arg2);
        x = GET_FLT(arg1);
        y = GET_FLT(arg2);
        z = pow(x,y);
        return(make_flt(z));
    }
    
    if(realp(arg1))
    	arg1 = realtocomp(arg1);
    x = GET_REAL_FLT(arg1);
    y = GET_IMAG_FLT(arg1);
	z = x+y*I;
    if(realp(arg2))
    	arg2 = realtocomp(arg2);
    x1 = GET_REAL_FLT(arg2);
    y1 = GET_IMAG_FLT(arg2);
    z1 = x1+y1*I;
    z2 = cpow(z,z1);
    x2 = creal(z2);
    y2 = cimag(z2);
    return(make_comp(x2,y2));
}

int square(int x){
	return(mult(x,x));
}

//xã«ã¯ã‚»ãƒ«ã¨ã—ã¦ã®æ•´æ•°ã€ï½™ã¯ï½ƒè¨€èªã®éè² æ•´æ•°ã€‚
int expt(int x, int y){
	if(y == 1)
    	return(x);
    else
    if((y % 2) == 0)
    	return(square(expt(x,y/2)));
    else
    	return(mult(x,expt(x,y-1)));
}

int f_zerop(int n){
	int arg;
    
    arg = pop_s();
    
    if(!numberp(arg))
    	exception("zero?", NOT_NUMBER, arg);
        
    if(zerop(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}


int f_realpart(int n){
	int arg;
    double x;
    
    arg = pop_s();
    
    if(!numberp(arg))
    	exception("real-part", NOT_NUMBER, arg);

    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        return(make_flt(x));
    }
    if(realp(arg))
    	return(arg);
    
    return(undef);    	
}

int f_imagpart(int n){
	int arg;
    double x;
    
    arg = pop_s();
    
    if(!numberp(arg))
    	exception("imag-part", NOT_NUMBER, arg);
    
    if(realp(arg))
    	return(make_int(0));
    else{
    	x = GET_IMAG_FLT(arg);
    	return(make_flt(x));
    }
}

int f_magnitude(int n){
	int arg;
    double x,y;
    
    arg = pop_s();
    
    if(!numberp(arg))
    	exception("magnitude", NOT_REAL, arg);
    
    if(realp(arg))
    	return(s_abs(arg));
   
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
    	y = GET_IMAG_FLT(arg);
    	return(make_flt(sqrt(x*x + y*y)));
    }
    return(undef);
}

int f_angle(int n){
	int arg;
    double x,y;
    
    arg = pop_s();
    
    if(!numberp(arg))
    	exception("angle", NOT_NUMBER, NIL);
    if(complexp(arg)){
    	x = GET_REAL_FLT(arg);
        y = GET_IMAG_FLT(arg);
    	return(make_flt(argz(x,y)));
    }
    else
    	return(make_int(0));
}

int f_make_rectangular(int n){
	int arg1,arg2;
    double x,y;
    
	arg2 = pop_s();
    arg1 = pop_s();
    if(!realp(arg1))
    	exception("make-rectangular", NOT_REAL, arg1);
    if(!realp(arg2))
    	exception("make-rectangular", NOT_REAL, arg2);
    
    arg1 = exact_to_inexact(arg1);
    arg2 = exact_to_inexact(arg2);
    x = GET_FLT(arg1);
    y = GET_FLT(arg2);
    return(make_comp(x,y));
}

int f_make_polar(int n){
	int arg1,arg2;
    double r,s,x,y;
    
	arg2 = pop_s();
    arg1 = pop_s();
    if(!realp(arg1))
    	exception("make-polar", NOT_REAL, arg1);
    if(!realp(arg2))
    	exception("make-polar", NOT_REAL, arg2);
    
    arg1 = exact_to_inexact(arg1);
    arg2 = exact_to_inexact(arg2);
    r = GET_FLT(arg1);
    s = GET_FLT(arg2);
    x = r * cos(s);
    y = r * sin(s);
    return(make_comp(x,y));
}


int	f_exact_inexact(int n){
	int arg;
    
    arg = pop_s();
    if(!numberp(arg))
    	exception("exact->inexact", NOT_NUMBER, arg);
    
    return(exact_to_inexact(arg));
}

int	f_inexact_exact(int n){
	int arg;
    
    arg = pop_s();
    if(!numberp(arg))
    	exception("inexact->exact", NOT_NUMBER, arg);

	return(inexact_to_exact(arg));
}

//-------çœŸå½å€¤-----------------

int f_not(int n){
	int arg;

    arg = pop_s();

    if(arg == BOOLF)
    	return(BOOLT);
    else
    	return(BOOLF);
}

//-------å…¥åŠ›-----------------------
int f_read(int n){
	int arg,res;
    
    
    if(n == 1){
    	arg = pop_s();
    	input_port = GET_PORT(arg);
    }
	res = read();
    input_port = stdin;
    return(res);
}

int f_read_char(int n){
	int arg,res;
    char c;
    
    
    if(n == 1){
    	arg = pop_s();
    	input_port = GET_PORT(arg);
    }
    c = getc(input_port);
    input_port = stdin;
    if(c == EOF)
    	return(end_of_file);
    else{
    	res = make_char(" ");
        SET_CHAR(res,c);
        return(res);
    }
}

int f_peek_char(int n){
	int arg,res;
    char c;
    
    if(n == 0){
    	arg = pop_s();
    	input_port = GET_PORT(arg);
    }
    c = getc(input_port);
    ungetc(c,input_port);
    input_port = stdin;
    if(c == EOF)
    	return(end_of_file);
    else{
    	res = make_char(" ");
        SET_CHAR(res,c);
        return(res);
    }
}

//å®Ÿè£…å›°é›£ã«ã¤ãå¸¸æ™‚#tã‚’è¿”ã™ã“ã¨ã¨ã™ã‚‹ã€‚
int	f_char_readyp(int n){
	return(BOOLT);
}

int f_load(int n){
	int arg,sexp,l,i;
    
    arg = pop_s();
    input_port = fopen(GET_NAME(arg),"r");
    if(input_port == NULL)
    	exception("load", CANT_OPEN, arg);
    
	s_pc = pc;
    s_sp = sp;
    s_env = env;
    s_n_args = n_args;
    s_head = head;
    s_tail = tail;
    s_code_pointer_end = code_pointer_end;
    for(i=0; i<code_pointer_end; i++){
    	s_code_pointer[i][0] = code_pointer[i][0];
        s_code_pointer[i][1] = code_pointer[i][1];
    }
    for(i=0; i<tail; i++)
    	s_code[i] = code[i];
    
    for(i=0; i<sp; i++)
    	s_stack[i] = stack[i];
    
    loadflag = 1;
    l = strlen(GET_NAME(arg));
    if(STRING_REF(arg,l-2) == '.' && STRING_REF(arg,l-1) == 'o'){
    	while(1){
        	sexp = read();
        	if(sexp == end_of_file)
        		break;
			pc = 0;
            tail = 0;
        	list_to_code(sexp);
        	vm1();
    	} 	
    }
    else{
    	int ret = setjmp(loadloop);   
    	while(1){
			if(ret == 1){
            	contflag = 0;
            }
        	sexp = read();
        	if(sexp == end_of_file)
        		break;
        
        	pc = 0;
        	tail = 0;
        	env = make_env(0,0);
        	eval(quasi_to_procedure(define_to_letrec(sexp)));   
    	}
    }
    fclose(input_port);
    loadflag = 0;
    
    pc = s_pc;
    sp = s_sp;
    env = s_env;
    n_args = s_n_args;
    head = s_head;
    tail = s_tail;
    code_pointer_end = s_code_pointer_end;
    for(i=0; i<s_code_pointer_end; i++){
    	code_pointer[i][0] = s_code_pointer[i][0];
        code_pointer[i][1] = s_code_pointer[i][1];
    }
    for(i=0; i<tail; i++)
    	code[i] = s_code[i];
    
    for(i=0; i<sp; i++)
    	stack[i] = s_stack[i];
    
    if(contflag){
    	longjmp(toplevel,1);	
    }
    return(BOOLT);
}


int	f_open_input_file(int n){
	int arg;
    FILE *port;
    
    arg = pop_s();
    if(!stringp(arg))
    	exception("open-input", NOT_STRING, arg);
        
    port = fopen(GET_NAME(arg),"r");
    if(port == NULL)
    	exception("open-input", CANT_OPEN, arg);
    loadflag = 1;
    return(make_port(port,0));
}

int f_input_portp(int n){
	int arg;
    
    arg = pop_s();
    if(GET_TAG(arg) == PRT && GET_CDR(arg) == 0)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_close_input_port(int n){
	int arg;
    
    arg = pop_s();
    fclose(GET_PORT(arg));
    loadflag = 0;
    return(undef);
}

int f_eof_objectp(int n){
	int arg;
    
    arg = pop_s();
    if(GET_TAG(arg) == EOFO)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_current_input_port(int n){
	
    return(make_port(input_port,0));
}

//-------å‡ºåŠ›---------------
int	f_open_output_file(int n){
	int arg;
    FILE *port;
    
    arg = pop_s();
	if(!stringp(arg))
    	exception("open-output", NOT_STRING, arg);
        
    port = fopen(GET_NAME(arg),"w");
    if(port == NULL)
    	exception("open-output", CANT_OPEN,arg);
    loadflag = 1;
    return(make_port(port,1));
}

int f_close_output_port(int n){
	int arg;
    
    arg = pop_s();
    fclose(GET_PORT(arg));
    loadflag = 0;
    return(undef);
}

int f_output_portp(int n){
	int arg;
    
    arg = pop_s();
    if(GET_TAG(arg) == PRT && GET_CDR(arg) == 1)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_current_output_port(int n){

    return(make_port(output_port, 1));    
}

int f_newline(int n){
	int arg;
    
    if(n == 0)	
		printf("\n");
    else{
    	arg = pop_s();
    	output_port = GET_PORT(arg);
    	fprintf(output_port, "\n");
    }
    return(undef);
}

void display_str(int x){
	char buf[SYMSIZE];
    int pos;
    char c;
    
    strcpy(buf,GET_NAME(x));
    pos = 0;
    c = buf[pos];
    while(c != NUL){
    	switch(c){
        	case '\\':	
            	pos++;
            	c = buf[pos];
                switch(c){
        			case 'n':	fprintf(output_port,"\n"); goto next;
            		case 'r':	fprintf(output_port,"\r"); goto next;
            		case 't':	fprintf(output_port,"\t"); goto next;
                }
        	default:	fprintf(output_port,"%c", c);
        }
        next:
        c = buf[++pos];
    }
}

int output_portp(int x){
	if(GET_TAG(x) == PRT && GET_CDR(x) == 1)
    	return(1);
    else
    	return(0);
}

int f_display(int n){
	int arg1,arg2;
    
    if(n == 1){
    	arg2 = NIL;
        arg1 = pop_s();
    }
    else{	
    	arg2 = pop_s();
    	arg1 = pop_s();
	}
    if(!nullp(arg2) && !output_portp(arg2))
    	exception("display", NOT_PORT,arg2);
    if(!nullp(arg2))
    	output_port = GET_PORT(arg2);
        
    if(stringp(arg1))
    	display_str(arg1);
    else
    if(charp(arg1))
    	fprintf(output_port, "%c", GET_CHAR(arg1));
    else
		print(arg1);
        
    output_port = stdout;
    return(undef);
}

int f_write(int n){
	int arg1,arg2;
    
    if(n == 1){
    	arg2 = NIL;
        arg1 = pop_s();
    }
    else{
    	arg2 = pop_s();
    	arg1 = pop_s();
    }
    if(!nullp(arg2) && !output_portp(arg2))
    	exception("write", NOT_PORT,arg2);
	if(!nullp(arg2))
		output_port = GET_PORT(arg2);
    print(arg1);
    output_port = stdout;
    return(undef);
}

int f_write_char(int n){
	int arg1,arg2;
    char* c;
    
    if(n == 1){
    	arg2 = NIL;
        arg1 = pop_s();
    }
    else{
    	arg2 = pop_s();
    	arg1 = pop_s();
    }
    
    if(!charp(arg1))
    	exception("write-char", NOT_CHAR, arg1);
    if(!nullp(arg2) && !output_portp(arg2))
    	exception("write-char", NOT_PORT,arg2);
    if(!nullp(arg2))
    	output_port = GET_PORT(arg2);
        
    c = GET_NAME(arg1);
    fputs(c, output_port);
	fflush(output_port);
    output_port = stdout;
    return(undef);
}

// --------------åˆ¶å¾¡------------------------
int f_exit(int n){
	longjmp(toplevel,2);
}




//------------------------------
int	f_gensym(int n){
	int arg,res;
    char str1[SYMSIZE],str2[10];
    
    if(n == 0)
    	arg = NIL;
    else
        arg = pop_s();
    
    if(!nullp(arg) && !stringp(arg))
    	exception("gensym", NOT_STRING, arg);
	
    if(nullp(arg))
    	strcpy(str1,"#:G");
    else{
    	strcpy(str1,"#:");
    	strcat(str1,GET_NAME(arg));
    }
    itoa(genint,str2,10);
    genint++;
    strcat(str1,str2);
    res = make_sym(str1);
    return(res);      
}

int f_apply(int n){
	int proc,args,i,code,m,savepc,savesp,res;
    
    args = pop_s();
    if(!listp(args))
    	exception("apply", NOT_LIST, args);
    for(i=n-2; i>0; i--)
    	args = cons(pop_s(),args);
   
	proc = pop_s();
	if(!closurep(proc) && !subrp(proc) &&!continuationp(proc))
    	exception("apply",NOT_PROCEDURE,proc);
        
    savepc = pc;
	savesp = sp;
    //ã‚¹ã‚¿ãƒƒã‚¯ãŒåº•ã‚’ã¤ã„ãŸçŠ¶æ…‹ã§SPã‚’ä¿æŒã€‚
    m = 0;
    while(!nullp(args)){
    	push_s(car(args));
        args = cdr(args);
        m++;
    }
    if(closurep(proc)){
    	push_s(proc);
    	code = cons(make_int(13),
                cons(make_int(m),
                 cons(make_int(33),NIL))); //((call n)(pause))
    }
    else if(subrp(proc)){
    	code = cons(make_int(17),
                cons(make_int(proc),
                 cons(make_int(m),
                  cons(make_int(33),NIL)))); //((call proc n)(pause))
    }
    else{
		//continuation
    	push_s(proc);
    	code = cons(make_int(13),
                cons(make_int(m),
                 cons(make_int(1),NIL))); //((call n)(halt))
    }
    list_to_code(code);
    pc = head;
    if(!debugflag)
    	res = vm1();
    else
    	res = vm2();
    
    if(contflag && continuationp(proc)){
    	print(res);
        printf("\n");
        if(loadflag)
        	longjmp(loadloop,1);
        else
			longjmp(toplevel,1);
    }        
    pc = savepc;
    sp = savesp;
    return(res);
}

int f_primitive_name_p(int n){
	int arg;
    
    arg = pop_s();
    arg = GET_CAR(arg);
    if(subrp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_macroexpand1(int n){
	int arg;
    
    arg = pop_s();
    if(!macro_namep(car(arg)) && !hygienic_namep(car(arg)))
    	exception("macroexpand", NOT_MACRO, arg);
	
    return(macroexpand1(arg));
}

int macroexpand1(int arg){
	int clo,m,code,new_expr,comp_env,vm_env,savepc,savesp,saveenv;
    
	//ä¼çµ±çš„ãƒã‚¯ãƒ­ã®å ´åˆ
    if(macro_namep(car(arg))){
    	savepc = pc;
    	savesp = sp;
        saveenv = env;
    	clo = GET_CAR(GET_CAR(car(arg)));
        arg = cdr(arg);
        
        m = 0;

        while(!nullp(arg)){
        	push_s(car(arg));
            m++;
            arg = cdr(arg);	
        }
        push_s(clo);
        code = list3(make_int(13),make_int(m),make_int(33));
		//((call m)(pause)) 
        list_to_code(code);
        pc = head; 
        new_expr = vm1();
        pc = savepc;
    	sp = savesp;
        env = saveenv;

    }
    
    else if(hygienic_namep(car(arg))){
    	savepc = pc;
    	savesp = sp;
        saveenv = env;
    	clo = GET_CAR(GET_CAR(car(arg)));
        vm_env = GET_CDR(GET_CAR(car(arg)));
		comp_env = GET_AUX(GET_CAR(car(arg)));
       
        push_s(arg);
        push_s(comp_env);
        push_s(vm_env);
        push_s(clo);
        code = list3(make_int(13),make_int(3),make_int(33));
		//((call 3)(pause)) 
        list_to_code(code);
        pc = head;
        new_expr = vm1();
        pc = savepc;
    	sp = savesp;
        env = saveenv;
    }
    else
    	new_expr = arg;
    
    return(new_expr);
}

int f_macroexpand(int n){
	int arg;
    
    arg = pop_s();
	return(macroexpand(arg));
}

int macroexpand(int x){
    
	if(nullp(x))
    	return(NIL);
    else if(atomp(x))
    	return(x);
    else if(vectorp(x))
    	return(x);
    else if(eqp(car(x),quote))
    	return(cadr(x));
    else if(macro_namep(car(x)))
    	return(macroexpand(macroexpand1(x)));
    else if(hygienic_namep(car(x)))
    	return(macroexpand(macroexpand1(x)));
    else if(atomp(car(x)))
    	return(cons(car(x),macroexpand(cdr(x))));
    else
    	return(cons(macroexpand(car(x)),macroexpand(cdr(x))));
}

int	f_addr(int n){
	int arg;
    
    arg = pop_s();
    return(make_int(arg));
}

int f_entity_addr(int n){
	int arg;
    
    arg = pop_s();
    if(car(arg) == undef){
    	exception("", UNBOUND_VARIABLE, arg);
    	return(undef);
    }
    else
    	return(make_int(car(arg)));
}

int f_undefined(int n){
	
    return(undef);
}

int f_step(int n){
	int arg;
    
    arg = pop_s();
    if(!booleanp(arg))
    	exception("step",NOT_BOOL,arg);
    
    if(arg == BOOLT)
    	step_on = 1;
    else
    	step_on = 0;
    
    return(arg);
}

int f_vm2_step(int n){
	int arg,res,i;
    
    arg = pop_s();
    
    s_pc = pc;
    s_sp = sp;
    s_env = env;
    s_n_args = n_args;
    s_head = head;
    s_tail = tail;
    s_code_pointer_end = code_pointer_end;
    for(i=0; i<code_pointer_end; i++){
    	s_code_pointer[i][0] = code_pointer[i][0];
        s_code_pointer[i][1] = code_pointer[i][1];
    }
    for(i=0; i<tail; i++)
    	s_code[i] = code[i];
    
    for(i=0; i<sp; i++)
    	s_stack[i] = stack[i];
    
    
    head = 0;
    tail = 0;
    list_to_code(arg);
    pc = 0;
    sp = 0;
    stepflag = 1;
    res = vm2();
    stepflag = 0;
    
    pc = s_pc;
    sp = s_sp;
    env = s_env;
    n_args = s_n_args;
    head = s_head;
    tail = s_tail;
    code_pointer_end = s_code_pointer_end;
    for(i=0; i<s_code_pointer_end; i++){
    	code_pointer[i][0] = s_code_pointer[i][0];
        code_pointer[i][1] = s_code_pointer[i][1];
    }
    for(i=0; i<tail; i++)
    	code[i] = s_code[i];
    
    for(i=0; i<sp; i++)
    	stack[i] = s_stack[i];
    

    return(res);
}

int f_vm1(int n){
	int arg,res;
    
    arg = pop_s();
    
    head = 0;
    tail = 0;
    list_to_code(arg);
    pc = 0;
    sp = 0;
    stepflag = 0;
    res = vm1();
    return(res);
}



int f_vm2(int n){
	int arg,res,i;
    
    arg = pop_s();
    
    s_pc = pc;
    s_sp = sp;
    s_env = env;
    s_n_args = n_args;
    s_head = head;
    s_tail = tail;
    s_code_pointer_end = code_pointer_end;
    for(i=0; i<code_pointer_end; i++){
    	s_code_pointer[i][0] = code_pointer[i][0];
        s_code_pointer[i][1] = code_pointer[i][1];
    }
    for(i=0; i<tail; i++)
    	s_code[i] = code[i];
    
    for(i=0; i<sp; i++)
    	s_stack[i] = stack[i];
    
    
    head = 0;
    tail = 0;
    list_to_code(arg);
    pc = 0;
    sp = 0;
    stepflag = 0;
    res = vm2();
    
    pc = s_pc;
    sp = s_sp;
    env = s_env;
    n_args = s_n_args;
    head = s_head;
    tail = s_tail;
    code_pointer_end = s_code_pointer_end;
    for(i=0; i<s_code_pointer_end; i++){
    	code_pointer[i][0] = s_code_pointer[i][0];
        code_pointer[i][1] = s_code_pointer[i][1];
    }
    for(i=0; i<tail; i++)
    	code[i] = s_code[i];
    
    for(i=0; i<sp; i++)
    	stack[i] = s_stack[i];

    return(res);
}



int f_dump(int n){
	int arg1,arg2,x,y;
    
    if(n == 2){
    	arg2 = pop_s();
        arg1 = pop_s();
        x = get_int(arg1);
        y = get_int(arg2);
    }
    else {
    	arg1 = pop_s();
        x = get_int(arg1);
        y = x + 10;
    }	
 	memorydump(x,y);
    return(undef);   	
}

int f_addr_prt(int n){
	int arg,x;
    
    arg = pop_s();
    x = get_int(arg);
    print(x);
    printf("\n");
    return(undef);
}

int f_gbc(int n){
	int arg;
    
    if(n == 0){
    	gbc();
        gctime = 0;
    }
    else {
    	arg = pop_s();    
    	if(arg == BOOLT)
    		gbcflag = 1;
    	if(arg == BOOLF)
    		gbcflag = 0;
    }
    
    return(undef);     
}

int f_room(int n){
	printf("cell_free     = %d\n",cell_free);
    printf("cell_heap_p   = %d\n",cell_heap_p);
	printf("dyna_env_p1   = %d\n",dyna_env_p1);
    printf("dyna_env_p2   = %d\n",dyna_env_p2);
    return(undef);
}

int f_vmcode(int n){
	int arg,code,i,res;
    
    arg = pop_s();
	
    if(!closurep(arg) && !macrop(arg))
    	exception("vmcode",NOT_CLOSURE,arg);
    if(closurep(arg))
    	code = GET_CAR(arg);
    else
    	code = GET_CAR(GET_CAR(arg));
        
    i = GET_CDR(code);
    res = NIL;
    while(i > 0){
    	res = cons(make_int(GET_VEC_ELT(code,(i-1))),res);
        i--;
    }
    return(res);
}

int f_env(int n){
	int arg;
    
    arg = pop_s();
    print(GET_CDR(arg));
    return(undef);
}

int f_timer_set(int n){
	
    start_time = clock();
    return(undef);
}

int f_timer_get(int n){
	clock_t end_time;
    double time;
    
    end_time = clock();
    time = (double)(end_time - start_time)/ CLOCKS_PER_SEC;
	time = round(time*1000)/1000;
    return(make_flt(time));
}

int f_timer_gbc(int n){
	double time;
    
    time = (double)gctime/ CLOCKS_PER_SEC;
    time = round(time*1000)/1000;
    return(make_flt(time));
}


int f_eval(int n){
	int arg;
    
    arg = pop_s();
    return(eval(arg));
}

int f_error(int n){
	int arg1,arg2,i;
    
    arg2 = NIL;
    while(n > 1){
    	arg2 = cons(pop_s(),arg2);
        n--;
    }
    arg1 = pop_s();
    if(!stringp(arg1))
    	exception("error", NOT_STRING, arg1);
    
	printf("Exception: ");
    display_str(arg1);
    while(!nullp(arg2)){
    	print(car(arg2));
        printf(" ");
        arg2 = cdr(arg2);
    }
    printf("\n");
	//loadä¸­ãªã‚‰ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¦ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã¸å¾©å¸°ã€‚
    if(loadflag == 1)
    	fclose(input_port);
    //ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã«è¨˜æ†¶ã—ãŸå‘½ä»¤åˆ—ã®é–‹å§‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¶ˆå»ã€‚
    for(i=0; i< code_pointer_end; i++){
    	SET_AUX(code_pointer[i][0] , -1);
    }
    code_pointer_end = 0; 
    longjmp(toplevel,1);
}

int f_flush(int n){
	
    fflush(stdout);
    return(undef);
}


int f_set_trace(int n){
	int i,fn;
    
    if(n == 0)
    	return(trace_list);
    else{
    	for(i=n; i>0; i--){
    		fn = pop_s();
            if(!symbolp(fn))
            	exception("trace",NOT_SYMBOL,fn);
            if(memq(fn,trace_list) == BOOLF){
        		SET_CDR(fn,1);
        		trace_list = cons(fn,trace_list);
            }
    	}
    	return(undef);
    }
}

int f_set_untrace(int n){
	int i,fn,addr;
    
    if(n == 0){
    	while(!nullp(trace_list)){
        	SET_CDR(car(trace_list),0);
            trace_list = cdr(trace_list);
        }
    }
    else{
    	for(i=n; i>0; i--){
        	fn = pop_s();
            SET_CDR(fn,0);
     		addr = trace_list;
            while(!nullp(addr)){
            	if(eqp(fn,car(addr))){
                	SET_CDR(addr,cdr(addr));
                	break;
                }
                addr = cdr(addr);
            }       
    	}
    }
    return(undef);
}



int f_current_module(int n){

	return(module_table[current_module][0]);
}


int f_transfer(int n){
	int arg;
    
    arg = pop_s();
    return(quasi_to_procedure(define_to_letrec(arg))); 
}



int f_debug(int n){
	int arg;
    
    arg = pop_s();
    if(!booleanp(arg))
    	exception("debug", NOT_BOOL, arg);
    
    if(arg == BOOLT)
    	debugflag = 1;
    else{
    	debugflag = 0;
        prof_on = 0;
        step_on = 0;
    }
    return(arg);
}

int f_prof(int n){
	int arg;
    
	arg = pop_s();
    if(!booleanp(arg))
    	exception("profile", NOT_BOOL, arg);
    
    if(arg == BOOLT)
    	prof_on = 1;
    else
    	prof_on = 0;
    
    return(arg);
}

int f_edump(int n){
	int arg,x,i;
    
    arg = pop_s();
    x = get_int(arg);
    
    for(i=x; i<x+10; i++){
    	printf("[");
        print(emem1[i]);
        printf("]");
    }
    return(BOOLT);
}

int f_lambda_asm(int n){
	int m,code,machine,res,savepc,savesp,saveenv;
    
    code = pop_s();
    m = pop_s();
    if(!integerp(m))
    	exception("lambda/asm", NOT_INTEGER, m);
    
    if(!listp(code))
    	exception("lambda/asm", NOT_CLOSURE, code);
    
	savepc = pc;
    savesp = sp;
    saveenv = env;
    
    res = make_clo();
    SET_ARGS_CNT(res,get_int(m));
    machine = cons(make_int(2),
               cons(code,
                cons(make_int(4),
                 cons(make_sym("assemble"),
                  cons(make_int(13),
                   cons(make_int(1),
                    cons(make_int(1),NIL)))))));
    list_to_code(machine);
    pc = head;
    code = vm1();
    SET_CAR(res,list_to_code_obj(code));
    SET_CDR(res,env);
    
    pc = savepc;
    sp = savesp;
    env = saveenv;
    return(res);
}


int f_values(int n){
	int lis,i;
    
    if(n == 0)
    	//ï¼å€‹ã®å ´åˆã«ã¯ç©ºé›†åˆã‚’è¿”ã™ã€‚
    	return(empty_set);
    else if(n == 1)
        //å˜æ•°ã®å ´åˆã«ã¯ãã‚Œãã®ã‚‚ã®ã‚’è¿”ã™ã€‚
    	return(pop_s());
    else{
    	lis = NIL;
    	for(i=0; i<n; i++)
    		lis = cons(pop_s(),lis);
    
    	return(make_multiple_values(lis));
    }
}

int f_sys_cont_room(int n){
	int clo,cont,cont_code,cont_stack,cont_env,saveenv;
    
    clo = pop_s();
    
    saveenv = env;
    env = cdr(clo);
    cont = get_lvar(1,0);
    cont_code = GET_CAR(cont);
    cont_stack = GET_CDR(cont);
    cont_env = car(GET_AUX(cont));
    
    printf("code size  %d\n",GET_VEC_ELT(cont_code,3));
    printf("stack size %d\n", GET_CDR(cont_stack));
    print(cont_env);
    env = saveenv;
    return(undef);
}

int f_make_sc(int lvar){
	int env,fv,expr,res;
    
    expr = pop_s();
    fv = pop_s();
    env = pop_s();
    
    if(IS_SYNCLO(expr))
    	return(expr);
    
    res = freshcell();
    SET_TAG(res,SYNCLO);
    SET_CAR(res,expr);
    SET_CDR(res,env);
    SET_AUX(res,fv);
    return(res);	
}


int f_symbol_to_identifier(int n){
	int arg;
    
    arg = pop_s();
    
    if(!symbolp(arg))
    	exception("symbol->identifier",NOT_SYMBOL,arg);
    
    return(make_ident(GET_NAME(arg)));
}

int f_identifier_to_symbol(int n){
	int arg;
    
    arg = pop_s();
    
    if(!identifierp(arg))
    	exception("identifier->symbol",NOT_IDENTIFIER,arg);
    
    return(make_sym(GET_NAME(arg)));
}

int f_syntactic_closurep(int n){
	int arg;
    
    arg = pop_s();
    if(syntactic_closurep(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_identifierp(int n){
	int arg;
    
    arg = pop_s();
    if(identifierp(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_identifier_bind(int n){
	int arg1,arg2;
    
    arg2 = pop_s();
    arg1 = pop_s();
    if(!identifierp(arg1))
    	exception("identifier-bind!", NOT_IDENTIFIER, arg1);
    
    SET_AUX(arg1,arg2);
    return(arg1);
}

int f_identifier_freep(int n){
	int arg;
    
    arg = pop_s();
    
    if(identifierp(arg) && GET_AUX(arg) == NIL)
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_identifier_boundp(int n){
	int arg;
    
    arg = pop_s();
    
    if(identifierp(arg) && GET_AUX(arg) == NIL)
    	return(BOOLF);
    else
    	return(BOOLT);
}

int f_global_boundp(int n){
	int arg;
    
    arg = pop_s();
    if(!symbolp(arg))
    	exception("global-bound?", NOT_SYMBOL, arg);
    
    if(GET_CAR(arg) == undef)
    	return(BOOLF);
    else
    	return(BOOLT);
}

int f_identifier_bound(int n){
	int arg;
    
    arg = pop_s();
    if(!identifierp(arg))
    	exception("identifier-bound", NOT_IDENTIFIER, arg);
    
    return(GET_AUX(arg));
}

int f_inspect(int n){
	int sexp,i;
    
    while(1){
    	printf("inspect> ");
        fflush(stdout);
        sexp = read();
        
        if(eqvp(sexp,make_sym("q")))
        	return(undef);
    	else if(eqvp(sexp,make_sym("b"))){
        	printf("back trace\n");
    		for(i=0; i<back_trace_end; i++){
				printf("[%d] ", i - back_trace_end);
        		print(cons(back_trace[i][0],back_trace[i][1]));
            	printf("\n");
        	}
        }
        	
    }
}

int f_exact_integerp(int n){
	int arg;
    
    arg = pop_s();
    
    if(IS_INTEGER(arg) || IS_BIGNUM(arg))
    	return(BOOLT);
    else
    	return(BOOLF);
}

int f_file_existsp(int n){
	int arg;
    FILE *port;
    
    arg = pop_s();
    if(!stringp(arg))
    	exception("file-exists?",NOT_STRING, arg);
    
    port = fopen(GET_NAME(arg),"r");
    if(port != NULL){
    	fclose(port);
        return(BOOLT);
    }
    else
    	return(BOOLF);
}

int f_system(int n){
	int arg;
    
    arg = pop_s();
    if(!stringp(arg))
    	exception("system", NOT_STRING, arg);
    
    system(GET_NAME(arg));
    return(undef);
}

//subrã‚’ç’°å¢ƒã«ç™»éŒ²ã™ã‚‹ã€‚
void defsubr(char *name, int func){
	int sym,val;
    
    sym = make_sym(name);
    val = freshcell();
    SET_TAG(val,SUBR);
    SET_SUBR(val,func);
    SET_NAME(val,name);
    SET_CAR(sym,val);
}

//ç‰¹æ®Šå½¢å¼ã‚’ç’°å¢ƒã«ç™»éŒ²ã™ã‚‹ã€‚
void defsyntax(char *name){
	int sym,val;
    
    sym = make_sym(name);
    val = freshcell();
    SET_TAG(val,SYNT);
    SET_NAME(val,name);
    SET_CAR(sym,val);
}

void initsubr(void){
	defsubr("car",(int)f_car);
    defsubr("cdr",(int)f_cdr);
    defsubr("cons",(int)f_cons);
    defsubr("caar",(int)f_caar);
    defsubr("cdar",(int)f_cdar);
    defsubr("cddr",(int)f_cddr);
    defsubr("cadr",(int)f_cadr);
    defsubr("caaar",(int)f_caaar);
    defsubr("cdaar",(int)f_cdaar);
    defsubr("cadar",(int)f_cadar);
    defsubr("caadr",(int)f_caadr);
    defsubr("cddar",(int)f_cddar);
    defsubr("caddr",(int)f_caddr);
    defsubr("cdadr",(int)f_cdadr);
    defsubr("cdddr",(int)f_cdddr);
    defsubr("caaaar",(int)f_caaaar);
    defsubr("cdaaar",(int)f_cdaaar);
    defsubr("cadaar",(int)f_cadaar);
    defsubr("caadar",(int)f_caadar);
    defsubr("caaadr",(int)f_caaadr);
    defsubr("cddaar",(int)f_cddaar);
    defsubr("caddar",(int)f_caddar);
    defsubr("caaddr",(int)f_caaddr);
    defsubr("cdaadr",(int)f_cdaadr);
    defsubr("cdadar",(int)f_cdadar);
    defsubr("cadddr",(int)f_cadddr);
    defsubr("cdaddr",(int)f_cdaddr);
    defsubr("cddadr",(int)f_cddadr);
    defsubr("cdddar",(int)f_cdddar);
    defsubr("cddddr",(int)f_cddddr);
    defsubr("assq",(int)f_assq);
    defsubr("assv",(int)f_assv);
    defsubr("assoc",(int)f_assoc);
    defsubr("memq",(int)f_memq);
    defsubr("memv",(int)f_memv);
    defsubr("member",(int)f_member);
    defsubr("reverse",(int)f_reverse);
    defsubr("reverse!",(int)f_reverse2);
    defsubr("list-tail",(int)f_listtail);
    defsubr("list-ref",(int)f_listref);
    defsubr("append",(int)f_append);
    defsubr("append!",(int)f_append2);
    defsubr("set-car!",(int)f_setcar);
    defsubr("set-cdr!",(int)f_setcdr);
    defsubr("list",(int)f_list);
    defsubr("make-list",(int)f_makelist);
    defsubr("length",(int)f_length);
    defsubr("pair-length",(int)f_pair_length);
    defsubr("last",(int)f_last);
    defsubr("butlast",(int)f_butlast);
    defsubr("newline",(int)f_newline);
    defsubr("display",(int)f_display);
    defsubr("write",(int)f_write);
    defsubr("write-char",(int)f_write_char);
	defsubr("null?",(int)f_nullp);
    defsubr("list?",(int)f_listp);
    defsubr("pair?",(int)f_pairp);
    defsubr("atom?",(int)f_atomp);
    defsubr("eq?",(int)f_eqp);
    defsubr("eqv?",(int)f_eqvp);
    defsubr("equal?",(int)f_equalp);
    defsubr("boolean?",(int)f_boolp);
    defsubr("procedure?",(int)f_procedurep);
    defsubr("number?",(int)f_numberp);
    defsubr("integer?",(int)f_integerp);
    defsubr("real?",(int)f_realp);
    defsubr("rational?",(int)f_rationalp);
    defsubr("complex?",(int)f_complexp);
    defsubr("exact?",(int)f_exactp);
    defsubr("inexact?",(int)f_inexactp);
    defsubr("symbol?",(int)f_symbolp);
    defsubr("string?",(int)f_stringp);
    defsubr("char?",(int)f_characterp);
    defsubr("bignum?",(int)f_bignump);
    defsubr("vector?",(int)f_vectorp);
    defsubr("macro?",(int)f_macrop);
	defsubr("macro-name?",(int)f_macro_namep);
    defsubr("hygienic-name?",(int)f_hygienic_namep);
    defsubr("zero?",(int)f_zerop);
    defsubr("+",(int)f_plus);
    defsubr("-",(int)f_minus);
    defsubr("*",(int)f_mult);
    defsubr("/",(int)f_div);
    defsubr("<",(int)f_smallerp);
    defsubr("<=",(int)f_eqsmallerp);
    defsubr(">",(int)f_greaterp);
    defsubr(">=",(int)f_eqgreaterp);
    defsubr("=",(int)f_numeqp);
	defsubr("sin",(int)f_sin);
    defsubr("cos",(int)f_cos);
    defsubr("tan",(int)f_tan);
    defsubr("asin",(int)f_asin);
    defsubr("acos",(int)f_acos);
    defsubr("atan",(int)f_atan);
    defsubr("log",(int)f_log);
    defsubr("exp",(int)f_exp);
    defsubr("sqrt",(int)f_sqrt);
    defsubr("expt",(int)f_expt);
    defsubr("not",(int)f_not);
    defsubr("odd?",(int)f_oddp);
    defsubr("even?",(int)f_evenp);
    defsubr("floor",(int)f_floor);
    defsubr("ceiling",(int)f_ceiling);
    defsubr("truncate",(int)f_truncate);
    defsubr("round",(int)f_round);
    defsubr("numerator",(int)f_numerator);
    defsubr("denominator",(int)f_denominator);
    defsubr("positive?",(int)f_positivep);
    defsubr("negative?",(int)f_negativep);
    defsubr("abs",(int)f_abs);
    defsubr("max",(int)f_max);
    defsubr("min",(int)f_min);
    defsubr("real-part",(int)f_realpart);
    defsubr("imag-part",(int)f_imagpart);
    defsubr("magnitude",(int)f_magnitude);
    defsubr("angle",(int)f_angle);
    defsubr("make-rectangular",(int)f_make_rectangular);
    defsubr("make-polar",(int)f_make_polar);
    defsubr("exact->inexact",(int)f_exact_inexact);
	defsubr("inexact->exact",(int)f_inexact_exact);
    defsubr("remainder",(int)f_remainder);
	defsubr("modulo",(int)f_modulo);
    defsubr("quotient",(int)f_quotient);
    defsubr("gcd",(int)f_gcd);
    defsubr("lcm",(int)f_lcm);
    defsubr("char=?",(int)f_char_eqp);
    defsubr("char>?",(int)f_char_greaterp);
    defsubr("char>=?",(int)f_char_eqgreaterp);
    defsubr("char<?",(int)f_char_smallerp);
    defsubr("char<=?",(int)f_char_eqsmallerp);
    defsubr("char-ci=?",(int)f_char_ci_eqp);
    defsubr("char-ci>?",(int)f_char_ci_greaterp);
    defsubr("char-ci>=?",(int)f_char_ci_eqgreaterp);
    defsubr("char-ci<?",(int)f_char_ci_smallerp);
    defsubr("char-ci<=?",(int)f_char_ci_eqsmallerp);
    defsubr("char-alphabetic?",(int)f_char_alphabeticp);
	defsubr("char-numeric?",(int)f_char_numericp);
    defsubr("char-whitespace?",(int)f_char_whitespacep);
    defsubr("char-upper-case?",(int)f_char_upper_casep);
    defsubr("char-lower-case?",(int)f_char_lower_casep);
    defsubr("char->integer",(int)f_char_to_integer);
    defsubr("integer->char",(int)f_integer_to_char);
    defsubr("char-upcase",(int)f_char_upcase);
    defsubr("char-downcase",(int)f_char_downcase);
    defsubr("string-append",(int)f_string_append);
    defsubr("number->string",(int)f_number_to_string);
    defsubr("string->number",(int)f_string_to_number);
    defsubr("string=?",(int)f_string_eqp);
    defsubr("string>?",(int)f_string_greaterp);
    defsubr("string>=?",(int)f_string_eqgreaterp);
    defsubr("string<?",(int)f_string_smallerp);
    defsubr("string<=?",(int)f_string_eqsmallerp);
    defsubr("string-ci=?",(int)f_string_ci_eqp);
    defsubr("string-ci>?",(int)f_string_ci_greaterp);
    defsubr("string-ci>=?",(int)f_string_ci_eqgreaterp);
    defsubr("string-ci<?",(int)f_string_ci_smallerp);
    defsubr("string-ci<=?",(int)f_string_ci_eqsmallerp);
    defsubr("string->symbol",(int)f_string_to_symbol);
    defsubr("symbol->string",(int)f_symbol_to_string);
    defsubr("string-length",(int)f_string_length);
    defsubr("make-string",(int)f_make_string);
    defsubr("string",(int)f_string);
    defsubr("string-ref",(int)f_string_ref);
    defsubr("string-set!",(int)f_string_set);
    defsubr("substring",(int)f_substring);
    defsubr("string->list",(int)f_string_to_list);
    defsubr("list->string",(int)f_list_to_string);
    defsubr("string-copy",(int)f_string_copy);
    defsubr("string-fill!",(int)f_string_fill);
    defsubr("make-vector",(int)f_make_vector);
    defsubr("vector-set!",(int)f_vector_set);
    defsubr("vector",(int)f_vector);
    defsubr("vector-ref",(int)f_vector_ref);
    defsubr("vector-length",(int)f_vector_length);
    defsubr("vector-fill!",(int)f_vector_fill);
    defsubr("vector->list",(int)f_vector_to_list);
    defsubr("list->vector",(int)f_list_to_vector);
    defsubr("read",(int)f_read);
    defsubr("load",(int)f_load);
    defsubr("open-input-file",(int)f_open_input_file);
    defsubr("open-output-file",(int)f_open_output_file);
    defsubr("close-input-port",(int)f_close_input_port);
    defsubr("close-output-port",(int)f_close_output_port);
    defsubr("eof-object?",(int)f_eof_objectp);
    defsubr("input-port?",(int)f_input_portp);
    defsubr("output-port?",(int)f_output_portp);
    defsubr("current-input-port",(int)f_current_input_port);
    defsubr("current-output-port",(int)f_current_output_port);
    defsubr("read-char",(int)f_read_char);
    defsubr("peek-char",(int)f_peek_char);
    defsubr("char-ready?",(int)f_char_readyp);
    defsubr("lambda/asm",(int)f_lambda_asm);
    defsubr("exit",(int)f_exit);
    defsubr("gensym",(int)f_gensym);
	defsubr("apply",(int)f_apply);
    defsubr("primitive-name?",(int)f_primitive_name_p);
    defsubr("macroexpand-1",(int)f_macroexpand1);
    defsubr("macroexpand",(int)f_macroexpand);
    defsubr("addr",(int)f_addr);
    defsubr("entity-addr",(int)f_entity_addr);
    defsubr("undefined",(int)f_undefined);
    defsubr("step",(int)f_step);
    defsubr("vm2-step",(int)f_vm2_step);
    defsubr("vm1",(int)f_vm1);
    defsubr("vm2",(int)f_vm2);
    defsubr("dump",(int)f_dump);
    defsubr("addr-prt",(int)f_addr_prt);
    defsubr("gbc",(int)f_gbc);
    defsubr("room",(int)f_room);
    defsubr("sys-code",(int)f_vmcode);
    defsubr("sys-env",(int)f_env);
    defsubr("sys-timer-set",(int)f_timer_set);
    defsubr("sys-timer-get",(int)f_timer_get);
    defsubr("sys-timer-gbc",(int)f_timer_gbc);
    defsubr("eval",(int)f_eval);
    defsubr("error",(int)f_error);
    defsubr("flush",(int)f_flush);
    defsubr("sys-set-trace",(int)f_set_trace);
    defsubr("sys-set-untrace",(int)f_set_untrace);
    defsubr("transfer",(int)f_transfer);
    defsubr("debug",(int)f_debug);
    defsubr("profiler",(int)f_prof);
    defsubr("current-module",(int)f_current_module);
    defsubr("values",(int)f_values);
	defsubr("sys-cont-room",(int)f_sys_cont_room);
    defsubr("make-syntactic-closure",(int)f_make_sc);
    defsubr("symbol->identifier",(int)f_symbol_to_identifier);
    defsubr("identifier->symbol",(int)f_identifier_to_symbol);
    defsubr("syntactic-closure?",(int)f_syntactic_closurep);
    defsubr("identifier?",(int)f_identifierp);
    defsubr("identifier-bind!",(int)f_identifier_bind);
    defsubr("identifier-free?",(int)f_identifier_freep);
    defsubr("identifier-bound?",(int)f_identifier_boundp);
    defsubr("identifier-bound",(int)f_identifier_bound);
    defsubr("global-bound?",(int)f_global_boundp);
    defsubr("inspect",(int)f_inspect);
    defsubr("exact-integer?",(int)f_exact_integerp);
    defsubr("file-exists?",(int)f_file_existsp);
    defsubr("system",(int)f_system);
}

void initsyntax(void){
	defsyntax("quote");
    defsyntax("begin");
    defsyntax("set!");
	defsyntax("if");
	defsyntax("lambda");
    defsyntax("define");
    defsyntax("define-macro");
    defsyntax("define-syntax");
    defsyntax("define-library");
    defsyntax("export");
    defsyntax("import");
    defsyntax("syntax-rules");
}L     p­ ì    .text           Æ    €ı      ›    0`.data                               @ 0À.bss                                € 0À.rdata           
  Ç              @ @@.drectve        `  0Ñ              @ 0À/4              ğ*  Ò  £     ı   @ 0@¸   Ãf¡    Ãf¡    ‹Å    Ãv ƒìè    ©   @uÁàƒ¸   •À¶À@ƒÄÃ¸   ƒÄÃv WVSè    ‰Ãè    ‰Æè    ‰Ç‰ØÁàƒ¸   t(è    ‰ÁÁáÇ      ‰™    ‰¹   ‰±   ‰Ã‰Ø[^_Ãƒìè    ƒø•À¶À@ƒÄÃfƒìè    Áàƒ¸   •À¶À@ƒÄÃv ƒìè    Áàƒ¸   	•À¶À@ƒÄÃv ƒìè    ©   @t	¸   ƒÄÃÁàƒ¸   •À¶À@ƒÄÃv ƒìè    ©   @t	¸   ƒÄÃÁàƒ¸   •À¶À@ƒÄÃv ƒìè    ‰$è    ƒøÀ÷ĞƒÀƒÄÃfSƒìè    ‰Ã‰$è    …Àu‰\$ÇD$   Ç$    è    Áã‹ƒ   ‰D$ ƒÄ[é    v Sƒìè    ‰Ã‰$è    …Àu‰\$ÇD$   Ç$   è    Áã‹ƒ   ‰$è    ¡    ƒÄ[ÃfSƒìè    ‰Ã‰$è    …Àt=ÇD$#   Áã‹ƒ   ‰$è    …Àt‰$è    ¸   ƒÄ[Ãf¸   ƒÄ[Ãf‰\$ÇD$   Ç$   è    ë©fƒìè    Áà‹€    ‰$è    Ç        ¡    ƒÄÃƒìè    Áà‹€    ‰$è    Ç        ¡    ƒÄÃƒì¡    ‰D$Ç$%   è    ¡    ‰D$Ç$9   è    ¡    ‰D$Ç$M   è    ¡    ‰D$Ç$a   è    ¡    ƒÄÃƒì¡    ƒÀ ‰$è    ¡    ƒÄÃƒìƒ|$tè    ‹    ‰    ƒÄÃè    Áà‹€    £    ëÕv Sƒìè    ‰Ãè    ‰\$‰$è    ƒøÀ÷ĞƒÀƒÄ[ÃVSƒì‹\$ 1ö…Û~è    ‰t$‰$è    ‰ÆKuê‰ğƒÄ[^ÃfSƒìè    ‰Ãè    ‰\$‰$è    ƒÄ[Ãv ƒìè    Áà‹€   ‰$è    ¡    ƒÄÃfVSƒì‹5    ƒÆ ëÇ$   è    ‰D$‰$è    …ÀuDÇ$u   è    ‰4$è    è    ‰ÃÇ$   è    ‰D$‰$è    …Àt­¡    ƒÄ[^ÃfÇ$ƒ   è    ¡    …À~§1Û‰Ú)Â‰T$Ç$   è    ‹İ   ‰D$‹İ    ‰$è    ‰$è    Ç$
   è    C¡    9Ø´éSÿÿÿv Sƒìè    ‰Ã‰$è    …Àu‰\$ÇD$   Ç$”   è    Áã‹ƒ   ƒÄ[Ãv Sƒìè    ‰Ã‰$è    …ÀtÁãÃ    ƒ{À÷ĞƒÀƒÄ[Ã¸   ƒÄ[ÃfSƒìè    ‰Ã‰$è    …Àu¸   ƒÄ[Ãv ÁãÃ    ƒ{ÀƒÀƒÄ[ÃVSƒìè    ‰Æè    ‰Ã‰$è    …Àu‰\$ÇD$   Ç$¥   è    ‰ØÁà‰°   ‰ØƒÄ[^Ãfƒìè    ‰$è    ƒøÀ÷ĞƒÀƒÄÃfSƒìè    ‰Ã‰$è    …Àu‰\$ÇD$   Ç$¶   è    Áã‹ƒ   ‰D$ ƒÄ[é    v Sƒìè    ‰Ã‰$è    …ÀtÁã¡    9ƒ    ”À¶À@ƒÄ[Ãv ‰\$ÇD$   Ç$É   è    ëÉfƒìè    ‰$è    ƒøÀ÷ĞƒÀƒÄÃfƒìè    ‰$è    ƒøÀ÷ĞƒÀƒÄÃfSƒìè    ‰Ã‰$è    …Àu‰\$ÇD$   Ç$×   è    Áã‹ƒ   ‰D$ ƒÄ[é    v UWVSƒìè    ‹    ‰$è    £    ÇD$    Ç$   è    Áà‹¨    ‹¸   ‹€   ‰$è    ‰ÆÁå‹…    ‹@‰D$Ç$ê   è    Áç‹‡   ‰D$Ç$ù   è    ‰4$è    ‰    ¡    ƒÄ[^_]Ãfƒìè    ‰$è    ƒøÀ÷ĞƒÀƒÄÃfƒìè    ‰$è    ‰$è    Ç$
   è    ¡    ƒÄÃv VSƒìƒ|$ t\è    ‰Ã1ö‰$è    …Àt+‰$è    ‰Ã1À…Û~v ‰D$‰4$è    KuñƒÄ[^Ãv ‰\$ÇD$   Ç$  è    ë»fè    ‰Æè    ‰ÃëSƒìè    ‰Ã‰$è    ;    t‰$è    ‰D$ ƒÄ[é    ‰\$ÇD$   Ç$  è    ¡    ƒÄ[Ãfƒìè    ‰D$ƒÄé    ƒìè    Ç        Ç        ‰$è    Ç        Ç        Ç        ƒÄé    fUWVSƒì,è    ‰Æè    ‰Ã‰$è    …À„o  ‰4$è    …Àu‰t$ÇD$
(define (create-n n)
  (do ((n n (- n 1))
       (a '() (cons '() a)))
      ((= n 0) a)))
 
(define (iterative-div2 l)
  (do ((l l (cddr l))
       (a '() (cons (car l) a)))
      ((null? l) a)))

(define (iterative=? n)
  (= (length (iterative-div2 (create-n n))) (/ n 2)))
 
(define (recursive-div2 l)
  (cond ((null? l) '())
        (else (cons (car l) (recursive-div2 (cddr l))))))

(define (recursive=? n)
  (= (length (recursive-div2 (create-n n))) (/ n 2)))



(define (deriv a)
  (cond ((not (pair? a))
         (if (eq? a 'x) 1 0))
        ((eq? (car a) '+)
         (cons '+
               (map deriv (cdr a))))
        ((eq? (car a) '-)
         (cons '-
               (map deriv (cdr a))))
        ((eq? (car a) '*)
         (list '*
                a
                (cons '+
                      (map (lambda (a) (list '/ (deriv a) a)) (cdr a)))))
        ((eq? (car a) '/)
         (list '-
               (list '/
                     (deriv (cadr a))
                     (caddr a))
               (list '/
                     (cadr a)
                     (list '*
                           (caddr a)
                           (caddr a)
                           (deriv (caddr a))))))
        (else
         (error "No derivation method available" a))))

;;; DESTRUC -- Destructive operation benchmark.


(define (append-to-tail! x y)
  (if (null? x)
    y
    (let loop ((a x) (b (cdr x)))
      (if (null? b)
        (begin
          (set-cdr! a y)
          x)
        (loop b (cdr b))))))

(define (destructive n m)
  (let ((l (do ((i 10 (- i 1)) (a '() (cons '() a)))
               ((= i 0) a))))
    (do ((i n (- i 1)))
        ((= i 0) l)
      (cond ((null? (car l))
             (do ((l l (cdr l)))
                 ((null? l))
               (if (null? (car l)) (set-car! l (cons '() '())))
               (append-to-tail! (car l)
                                (do ((j m (- j 1)) (a '() (cons '() a)))
                                  ((= j 0) a)))))
            (else
             (do ((l1 l (cdr l1)) (l2 (cdr l) (cdr l2)))
                 ((null? l2))
               (set-cdr! (do ((j (div (length (car l2)) 2) (- j 1))
                              (a (car l2) (cdr a)))
                             ((zero? j) a)
                           (set-car! a i))
                         (let ((n (div (length (car l1)) 2)))
                           (cond ((= n 0)
                                  (set-car! l1 '())
                                  (car l1))
                                 (else
                                  (do ((j n (- j 1)) (a (car l1) (cdr a)))
                                      ((= j 1)
                                       (let ((x (cdr a)))
                                         (set-cdr! a '())
                                         x))
                                    (set-car! a i))))))))))))


(define (sum n)
  (let loop ((i n) (result 0))
    (if (< i 0)
      result
      (loop (- i 1) (+ i result)))))

(define (cpstak x y z)
  (define (tak x y z k)
    (if (not (< y x))
        (k z)
        (tak (- x 1)
             y
             z
             (lambda (v1)
               (tak (- y 1)
                    z
                    x
                    (lambda (v2)
                      (tak (- z 1)
                           x
                           y
                           (lambda (v3)
                             (tak v1 v2 v3 k)))))))))
  
  (tak x y z (lambda (a) a)))

(define (ctak x y z)
  (call-with-current-continuation
    (lambda (k) (ctak-aux k x y z))))

(define (ctak-aux k x y z)
  (if (not (< y x))
      (k z)
      (call-with-current-continuation
        (lambda (k)
          (ctak-aux
           k
           (call-with-current-continuation
             (lambda (k) (ctak-aux k (- x 1) y z)))
           (call-with-current-continuation
             (lambda (k) (ctak-aux k (- y 1) z x)))
           (call-with-current-continuation
             (lambda (k) (ctak-aux k (- z 1) x y))))))))

(define (succ n) (+ n 1))
(define (pred n) (- n 1))

;;; fib with peano arithmetic (using numbers) with call/cc

(define (addc x y k)
  (if (zero? y)
    (k x)
    (addc (succ x) (pred y) k)))

(define (fibc x c)
  (if (zero? x)
    (c 0)
    (if (zero? (pred x))
      (c 1)
      (addc (call-with-current-continuation
             (lambda (c) (fibc (pred x) c)))
            (call-with-current-continuation
             (lambda (c) (fibc (pred (pred x)) c)))
            c))))

(define (fibfp n)
  (if (fl<? n 2.)
    n
    (fl+ (fibfp (fl- n 1.))
         (fibfp (fl- n 2.)))))


(define (solve? num ls)
  (let loop ((ls ls)(n 1))
    (cond
      ((null? ls)#t)
      ((= (abs (- num (car ls))) n)
       #f)
      (else (loop (cdr ls)(+ n 1))))))

(define (check? lst)
  (let loop ((lst lst))
    (cond
      ((null? (cdr lst))#t)
      ((solve? (car lst) (cdr lst))
       (loop (cdr lst)))
      (else #f))))

(define (queen lst)
  (let loop ((lst lst)(result '()))
    (if (null? lst)
        (print (reverse result))
      (for-each (lambda(x)
        (if (check? (reverse (cons x result)))
                  (loop (delete x lst) (cons x result)))) lst))))

(define (delete x lst)
  (cond ((null? lst) '())
        ((eq? x (car lst)) (delete x (cdr lst)))
        (else (cons (car lst) (delete x (cdr lst))))))

(define (print x)
  (display x)
  (newline))


(define (foo n)
  (call/cc 
    (lambda (c)
      (if (= n 0)
          (c 0)
          (+ n (foo (- n 1)))))))

(define (nth ls n)
  (if (zero? n)
      (car ls)
      (nth (cdr ls) (- n 1))))


(define-syntax nil!
  (syntax-rules ()
    ((_ x)
     (set! x '()))))

(define-syntax when
  (syntax-rules ()
    ((_ pred b1 ...)
     (if pred (begin b1 ...)))))

(define-syntax my-and
  (syntax-rules ()
    ((_) #t)
    ((_ e) e)
    ((_ e1 e2 ...)
     (if e1
	 (my-and e2 ...)
	 #f))))

(define-syntax arithmetic-if
  (syntax-rules ()
    ((_ test neg zero pos)
     (let ((var test))
       (cond ((< var 0) neg)
             ((= var 0) zero)
             (else pos))))))


(define-syntax for
  (syntax-rules ()
    ((_ (i from to) b1 ...)
     (let loop((i from))
       (when (< i to)
         b1 ...
         (loop (+ i 1)))))))

(define-syntax incf
  (syntax-rules ()
    ((_ x) (begin (set! x (+ x 1)) x))
    ((_ x i) (begin (set! x (+ x i)) x))))

(define-syntax swap!
  (syntax-rules ()
    ((swap! a b)
     (let ((value a))
       (set! a b)
       (set! b value)))))

(define b 2)

(define-syntax settest
  (syntax-rules ()
    ((_) (set! b 1))))

(let ((b 100))
  (display b)
  (newline)
  (settest)
  (display b))
(38 (normal system) ((export pair-length last butlast sys-code sys-env sys-timer-set sys-timer-get sys-timer-gbc primitive-name? macroexpand-1 macroexpand addr entity-addr undefined step vm2-step vm1 vm2 dump addr-prt room macro-name? hygienic-name? gensym flush sys-set-trace sys-set-untrace transfer debug profiler current-module sys-cont-room make-syntactic-closure symbol->identifier identifier->symbol syntactic-closure? identifier? identifier-bind! identifier-free? identifier-bound? identifier-bound global-bound? inspect lambda/asm system)) 2 (normal system) 1)
(38 (normal compile) ((export compile assemble compile-file map for-each and or let let* cond letrec do case call/cc call-with-current-continuation dynamic-wind call-with-values)) 2 (normal compile) 1)
(38 (scheme base) ((import (normal system) (normal compile)) (export car cdr cons caar cdar cddr cadr caaar cdaar cadar caadr cddar caddr cdadr cdddr caaaar cdaaar cadaar caadar caaadr cddaar caddar caaddr cdaadr cdadar cadddr cdaddr cddadr cdddar cddddr assq assv assoc memq memv member reverse reverse! list-tail list-ref append append! set-car! set-cdr! list make-list length newline write-char null? list? pair? atom? eq? eqv? equal? boolean? procedure? number? integer? real? rational? complex? exact? inexact? symbol? string? char? bignum? vector? macro? zero? error + - * / < <= > >= = expt not odd? even? floor ceiling truncate round numerator denominator positive? negative? abs max min exact->inexact inexact->exact remainder modulo quotient gcd lcm string-append number->string string->number string=? string>? string>=? string<? string<=? string-ci=? string-ci>? string-ci>=? string-ci<? string-ci<=? string->symbol symbol->string string-length make-string string string-ref string-set! substring string->list list->string string-copy string-fill! make-vector vector-set! vector vector-ref vector-length vector-fill! vector->list list->vector open-input-file open-output-file close-input-port close-output-port eof-object? input-port? output-port? current-input-port current-output-port read-char peek-char char-ready? exit apply gbc values map for-each and or let let* cond letrec do case call/cc call-with-current-continuation dynamic-wind call-with-values exact-integer? when unless) (begin (define-macro when (lambda (pred . true) (cons 'if (cons pred (cons (cons 'begin (append true '())) '()))))) (define-macro unless (lambda (pred . else) (cons 'if (cons (cons 'not (cons pred '())) (cons (cons 'undefined '()) (cons (cons 'begin (append else '())) '())))))))) 2 (scheme base) 1)
(38 (scheme inexact) ((export sin cos tan asin acos atan log exp sqrt)) 2 (scheme inexact) 1)
(38 (scheme complex) ((export real-part imag-part magnitude angle make-rectangular make-polar)) 2 (scheme complex) 1)
(38 (scheme division) ((import (scheme base)) (export floor/ round/ truncate/ ceiling/) (begin (define (floor/ n1 n2) (when (zero? n2) (error "in floor/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in floor/ not integer " n1 n2)) (let* ((q (floor (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (round/ n1 n2) (when (zero? n2) (error "in round/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in round/ not integer " n1 n2)) (let* ((q (round (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (truncate/ n1 n2) (when (zero? n2) (error "in truncate/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in truncate/ not integer " n1 n2)) (let* ((q (truncate (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))) (define (ceiling/ n1 n2) (when (zero? n2) (error "in ceiling/ devide by zero " n1 n2)) (when (or (not (integer? n1)) (not (integer? n2))) (error "in ceiling/ not integer " n1 n2)) (let* ((q (ceiling (/ n1 n2))) (r (- n1 (* n2 q)))) (values q r))))) 2 (scheme division) 1)
(38 (scheme eval) ((export eval)) 2 (scheme eval) 1)
(38 (scheme load) ((export load)) 2 (scheme load) 1)
(38 (scheme read) ((export read)) 2 (scheme read) 1)
(38 (scheme write) ((export display write)) 2 (scheme write) 1)
(38 (scheme char) ((export char=? char>? char>=? char<? char<=? char-ci=? char-ci>? char-ci>=? char-ci<? char-ci<=? char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case? char->integer integer->char char-upcase char-downcase)) 2 (scheme char) 1)
(38 (scheme lazy) ((export delay force) (import (scheme base)) (begin (define-macro delay (lambda (expr) (cons 'make-promise (cons (cons 'lambda (cons '() (cons expr '()))) '())))) (define make-promise (lambda (p) (let ((val #f) (set? #f)) (lambda () (if (not set?) (let ((x (p))) (if (not set?) (begin (set! val x) (set! set? #t)) '())) '()) val)))) (define force (lambda (x) (if (procedure? x) (x) x))))) 2 (scheme lazy) 1)
(38 (scheme time) ((import (normal system) (scheme base) (scheme write)) (export time) (begin (define-macro time (lambda (expr) (cons 'begin (cons (cons 'gbc '()) (cons (cons 'sys-timer-set '()) (cons (cons 'display (cons expr '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"total " '())) (cons (cons 'display (cons (cons 'sys-timer-get '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"GC    " '())) (cons (cons 'display (cons (cons 'sys-timer-gbc '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) '()))))))))))))))))) 2 (scheme time) 1)
(38 (scheme file) ((export call-with-input-file call-with-output-file with-input-from-file with-output-to-file file-exists? delete-file) (import (scheme base) (normal system)) (begin (define (call-with-input-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc p))) (close-input-port p) v))) (define (call-with-output-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc p))) (close-output-port p) v))) (define (with-input-from-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc))) (close-input-port p) v))) (define (with-output-to-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc))) (close-output-port p) v))) (define (delete-file x) (when (not (string? x)) (error "in delete-file require string " x)) (system (string-append "del " x))))) 2 (scheme file) 1)
(38 (normal test) ((import (scheme base) (scheme write)) (export test*) (begin (define-macro test* (lambda (name expected expr) (cons 'let (cons (cons (cons 'result (cons (cons 'quote (cons '() '())) '())) '()) (cons (cons 'display (cons '"test " '())) (cons (cons 'display (cons name '())) (cons (cons 'display (cons '", expects " '())) (cons (cons 'display (cons expected '())) (cons (cons 'display (cons '" ==> " '())) (cons (cons 'set! (cons 'result (cons expr '()))) (cons (cons 'if (cons (cons 'equal? (cons 'result (cons expected '()))) (cons (cons 'display (cons '"ok\n" '())) (cons (cons 'begin (cons (cons 'display (cons '"ERROR: GOT " '())) (cons (cons 'display (cons 'result '())) (cons (cons 'newline '()) '())))) '())))) '()))))))))))))) 2 (normal test) 1)
(38 (normal debug) ((import (normal system) (scheme base)) (export trace untrace debug step profiler) (begin (define-macro trace (lambda fn (cons 'sys-set-trace (append (map (lambda (x) (list 'quote x)) fn) '())))) (define-macro untrace (lambda fn (cons 'sys-set-untrace (append (map (lambda (x) (list 'quote x)) fn) '())))))) 2 (normal debug) 1)
(40 ((scheme base)) 1)
(40 ((scheme load)) 1)
(40 ((scheme write)) 1)
(40 ((scheme read)) 1)
(40 ((scheme eval)) 1)

(define-library (normal system)
  (export
    pair-length
    last
    butlast
    sys-code
    sys-env
    sys-timer-set
    sys-timer-get
    sys-timer-gbc
    primitive-name?
    macroexpand-1
    macroexpand
    addr
    entity-addr
    undefined
    step
    vm2-step
    vm1
    vm2
    dump
    addr-prt
    room
    macro-name?
    hygienic-name?
    gensym
    flush
    sys-set-trace
    sys-set-untrace
    transfer
    debug
    profiler
    current-module
    sys-cont-room
    make-syntactic-closure
    symbol->identifier
    identifier->symbol
    syntactic-closure?
    identifier?
    identifier-bind!
    identifier-free?
    identifier-bound?
    identifier-bound
    global-bound?
    inspect
    lambda/asm
    system))
  
(define-library (normal compile)
  (export compile assemble compile-file map for-each and or let let* cond letrec do case
          call/cc call-with-current-continuation dynamic-wind call-with-values))

(define-library (scheme base)
  (import (normal system)
          (normal compile))
  (export
    car cdr cons caar cdar cddr cadr caaar cdaar cadar caadr cddar caddr cdadr
    cdddr caaaar cdaaar cadaar caadar caaadr cddaar caddar caaddr cdaadr cdadar
    cadddr cdaddr cddadr cdddar cddddr assq assv assoc memq memv member reverse
    reverse! list-tail list-ref append append! set-car! set-cdr! list make-list length newline
    write-char null? list? pair? atom? eq? eqv? equal? boolean? procedure? number?
    integer? real? rational? complex? exact? inexact? symbol? string? char? bignum?
    vector? macro? zero? error
    + - * / < <= > >= =
    expt not odd? even? floor ceiling truncate round numerator denominator positive?
    negative? abs max min exact->inexact inexact->exact remainder modulo quotient
    gcd lcm string-append number->string string->number
    string=? string>? string>=? string<? string<=? string-ci=? string-ci>? string-ci>=?
    string-ci<? string-ci<=? string->symbol symbol->string string-length make-string
    string string-ref string-set! substring string->list list->string string-copy string-fill!
    make-vector vector-set! vector vector-ref vector-length vector-fill! vector->list list->vector
    open-input-file open-output-file close-input-port close-output-port
    eof-object? input-port? output-port? current-input-port current-output-port
    read-char peek-char char-ready? exit apply gbc values
    map for-each and or let let* cond letrec do case call/cc call-with-current-continuation
    dynamic-wind call-with-values exact-integer? when unless)
  (begin
    (define-macro when
      (lambda (pred . true)
        `(if ,pred (begin ,@true))))
    
    (define-macro unless
      (lambda (pred . else)
        `(if (not ,pred) (undefined) (begin ,@else)))))
)



(define-library (scheme inexact)
  (export
    sin cos tan asin acos atan log exp sqrt))

(define-library (scheme complex)
  (export
    real-part imag-part magnitude angle make-rectangular make-polar))

(define-library (scheme division)
  (import (scheme base))
  (export floor/ round/ truncate/ ceiling/)
  (begin
    (define (floor/ n1 n2)
      (when (zero? n2)
        (error "in floor/ devide by zero " n1 n2))
      (when (or (not (integer? n1)) (not (integer? n2)))
        (error "in floor/ not integer " n1 n2))
      (let* ((q (floor (/ n1 n2)))
             (r (- n1 (* n2 q))))
        (values q r)))
    
    (define (round/ n1 n2)
      (when (zero? n2)
        (error "in round/ devide by zero " n1 n2))
      (when (or (not (integer? n1)) (not (integer? n2)))
        (error "in round/ not integer " n1 n2))
      (let* ((q (round (/ n1 n2)))
             (r (- n1 (* n2 q))))
        (values q r)))
    
    (define (truncate/ n1 n2)
      (when (zero? n2)
        (error "in truncate/ devide by zero " n1 n2))
      (when (or (not (integer? n1)) (not (integer? n2)))
        (error "in truncate/ not integer " n1 n2))
      (let* ((q (truncate (/ n1 n2)))
             (r (- n1 (* n2 q))))
        (values q r)))
    
    
    (define (ceiling/ n1 n2)
      (when (zero? n2)
        (error "in ceiling/ devide by zero " n1 n2))
      (when (or (not (integer? n1)) (not (integer? n2)))
        (error "in ceiling/ not integer " n1 n2))
      (let* ((q (ceiling (/ n1 n2)))
             (r (- n1 (* n2 q))))
        (values q r)))
    
))


  


(define-library (scheme eval)
  (export eval))

(define-library (scheme load)
  (export load))

(define-library (scheme read)
  (export read))

(define-library (scheme write)
  (export display write))

(define-library (scheme char)
  (export
    char=? char>? char>=? char<? char<=? char-ci=? char-ci>? char-ci>=? char-ci<? char-ci<=?
    char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case?
    char->integer integer->char char-upcase char-downcase))

(define-library (scheme lazy)
  (export delay force)
  (import (scheme base))
  (begin
    ;;; ;;’x‰„•]‰¿
    ;;; ;;Kent Dybvig p98
    (define-macro delay
      (lambda (expr)
        `(make-promise (lambda () ,expr))))
    
    (define make-promise
      (lambda (p)
        (let ((val #f) (set? #f))
          (lambda ()
            (if (not set?)
                (let ((x (p)))
                  (if (not set?)
                      (begin (set! val x)
                             (set! set? #t))
                      '()))
                '())
            val))))
    
    (define force
      (lambda (x)
        (if (procedure? x)
            (x)
            x)))))

(define-library (scheme time)
  (import (normal system)
          (scheme base)
          (scheme write))
  (export time)
  (begin
    (define-macro time
      (lambda (expr)
        `(begin (gbc)
                (sys-timer-set)
                (display ,expr)
                (newline)
                (display "total ")
                (display (sys-timer-get))
                (display " second")
                (newline)
                (display "GC    ")
                (display (sys-timer-gbc))
                (display " second")
                (newline))))))

(define-library (scheme file)
  (export call-with-input-file
          call-with-output-file
          with-input-from-file
          with-output-to-file
          file-exists?
          delete-file)
  (import (scheme base)
          (normal system))
  (begin
    ;;ƒtƒ@ƒCƒ‹
    (define (call-with-input-file filename proc)
      (let ((p (open-input-file filename)))
        (let ((v (proc p)))
          (close-input-port p)
          v)))
    
    (define (call-with-output-file filename proc)
      (let ((p (open-output-file filename)))
        (let ((v (proc p)))
          (close-output-port p)
          v)))
    
    (define (with-input-from-file filename proc)
      (let ((p (open-input-file filename)))
        (let ((v (proc)))
          (close-input-port p)
          v)))
    
    (define (with-output-to-file filename proc)
      (let ((p (open-output-file filename)))
        (let ((v (proc)))
          (close-output-port p)
          v)))
    (define (delete-file x)
      (when (not (string? x)) (error "in delete-file require string " x))
      (system (string-append "del " x)))
    ))

;;ƒeƒXƒg—p‚Ìƒ}ƒNƒ
(define-library (normal test)
  (import (scheme base)
          (scheme write))
  (export test*)
  (begin
    (define-macro test*
      (lambda (name expected expr)
        `(let ((result '()))
           (display "test ")
           (display ,name)
           (display ", expects ")
           (display ,expected)
           (display " ==> ")
           (set! result ,expr)
           (if (equal? result ,expected)
               (display "ok\n")
               (begin (display "ERROR: GOT ")
                      (display result)
                      (newline))))))))

;;ƒfƒoƒbƒO—p‚Ìƒ}ƒNƒ
(define-library (normal debug)
  (import (normal system)
          (scheme base))
  (export trace untrace debug step profiler)
  (begin
    
    (define-macro trace
      (lambda fn
        `(sys-set-trace ,@(map (lambda (x) (list 'quote x)) fn))))
    
    (define-macro untrace
      (lambda fn
        `(sys-set-untrace ,@(map (lambda (x) (list 'quote x)) fn))))))
    

(import (scheme base))
(import (scheme load))
(import (scheme write))
(import (scheme read))
(import (scheme eval))


  ;;Babbage—p‚Ì‰¹ŠyA‰æ‘œƒ‰ƒCƒuƒ‰ƒŠBNormal—p‚É‘‚«’¼‚µ‚½B
;;written by K.Sasagawa
;;------MIDIŠÖŒW----------------

(define-library (normal kids)
  (import (normal system)
          (scheme base)
          (scheme write))
  (export fd bk lt rt cls)
  (begin
    
    (define *volume* 127)
    
    (define *tempo* 240)
    
    (define *channel* 0)
    
    (define (midi-open)
      (display "@MIDIOpen;")
      (flush))
    
    (define (midi-close)
      (display "@MIDIClose;")
      (flush))
    
    (define (midi-msg x1 x2 x3 x4)
      (check-integer x1)
      (check-integer x2)
      (check-integer x3)
      (check-integer x4)
      (display "@MIDIMsg ")
      (display x1)
      (display " ")
      (display x2)
      (display " ")
      (display x3)
      (display " ")
      (display x4)
      (display ";")
      (flush))
    
    
    (define (note-on n)
      (midi-msg (+ #x90 *channel*) n *volume* 0))
    
    (define (note-off n)
      (midi-msg (+ #x80 *channel*) n *volume* 0))
    
    (define (all-note-off)
      (midi-msg (+ #xb0 *channel*) #x7b 0 0))
    
    (define (all-sound-off)
      (midi-msg (+ #xb0 *channel*) #x78 0 0))
    
    (define (reset-all-controller)
      (midi-msg (+ #xb0 *channel*) #x79 0 0))
    
    (define (pitch-bend n)
      (check-integer n)
      (let* ((m (+ n 8192))
             (msb (/ (logand #b11111110000000 m) (expt 2 7)))
             (lsb (logand #b00000001111111 m)))
        (midi-msg (+ #xe0 *channel*) lsb msb 0)))
    
    (define (logand m n)
      (if (or (= m 0) (= n 0))
          0
          (+ (* (remainder m 2) (remainder n 2))
             (* 2 (logand (quotient m 2) (quotient n 2)))))) 
    
    (define (pitch-bend-sensitivity n)
      (check-integer n)
      (midi-msg (+ #xb0 *channel*) 101 0 0)
      (midi-msg (+ #xb0 *channel*) 100 0 0)
      (midi-msg (+ #xb0 *channel*) 6 n 0))
    
    (define (voice n)
      (check-integer n)
      (midi-msg (+ #xc0 *channel*) n 0 0))
    
    (define (volume n)
      (check-integer n)
      (cond ((< n 0) (set! *volume* 0))
            ((> n 127) (set! *volume* 127))
            (else (set! *volume* n))))
    
    (define (tempo n)
      (check-integer n)
      (cond ((< n 10) (set! *tempo* 10))
            ((> n 240) (set! *tempo* 240))
            (else (set! *tempo* n))))
    
    (define (channel n)
      (check-integer n)
      (if (and (>= n 0) (<= n 16))
          (set! *channel* n)
          (error "channel must be  0<= n <= 16" n)))
    
    (define (note p . options)
      (let ((l 1/4)
            (b #f))
        (cond ((assq 'b options) (set! b (cadr (assq 'b options))))
              ((assq 'l options) (set! l (cadr (assq 'l options)))))
        (note1 (make-regular-pitch p) l b)))
    
    
    (define (make-regular-pitch p)
      (if (member p '(A A# B B# C C# D D# E F F# G G#))
          (string->symbol (string-append (symbol->string p) "4"))
          p))
    
    (define (note1 p l b)
      (check-pitch p)
      (check-number l)
      (let* ((n (pitch->number p))
             (milli 1000)
             (time1 (* (/ (* 60 4) *tempo*) l milli))
             (time2 (ceiling->exact time1)))
        (note-on n)
        (cond (b (note-on n)
                 (pitch-bend-sensitivity 12)
                 (bend-n 10 (* b 683) (quotient (* b 683) 10) (quotient time2 20))
                 (sleep (quotient time2 20))
                 (note-off n))
              (else 
                (note-on n)
                (sleep time2)
                (note-off n)))))
    
    (define (ceiling->exact x)
      (inexact->exact (ceiling x)))
    
    
    (define (bend-n n sensitivity diff time1)
      (cond ((zero? n) #t)
            (else (pitch-bend sensitivity)
                  (sleep time1)
                  (bend-n (- n 1) (- sensitivity diff) diff time1))))
    
    
    (define (chord ps . options)
      (let ((l 1)
            (a #f))
        (cond ((assq 'l options) (set! l (cadr (assq 'l options))))
              ((assq 'a options) (set! a (cadr (assq 'a options)))))
        (let ((ps1 (map make-regular-pitch ps)))
          (for-each check-pitch ps1)
          (check-number l)
          (cond (a
                  (check-arpeggio a)
                  (chord1 ps1 a))
                (else
                  (chord2 ps1 l))))))
    
    (define (check-arpeggio pat)
      (if (and (list? pat)
               (every integer? pat)
               (<= (max-list pat) (length pat))
               (>= (min-list pat) 1))
          #t
          (error "malformed arpegio pattern: " pat)))
    
    (define (every f ls)
      (cond ((null? ls) #t)
            ((not (f (car ls))) #f)
            (else (every f (cdr ls)))))
    
    
    (define (max-list ls)
      (if (null? (cdr ls))
          (car ls)
          (max (car ls) (max-list (cdr ls)))))
    
    (define (min-list ls)
      (if (null? (cdr ls))
          (car ls)
          (max (car ls) (min-list (cdr ls)))))
    
    
    (define (chord1 ps a)
      (define (iter ps l a1)
        (cond ((null? a1) #t)
              (else (note (list-ref ps (- (car a1) 1)) `(l ,l))
                    (iter ps l (cdr a1)))))
      (let ((l (/ 1 (length a))))
        (iter ps l a)))
    
    
    (define (chord2 ps l)
      (let* ((ps1 (map pitch->number ps))
             (milli 1000)
             (time1 (* (/ (* 60 4) *tempo*) l milli))
             (time2 (ceiling->exact time1)))
        (for-each note-on ps1)
        (sleep time2)
        (all-note-off)))
    
    
    (define (check-pitch p)
      (if (not (pitch? p))
          (error "pitch required but got: " p)))
    
    
    
    (define (pitch-name p)
      (let ((p1 (symbol->string p)))
        (cond ((= (string-length p1) 2)
               (char->symbol(string-ref (symbol->string p) 0)))
              ((= (string-length p1) 3)
               (string->symbol (char-append (string-ref (symbol->string p) 0)
                                            (string-ref (symbol->string p) 1))))
              (else #f))))
    
    
    (define (char->symbol x)
      (string->symbol (list->string (list x))))
    
    (define (char-append x y)
      (list->string (list x y)))
    
    (define (pitch-nth p)
      (let* ((p1 (symbol->string p))
             (n (string-length p1)))
        (- (char->integer (string-ref p1 (- n 1))) (char->integer #\0))))
    
    (define (pitch? p)
      (cond ((symbol? p)
             (let ((name (pitch-name p))
                   (nth (pitch-nth p)))
               (if (and (member name '(A A# B B# C C# D D# E F F# G G#))
                        (member nth '(0 1 2 3 4 5 6 7 8 9)))
                   #t
                   #f)))
            (else #f)))
    
    (define (pitch->number p)
      (let ((name (pitch-name p))
            (nth (pitch-nth p)))
        (case name
              ((C)  (* 12 nth))
              ((C#) (+ (* 12 nth) 1))
              ((D)  (+ (* 12 nth) 2))
              ((D#) (+ (* 12 nth) 3))
              ((E)  (+ (* 12 nth) 4))
              ((F)  (+ (* 12 nth) 5))
              ((F#) (+ (* 12 nth) 6))
              ((G)  (+ (* 12 nth) 7))
              ((G#) (+ (* 12 nth) 8))
              ((A)  (+ (* 12 nth) 9))
              ((A#) (+ (* 12 nth) 10))
              ((B)  (+ (* 12 nth) 11)))))
    
    
    (define (number->pitch n)
      (let* ((nth (- (quotient n 12) 1))
             (r (remainder n 12))
             (name (list-ref '(C C# D D# E F F# G G# A A# B) r)))
        (string->symbol (string-append (symbol->string name) (number->string nth)))))
    
    ;;------•`‰æŠÖŒW----------------
    (define (check-number x)
      (if (not (number? x))
          (error "number required but got: " x)))
    
    (define (check-integer n)
      (if (not(integer? n))
          (error "integer required but got: " n)))
    
    (define (check-symbol s)
      (if (not(symbol? s))
          (error "symbol required but got: " s)))
    
    (define (close)
      (display "@Close;")
      (flush))
    
    (define (move x y)
      (check-number x)
      (check-number y)
      (if (and (number? x)(number? y))
          (begin (display "@Move ")
                 (display x)
                 (display " ")
                 (display y)
                 (display ";")
                 (flush))
          (error "expect arguments of type <number>" x)))
    
    (define (set-pos x y)
      (check-number x)
      (check-number y)
      (pen-up)
      (move x y)
      (pen-down))
    
    (define (set-x x)
      (check-number x)
      (display "@Setx ")
      (display x)
      (display ";")
      (flush))
    
    (define (set-y y)
      (check-number y)
      (display "@Sety ")
      (display y)
      (display ";")
      (flush))
    
    
    (define (home)
      (display "@Home;")
      (flush))
    
    
    (define (forward n)
      (check-number n)
      (display "@FD ")
      (display n)
      (display ";")
      (flush))
    
    
    (define (fd n)
      (forward n))
    
    
    (define (back n)
      (check-number n)
      (display "@BK ")
      (display n)
      (display ";")
      (flush))
    
    
    (define (bk n)
      (back n))
    
    
    (define (north)
      (display "@North;")
      (flush))
    
    
    (define (pset x y)
      (check-number x)
      (check-number y)
      (display "@PS ")
      (display x)
      (display " ")
      (display y)
      (display ";")
      (flush))
    
    (define (dot x y)
      (check-number x)
      (check-number y)
      (pset x y))
    
    (define (fill x y)
      (check-number x)
      (check-number y)
      (display "@Fill ")
      (display x)
      (display " ")
      (display y)
      (display ";")
      (flush))
    
    (define (circle x y r)
      (check-number x)
      (check-number y)
      (check-number r)
      (display "@Circle ")
      (display x)
      (display " ")
      (display y)
      (display " ")
      (display r)
      (display ";")
      (flush))
    
    
    (define (set-zoom x)
      (check-number x)
      (display "@SetZoom ")
      (display x)
      (display ";")
      (flush))
    
    
    (define (quadrant n)
      (check-integer n)
      (display "@Quadrant ")
      (display n)
      (display ";")
      (flush))
    
    
    (define (left n)
      (check-integer n)
      (display "@LT ")
      (display n)
      (display ";")
      (flush))
    
    
    (define (lt n)
      (left n))
    
    
    (define (right n)
      (check-integer n)
      (display "@RT ")
      (display n)
      (display ";")
      (flush))
    
    
    (define (rt n)
      (right n))
    
    
    (define (cls)
      (display "@Cls;")
      (flush))
    
    
    (define (fore)
      (display "@Fore;")
      (flush))
    
    
    (define (pen-up)
      (display "@PenUp;")
      (flush))
    
    
    (define (pu)
      (pen-up))
    
    
    (define (pen-down)
      (display "@PenDown;")
      (flush))
    
    
    (define (pd)
      (pen-down))
    
    
    (define (show-turtle)
      (display "@ShowTurtle;")
      (flush))
    
    (define (st)
      (show-turtle))
    
    
    (define (hide-turtle)
      (display "@HideTurtle;")
      (flush))
    
    (define (ht)
      (hide-turtle))
    
    (define (letter x)
      (check-number x)
      (display "@Letter ")
      (display x)
      (display ";")
      (flush))
    
    (define (pen-color c)
      (check-symbol c)
      (cond ((eq? c 'blue) (display "@PenBlue;"))
            ((eq? c 'aqua) (display "@PenAqua;"))
            ((eq? c 'red) (display "@PenRed;"))
            ((eq? c 'black) (display "@PenBlack;"))
            ((eq? c 'cream) (display "@PenCream;"))
            ((eq? c 'dkgray) (display "@PenDkGray;"))
            ((eq? c 'fuchsia) (display "@PenFuchsia;"))
            ((eq? c 'gray) (display "@PenGray;"))
            ((eq? c 'yellow) (display "@PenYellow;"))
            ((eq? c 'purple) (display "@PenPurple;"))
            ((eq? c 'maroon) (display "@PenMaroon;"))
            ((eq? c 'white) (display "@PenWhite;"))
            ((eq? c 'skyblue) (display "@PenSkyBlue;"))
            ((eq? c 'green) (display "@PenMoneyGreen;"))
            ((eq? c 'navy) (display "@PenNavy;"))
            ((eq? c 'silver) (display "@PenSilver;"))
            (else (error "undefined color: " c))))
    
    (define (red)
      (pen-color 'red))
    
    (define (blue)
      (pen-color 'blue))
    
    (define (aqua)
      (pen-color 'aqua))
    
    (define (black)
      (pen-color 'black))
    
    (define (cream)
      (pen-color 'cream))
    
    (define (dkgray)
      (pen-color 'dkgray))
    
    (define (fuchsia)
      (pen-color 'fuchsia))
    
    (define (gray)
      (pen-color 'gray))
    
    (define (yellow)
      (pen-color 'yellow))
    
    (define (purple)
      (pen-color 'purple))
    
    (define (maroon)
      (pen-color 'maroon))
    
    (define (white)
      (pen-color 'white))
    
    (define (skyblue)
      (pen-color 'skyblue))
    
    (define (green)
      (pen-color 'green))
    
    (define (navy)
      (pen-color 'navy))
    
    (define (silver)
      (pen-color 'silver))
    
    (define (pen-width i)
      (check-integer i)
      (display "@PenWidth ")
      (display i)
      (display ";"))
    
    
    
    (define (from-top n)
      (check-integer n)
      (display "@FromTop ")
      (display n)
      (display ";"))
    
    
    (define (from-left n)
      (check-integer n)
      (display "@FromLeft ")
      (display n)
      (display ";"))
    
));;ƒÉŒvZƒCƒ“ƒ^[ƒvƒŠƒ^ ver0.8 k.sasagawa
;;„‚Ì•×‹­—p‚É‘‚¢‚½‚à‚ÌBŠÈ–ñ‚Í•sŠ®‘SB
;;Normal‚Ì“®ìŠm”F—pB

(define (subst old new f)
  (cond ((null? f) '())
        ((equal? (car f) old) (cons new (subst old new (cdr f))))
        ((atom? (car f)) (cons (car f) (subst old new (cdr f))))
        (else (cons (subst old new (car f))(subst old new (cdr f))))))



;;ƒÉ®‚ÌƒŠƒXƒg•\Œ»
;; ƒÉx.M (lambda (x) M)
;; (ƒÉx.M)N ((lambda (x) M) N)
;; M (M1 M2) ((M1 M2) M3)
;; ‘½d’ŠÛ‚à‹–‚·‚±‚Æ‚Æ‚·‚éB
;; ((lambda (x) (lambda (y) (x y))) a b)
;; ((lambda (x y) (x y)) a b)

(define (lambda-term? f)
  (cond ((null? f) #t)
        ((symbol? f) #t) ;x0,x1...
        ((number? f) #t) ;1,2,3..”‚àƒÉ®‚Æ‚¢‚¤‚±‚Æ‚É‚·‚éB
        ((and (eq? (car f) 'lambda)(list? (cadr f))(lambda-term? (caddr f))) #t);ƒÉx.M
        ((and (lambda-term? (car f))(lambda-term? (cdr f))) #t) ;(M N)
        (else #f)))



;;ƒ¿•ÏŠ· ƒÉ®‚Ì’è‹`‚É‚µ‚½‚ª‚Á‚Äƒp[ƒXB
(define (alpha-convert f)
  (genvar 'reset)
  (reset-var)
  (alpha-convert1 f))

(define (alpha-convert1 f)
  (cond ((null? f) '())
        ((and (symbol? f)(bound? f)) (bound? f))
        ((and (symbol? f)(not(bound? f))) f)
        ((number? f) f)
        ((and (eq? (car f) 'lambda)(list? (cadr f)))
         (let ((new '()) (l '()))
           (push-var)
           (set! new (var-convert! (cadr f)))
           (set! l (list 'lambda new (alpha-convert1 (caddr f))))
           (pop-var)
           l))
        (else (cons (alpha-convert1 (car f))(alpha-convert1 (cdr f))))))

(define (var-convert! var)
  (define (iter old new)
    (if (null? old)
        (reverse new)
        (let ((v '()))
          (set! v (genvar 'gen))
          (bound! (car old) v)
          (iter (cdr old) (cons v new)))))
  (iter var '()))
                 

;;•Ï”ƒŠƒXƒg
;;((x . x1)(y . x2) ...)
(define var-assoc '())
(define stack '())

(define (bound? v)
  (let ((ans (assq v var-assoc)))
    (if ans
        (cdr ans)
        #f)))

(define (bound! old new)
  (set! var-assoc (cons (cons old new) var-assoc)))

(define (reset-var)
  (set! var-assoc '()))

(define (push-var)
  (set! stack (cons var-assoc stack)))

(define (pop-var)
  (set! var-assoc (car stack))
  (set! stack (cdr stack)))

;; •Ï”‚ğ¶¬‚·‚é
(define genvar
  (let ((x -1))
    (lambda (msg)
      (cond ((eq? msg 'gen)
             (begin (set! x (+ x 1))
                    (string->symbol (string-append "x" (number->string x)))))
            ((eq? msg 'reset)(set! x -1))))))


;;ƒÀŠî‚Ì”»’è (ƒÉx.M)N ŒvZ˜_p66
(define (beta-redex? f)
  (cond ((atom? f) #f)
        ((atom? (car f)) #f)
        ((and (eq? (caar f) 'lambda)
              (symbol? (caadar f))
              (lambda-term? (caddar f))
              (lambda-term? (cadr f))) #t)
        (else #f)))

;;(ƒÉx.M)N
;;((lambda (x) M) N)
;;ƒÀ³‹KŒ` ƒÀ-normal-form
(define (beta-normal-form? f)
  (cond ((not (lambda-term? f)) #f) 
        ((symbol? f) #t) ; x0,x1...
        ((number? f) #t) ; 1,2,3...
        ((and (list? f)(eq? (car f) 'lambda)
              (beta-normal-form? (caddr f))) #t) ;ƒÉx.x
        ((and (list? f)
              (symbol? (car f))
              (beta-normal-form? (cadr f))) #t) ;(x ƒÉx.x)
        ((and (list? f)(symbol? (car f))(symbol? (cadr f))) #t) ;(x0 x1)
        (else #f)))


;;ƒÀ•ÏŠ·
;;;; example ((lambda (x) (lambda (y) (x y))) a b)
(define (beta-reduce form)
  (cond ((= (length (cadar form)) 1)
         (beta-reduce1 (car form) (cdr form)))
        ((> (length (cadar form)) 1)
         (beta-reduce2 1 (car form) (cdr form)))))
  
(define (beta-reduce1 l m) ; l=(lambda (x) ...) m=(a b)
  (display (cons l m))(newline)
  (if (null? m)
      l
      (let ((var (caadr l))  
            (body (cddr l))) 
        (beta-reduce1 (car (subst var (car m) body)) (cdr m)))))

(define (beta-reduce2 n l m)
  (display (cons l m))(newline)
  (if (null? m)
      (caddr l)
      (let ((var (nth n (cadr l))))
        (beta-reduce2 (+ n 1) (subst var (car m) l) (cdr m)))))

(define (nth n l)
  (if (= n 1)
      (car l)
      (nth (- n 1) (cdr l))))

(define (reduce form)
  (if (lambda-term? form)
      (reduce1 (alpha-convert form))
      (error "Not lambda term" form)))

(define (reduce1 form)
  (display form)(newline)
  (cond ((beta-normal-form? form) form) ;ƒÀ-normal-form
        ((and (symbol? (car form))
              (beta-redex? (cadr form))) ;(x0 M)
         (reduce1 (list (car form) (reduce1 (cadr form)))))
        ((eq? (car form) 'lambda) ;ƒÉx.M
         (reduce1 (list (car form)
                        (cadr form)
                        (reduce1 (caddr form)))))
        ((eq? (caar form) 'lambda)
         (reduce1 (beta-reduce form))) ;(ƒÉx.x)M
        (else (error "Reduction error" form))))
               


;;ƒeƒXƒg—pƒf[ƒ^
(define foo '((lambda (x) x) (lambda (a) a)))
(define bar '((lambda (y) (y ((lambda (z) (x z)) (lambda (z) z)))) (lambda (a) a)))
(define baz '(x ((lambda (x) x) y)))
(define boo '((lambda (x) x) y))
(define uoo '((lambda (x) (lambda (y) x)) y))
(define uoo2 '((lambda (x) (lambda (z) x)) y))
(define woo '((lambda (x) (lambda (y) x)) z))
(define hoo '((lambda (x) (x x)) (lambda (x) (x x))))


(define t '((lambda (x y z w) (x y (z w))) a b c d))

;(define t '(lambda (x y) x))
(define f '(lambda (x y) y));;r7rs ƒ‰ƒCƒuƒ‰ƒŠ“®ìŠm”F

(define-library (scheme base)
  (export = + - * / < <= > >= (rename list fff)))

(define-library (test macro)
  (export foo fact)
  (import (scheme base)
          (normal user))
  (begin
    (define (foo x y) (fff x y))
    (define (fact n)
      (if (zero? n)
          1
          (* n (fact (- n 1)))))))








#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include <math.h>
#include "norm.h"

extern cell memory[];
extern jmp_buf toplevel;


//--------------ƒŠƒXƒg‘€ì---------------------
//ƒGƒ‰[ˆ—‚È‚µB(cdr '()) = '() “à•”ˆ—‚Åg‚¤B
int car(int lis){
	return(GET_CAR(lis));
}

int cdr(int lis){
	return(GET_CDR(lis));
}

//ƒGƒ‰[ˆ—‚ ‚èBSchemeƒŒƒxƒ‹‚Åg‚¤B
int scm_car(int lis){
	if(pairp(lis))
    	return(GET_CAR(lis));
    else
    	exception("car", NOT_PAIR, lis);
    return(undef);
}

int scm_cdr(int lis){
	if(pairp(lis))
    	return(GET_CDR(lis));
    else
    	exception("cdr", NOT_PAIR, lis);
    return(undef);
}

int caar(int lis){
	return(car(car(lis)));
}

int cdar(int lis){
	return(cdr(car(lis)));
}

int cadar(int lis){
	return(car(cdr(car(lis))));
}



int cddr(int lis){
	return(cdr(cdr(lis)));
}

int cdddr(int lis){
	return(cdr(cdr(cdr(lis))));
}

int cdadr(int lis){
	return(cdr(car(cdr(lis))));
}


int cadr(int lis){
	return(car(cdr(lis)));
}

int caddr(int lis){
	return(car(cdr(cdr(lis))));
}

int caadr(int lis){
	return(car(car(cdr(lis))));
}

int cadddr(int lis){
	return(car(cdr(cdr(cdr(lis)))));
}


int cons(int car, int cdr){
	int addr;

    addr = freshcell();
   	SET_TAG(addr,LIS);
    SET_CAR(addr,car);
    SET_CDR(addr,cdr);
    return(addr);
}

int assq(int obj, int lis){
	while(!nullp(lis))
    	if(eqp(obj,caar(lis)))
        	return(car(lis));
        else
        	lis = cdr(lis);
    return(BOOLF);
}

int assv(int obj, int lis){
	while(!nullp(lis))
    	if(eqvp(obj,caar(lis)))
        	return(car(lis));
        else
        	lis = cdr(lis);
    return(BOOLF);
}

int assoc(int obj, int lis){
	while(!nullp(lis))
    	if(equalp(obj,caar(lis)))
        	return(car(lis));
        else
        	lis = cdr(lis);
    return(BOOLF);
}

int memq(int obj, int lis){
	while(!nullp(lis))
    	if(eqp(obj,car(lis)))
        	return(lis);
        else
        	lis = cdr(lis);
    return(BOOLF);
}

int memv(int obj, int lis){
	while(!nullp(lis))
    	if(eqvp(obj,car(lis)))
        	return(lis);
        else
        	lis = cdr(lis);
    return(BOOLF);
}

int member(int obj, int lis){
	while(!nullp(lis))
    	if(equalp(obj,car(lis)))
        	return(lis);
        else
        	lis = cdr(lis);
    return(BOOLF);
}


int listtail(int lis, int n){
	while(!(nullp(lis))){
    	if(n == 0)
        	return(lis);
        else{
        	lis = cdr(lis);
            n--;
        }
    }
    if(n == 0)
    	return(NIL);
    else
    	return(BOOLF);
}

int listref(int lis, int n){
	while(!(nullp(lis))){
    	if(n == 0)
        	return(car(lis));
        else{
        	lis = cdr(lis);
            n--;
        }
    }
    return(BOOLF);
}

int drop(int lis, int n){
	while(!(nullp(lis))){
    	if(n == 0)
        	return(lis);
        else{
        	lis = cdr(lis);
            n--;
        }
    }
    return(undef);
}

int length(int lis){
	int len = 0;
    
    while(!(nullp(lis))){
    	len++;
        lis = cdr(lis);
    }
    return(len);
} 

int list(int arglist){
	if(nullp(arglist))
    	return(make_NIL());
    else
    	return(cons(car(arglist),list(cdr(arglist))));    
}

int list1(int x){
	return(cons(x,NIL));
}

int list2(int x, int y){
	return(cons(x,cons(y,NIL)));
}

int list3(int x, int y, int z){
	return(cons(x,cons(y,cons(z,NIL))));
}

int list4(int x1, int x2, int x3, int x4){
	return(cons(x1,cons(x2,cons(x3,cons(x4,NIL)))));
}

int list5(int x1, int x2, int x3, int x4, int x5){
	return(cons(x1,cons(x2,cons(x3,cons(x4,cons(x5,NIL))))));
}

int list6(int x1, int x2, int x3, int x4, int x5, int x6){
	return(cons(x1,cons(x2,cons(x3,cons(x4,cons(x5,cons(x6,NIL)))))));
}

int list7(int x1, int x2, int x3, int x4, int x5, int x6, int x7){
	return(cons(x1,cons(x2,cons(x3,cons(x4,cons(x5,cons(x6,cons(x7,NIL))))))));
}

int list8(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8){
	return(cons(x1,cons(x2,cons(x3,cons(x4,cons(x5,cons(x6,cons(x7,cons(x8,NIL)))))))));
}

int listcopy(int lis){
	if(nullp(lis))
    	return(NIL);
    else
    	return(cons(car(lis),listcopy(cdr(lis))));
}

int reverse(int lis){
	int addr;
    
    addr = NIL;
	while(!(nullp(lis))){
    	addr = cons(car(lis),addr);
        lis = cdr(lis);
    }
	return(addr);
}

int reverse2(int lis){
	int x,addr;
    
    addr = NIL;
	while(!(nullp(lis))){
        x = cdr(lis);
        SET_CDR(lis,addr);
        addr = lis;
        lis = x;
    }
	return(addr);
}

int	last(int lis){
    
    while(!nullp(cdr(lis)))
    	lis = cdr(lis);
    
    return(car(lis));
}

int butlast(int lis){
	int res;
    
    res = NIL;
    while(!nullp(cdr(lis))){
    	res = cons(car(lis),res);
        lis = cdr(lis);
    }
    return(reverse2(res));
}
	

int atomp(int x){
    if(numberp(x) || symbolp(x) || charp(x) || stringp(x) || booleanp(x) || identifierp(x)
                  || IS_SYNCLO(x))
    	return(1);
    else
    	return(0);
}


int symbolp(int x){
    if(0 <= x && x <= CELLSIZE){
    	if(IS_SYMBOL(x))
    		return(1);
   		else
    		return(0);
    }
    else
    	return(0);
}

//nil‚ğ‹óƒŠƒXƒg‚Æ‰ğß‚µ‚Ä‚¢‚éB
int listp(int x){
	if(0 <= x && x <= CELLSIZE){	
    	if(IS_LIST(x) && (!(improperp(x))))
    		return(1);
    	else
    	if(IS_NIL(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int stringp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_STRING(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int charp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_CHARACTER(x))
    		return(1);
    	else
    		return(0);
    	}
    	else
    		return(0);
}

int improperp(int x){
	if(0 <= x && x <= CELLSIZE){
		while(!(nullp(x))){
    		if(atomp(cdr(x)))
        		return(1);
        	x = cdr(x);
    	}
    	return(0);
    }
    else
    	return(0);
}

int pairp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_LIST(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int nullp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_NIL(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int booleanp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_BOOL(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int procedurep(int x){
	if(0 <= x && x <= CELLSIZE){
		if((IS_SUBR(x)) || (IS_CLOSURE(x)) || (IS_CONT(x)))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int multvalp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_MULTVAL(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int vectorp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_VECTOR(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int identifierp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_IDENTIFIER(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int syntactic_closurep(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_SYNCLO(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);

}

int equalp(int x1, int x2){
	int i,n;
    
	if(integerp(x1) && integerp(x2)){
     	if(x1 == x2)
    		return(1);
        else
        	return(0);
    }
	if(nullp(x1) && nullp(x2))
    	return(1);
    if((nullp(x1) && !nullp(x2)) || (!nullp(x1) && nullp(x2)))
    	return(0);
	if(numberp(x1) && numberp(x2) && numeqp(x1,x2))
    	return(1);
    if(vectorp(x1) && vectorp(x2)){
    	if(vector_length(x1) != vector_length(x2))
        	return(0);
        n = vector_length(x1);
        for(i=0; i<n; i++)
        	if(!eqvp(GET_VEC_ELT(x1,i),GET_VEC_ELT(x2,i)))
            	return(0);
        return(1);	
    }
	if(atomp(x1) && atomp(x2))
    	return(eqvp(x1,x2));
    if(equalp(car(x1),car(x2)))
    		return(equalp(cdr(x1),cdr(x2)));
    else
    	return(0);
}
    	



int subrp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_SUBR(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int closurep(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_CLOSURE(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int continuationp(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_CONT(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

//ƒ}ƒNƒ‚Ì–¼‘O‚©‚Ç‚¤‚©H

int macro_namep(int sym){
	int addr;
    
    if(symbolp(sym) && IS_MACRO(GET_CAR(sym)))
    	return(1);
    else
    if(identifierp(sym)){
    	addr = identifier_to_symbol(sym);
        if(IS_MACRO(GET_CAR(addr)))
        	return(1);
        else
        	return(0);
    }
    else
    	return(0);
}


int hygienic_namep(int sym){
	int addr;
    
    if(symbolp(sym) && IS_HYGIENIC(GET_CAR(sym)))
    	return(1);
    else
    if(identifierp(sym)){
    	addr = identifier_to_symbol(sym);
        if(IS_HYGIENIC(GET_CAR(addr)))
        	return(1);
        else
        	return(0);
    }
    else
    	return(0);
}


int macrop(int x){
	if(0 <= x && x <= CELLSIZE){
		if(IS_MACRO(x))
    		return(1);
    	else
    		return(0);
    }
    else
    	return(0);
}

int setcar(int x, int y){
	SET_CAR(x,y);
    return(x);
}

int setcdr(int x, int y){
	SET_CDR(x,y);
    return(x);
}

int append(int x, int y){
	if(nullp(x))
    	return(y);
    else
    	return(cons(car(x),append(cdr(x),y)));
}

int append2(int x, int y){
	int res;
    
    res = x;
    while(!(nullp(cdr(x))))
    	x = cdr(x);
    
    setcdr(x,y);
    return(res);
}

L     Â?  f     .text               ì)      ï    0`.data                               @ 0À.bss                                € 0À.rdata                             @ 0@.drectve        D  (               @ 0À/4              €  l!  B=      @   @ 0@‹D$Áà‹€    Ãf‹D$Áà‹€   Ãfƒì‹D$ = -1w‰ÂÁâƒº   t$‰D$ÇD$   Ç$    è    ¡    ƒÄÃv ‹‚    ƒÄÃfƒì‹D$ = -1w‰ÂÁâÂ    ƒzt!‰D$ÇD$   Ç$   è    ¡    ƒÄÃ‹BƒÄÃ‹D$Áà‹€    Áà‹€    Ã‹D$Áà‹€    Áà‹€   Ã‹D$Áà‹€    Áà‹€   Áà‹€    Ã‹D$Áà‹€   Áà‹€   Ã‹D$Áà‹€   Áà‹€   Áà‹€   Ã‹D$Áà‹€   Áà‹€    Áà‹€   Ã‹D$Áà‹€   Áà‹€    Ã‹D$Áà‹€   Áà‹€   Áà‹€    Ã‹D$Áà‹€   Áà‹€    Áà‹€    Ã‹D$Áà‹€   Áà‹€   Áà‹€   Áà‹€    Ãv Sƒìè    ‰ÁÁá‘    Ç      ‹\$‰™    ‹L$‰JƒÄ[ÃVSƒì‹t$ ‹D$$ë,Áà˜    ‹€    Áà‹€    ‰D$‰4$è    …Àu$‹C= -1wÎ‰ÂÁâƒº   uÀ¸   ƒÄ[^Ã‹ƒÄ[^ÃVSƒì‹t$ ‹D$$ë,Áà˜    ‹€    Áà‹€    ‰D$‰4$è    …Àu$‹C= -1wÎ‰ÂÁâƒº   uÀ¸   ƒÄ[^Ã‹ƒÄ[^ÃWVSƒì‹|$ ‹\$$ë$‰ØÁà°    ‹€    ‰D$‰<$è    …Àu‹^û -1wÔ‰ØÁàƒ¸   uÆ»   ‰ØƒÄ[^_ÃWVSƒì‹|$ ‹\$$ë$‰ØÁà°    ‹€    ‰D$‰<$è    …Àu‹^û -1wÔ‰ØÁàƒ¸   uÆ»   ‰ØƒÄ[^_Ã‹D$‹T$ëf…Òt,Áà‹€   J= -1wë‰ÁÁáƒ¹   uİƒúÀ÷ĞƒàÃfÃv ‹D$‹T$ëf…Òt(Áà‹€   J= -1wë‰ÁÁáƒ¹   uİ¸   Ãv Áà‹€    Ãf‹D$‹T$ëf…Òt(Áà‹€   J= -1wë‰ÁÁáƒ¹   uİ¡    Ãv Ãv ‹T$1Àú -1w‰ÑÁáƒ¹   t @Áâ‹’   ú -1wî‰ÑÁáƒ¹   uàÃv UWVSƒìL‹\$`û -1w‰ØÁàƒ¸   „“  ‰ØÁà‹°   ş -1w‰ğÁàƒ¸   „z  ‰ğÁà‹¸   ÿ -1ws‰øÁàƒ¸   ueè    ‰ÇfÁæ‹®    è    ‰Æ‰ÂÁâÇ‚      ‰ª    ‰º   Áã‹›    è    ‰ÁÁá‘    ÇB   ‰™    ‰rƒÄL[^_]Ã‰øÁà‹¨   ı -1w‰èÁàƒ¸   „  ‰èÁà‹   ú -1w‰ĞÁàƒ¸   „Ş  ‰ĞÁà‹€   ‰D$(= -1†œ  ‹D$(Áà‹€   ‰D$,= -1wÁàƒ¸   „¸  ‹D$,Áà‹€   ‰D$0= -1wÁàƒ¸   „¦  ‹D$0Áà‹ˆ   ù -1w‰ÈÁàƒ¸   „•  Áá‹   ‰$‰T$ ‰L$$è<şÿÿ‰D$8‹L$$‹‰    ‰L$<è    ‰D$4Áà‰D$    ‰D$Ç@   ‹L$<‹D$‰ˆ    ‹L$8‹D$‰H‹T$ ‹D$0Áà‹€    ‰D$8‰T$ è    ‰D$0Áà‰D$<    ‰D$Ç@   ‹L$8‹D$<‰ˆ    ‹L$4‹D$‰H‹T$ ‹D$,Áà‹€    ‰D$4‰T$ è    ‰D$,Áà‰D$8    ‰D$<Ç@   ‹L$4‹D$8‰ˆ    ‹L$0‹D$<‰H‹T$ ‹D$(Áà‹€    ‰D$0‰T$ è    ‰D$(Áà‰D$4    ‰D$8Ç@   ‹L$0‹D$4‰ˆ    ‹L$,‹D$8‰H‹T$ Áâ‹’    ‰T$,è    ‰D$0‰ÂÁâ‚    Ç‚      ‹L$,‰Š    ‹T$(‰PÁå‹­    ‰l$(è    ‰Å‰ÁÁá    Ç      ‹T$(‰‘    ‹L$0‰HÁç‹—    ‰T$ è    ‰Ç‰ÁÁáÇ      ‹T$ ‰‘    ‰©   é½üÿÿƒÄL[^_]é    è    ‰ÆéÏüÿÿÁàƒ¸   …Tıÿÿ‰T$ è    ‰D$(‹T$ éÿÿÿfè    ‰D$0é?ÿÿÿfè    ‰Åékÿÿÿ‰T$ è    ‰D$,‹T$ éşÿÿ‰T$ è    ‰D$0‹T$ é%şÿÿ‰T$ è    ‰D$4‹T$ é½ıÿÿfSƒìè    ‰ÁÁáÇ      ‹\$‰™    Ç       ƒÄ[Ãv VSPè    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    Ç‚       è    ‰ÁÁáÇ      ‹t$‰±    ‰™   Z[^Ãv VSQè    ‰Æ‰ÂÁâÇ‚      ‹L$‰Š    Ç‚       è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰ÁÁáÇ      ‹t$‰±    ‰™   [[^ÃVSVè    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    Ç‚       è    ‰Æ‰ÂÁâÇ‚      ‹L$‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰ÁÁáÇ      ‹t$‰±    ‰™   Z[^Ãv VSQè    ‰Æ‰ÂÁâÇ‚      ‹L$ ‰Š    Ç‚       è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰Æ‰ÂÁâÇ‚      ‹L$‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰ÁÁáÇ      ‹t$‰±    ‰™   [[^ÃVSVè    ‰Ã‰ÂÁâÇ‚      ‹L$$‰Š    Ç‚       è    ‰Æ‰ÂÁâÇ‚      ‹L$ ‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰Æ‰ÂÁâÇ‚      ‹L$‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰ÁÁáÇ      ‹t$‰±    ‰™   Z[^Ãv VSQè    ‰Æ‰ÂÁâÇ‚      ‹L$(‰Š    Ç‚       è    ‰Ã‰ÂÁâÇ‚      ‹L$$‰Š    ‰²   è    ‰Æ‰ÂÁâÇ‚      ‹L$ ‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰Æ‰ÂÁâÇ‚      ‹L$‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰ÁÁáÇ      ‹t$‰±    ‰™   [[^ÃVSVè    ‰Ã‰ÂÁâÇ‚      ‹L$,‰Š    Ç‚       è    ‰Æ‰ÂÁâÇ‚      ‹L$(‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$$‰Š    ‰²   è    ‰Æ‰ÂÁâÇ‚      ‹L$ ‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰Æ‰ÂÁâÇ‚      ‹L$‰Š    ‰š   è    ‰Ã‰ÂÁâÇ‚      ‹L$‰Š    ‰²   è    ‰ÁÁáÇ      ‹t$‰±    ‰™   Z[^Ãv UWVSƒìL‹\$`û -1w‰ØÁàƒ¸   „›  ‰ØÁà‹°   ş -1wD‰ğÁàƒ¸   u61öÁã‹›    è    ‰ÁÁáÇ      ‰™    ‰±   ƒÄL[^_]Ãv ‰ğÁà‹¸   ÿ -1w‰øÁàƒ¸   „G  ‰øÁà‹¨   ı -1†  ‰èÁà‹   ú -1w‰ĞÁàƒ¸   „  ‰ĞÁà‹€   ‰D$(= -1wÁàƒ¸   „ö  ‹D$(Áà‹€   ‰D$,= -1wÁàƒ¸   „Û  ‹D$,Áà‹€   ‰D$0= -1wÁàÇD$4    ƒ¸   „å   ‹D$0Áà‹ˆ   ù -1w‰ÈÁàÇD$8    ƒ¸   thÁá‹   ‰$‰T$ ‰L$$èaşÿÿ‰D$4‹L$$‹‰    ‰L$<è    ‰D$8Áà‰D$    ‰D$Ç@   ‹L$<‹D$‰ˆ    ‹L$4‹D$‰H‹T$ ‹D$0Áà‹€    ‰D$0‰T$ è    ‰D$4Áà‰D$<    ‰D$Ç@   ‹L$0‹D$<‰ˆ    ‹L$8‹D$‰H‹T$ ‹D$,Áà‹€    ‰D$,‰T$ è    ‰D$0Áà‰D$8    ‰D$<Ç@   ‹L$,‹D$8‰ˆ    ‹L$4‹D$<‰H‹T$ ‹D$(Áà‹€    ‰D$(‰T$ è    ‰D$,Áà‰D$4    ‰D$8Ç@   ‹L$(‹D$4‰ˆ    ‹L$0‹D$8‰H‹T$ Áâ‹Š    ‰L$$è    ‰D$(‰ÂÁâ‚    Ç‚      ‹L$$‰Š    ‹T$,‰PÁå‹•    ‰T$ è    ‰Å‰ÁÁá    Ç      ‹T$ ‰‘    ‹L$(‰HÁç‹—    ‰T$ è    ‰Ç‰ÁÁáÇ      ‹T$ ‰‘    ‰©   Áæ‹®    è    ‰Æ‰ÂÁâÇ‚      ‰ª    ‰º   é‹üÿÿv 1ÀƒÄL[^_]Ãf‰èÁàƒ¸   …Úüÿÿ1íéuÿÿÿv 1ÿë¡ÇD$(    é'ÿÿÿÇD$,    éŞşÿÿÇD$0    éşÿÿWVS‹T$1Ûú -1w‰ĞÁàƒ¸   tJÁâ²    ‹º    è    ‰ÁÁáÇ      ‰¹    ‰™   ‹V‰Ãú -1wÄ‰ĞÁàƒ¸   u¶‰Ø[^_ÃS‹T$1Àú -1w‰ÑÁáƒ¹   t+‰ÑÁá‹™   ‰   ‰Ğ‰Úú -1wã‰ÑÁáƒ¹   uÕ[Ãf‹D$Áà    ‹€   = -1wê‰ÁÁáƒ¹   uÜ‹ÃWVS‹T$1Ûv ‰ĞÁà‹€   = -1wÁàƒ¸   t6Áâ²    ‹º    è    ‰ÁÁáÇ      ‰¹    ‰™   ‹V‰Ãë¬1Àû -1w‰ÚÁâƒº   t+‰ÚÁâ‹Š   ‰‚   ‰Ø‰Ëû -1wã‰ÚÁâƒº   uÕ[^_ÃSƒì‹\$ ‰$è    …Àu,û -1w0Áã‹ƒ   ƒøtƒøtƒøtƒøtƒøuf¸   ƒÄ[ÃfÁã‹ƒ   ƒø”À¶Àëå‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃVSƒì‹\$ û -1w‰ØÁà‹€   ƒøtH”À¶ÀƒÄ[^Ãf1ÀƒÄ[^Ã‰ŞëÁæÆ    ‹F‰$è0ÿÿÿ…Àu ‹vş -1wİ‰ğÁàƒ¸   uÏ¸   ë´Áã‹ƒ   ë¢‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃSƒì‹\$ û -1w@‰ØÁàƒ¸   uë0‹[û -1våÁãÃ    ‹C‰$èşÿÿ…Àtİ¸   ƒÄ[Ãv 1ÀƒÄ[Ã‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$= -1wÁà‹€   ƒøtƒøtƒø”À¶ÀÃ1ÀÃ¸   Ãf¸   Ãf‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$= -1wÁàƒ¸   	”À¶ÀÃ1ÀÃ‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃUWVSƒì,‹\$@‹t$Dé¤   û -1w‰ØÁàƒ¸   „*  ş -1w‰ğÁàƒ¸   „Ğ   ‰$è    …À…Ì   û -1w‰ßÁçƒ¿   	tv‰$èÖüÿÿ…Àt‰4$èÊüÿÿ…À…ë   Áæ‹†    ‰D$Áã‹ƒ    ‰$èXÿÿÿ…Àtl‹¶   ‹›   ‰$è    …À„Lÿÿÿ‰4$è    …À„<ÿÿÿ1À9ó”Àë9v ş -1w‚‰õÁåƒ½   	…pÿÿÿ‰$è    ‰D$‰4$è    9D$tt1ÀƒÄ,[^_]Ãf‰4$è    …À„$ÿÿÿ‰t$‰$è    …À„ÿÿÿ¸   ƒÄ,[^_]Ãv ş -1w¸‰ğÁàƒ¸   tÚu¨éÓşÿÿ‰t$D‰\$@ƒÄ,[^_]é    v ‰$è    ‰Æ…À~®1ÛëfC9ót£    ‹•    ‹‰T$‹—    ‹‰$è    …ÀuÒéEÿÿÿWVSƒì‹|$ ‹\$$ë$‰ØÁà°    ‹€    ‰D$‰<$èÿıÿÿ…Àu‹^û -1wÔ‰ØÁàƒ¸   uÆ»   ‰ØƒÄ[^_ÃVSƒì‹t$ ‹D$$ë,Áà˜    ‹€    Áà‹€    ‰D$‰4$è ıÿÿ…Àu$‹C= -1wÎ‰ÂÁâƒº   uÀ¸   ƒÄ[^Ã‹ƒÄ[^Ã‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃƒì‹D$ = -1w‰ÁÁá‹‘   ƒútƒút%1ÀƒÄÃv ‹    Áàƒ¸   ”À¶ÀƒÄÃf‰$è    Áà‹€    Áàƒ¸   ”À¶ÀƒÄÃv ƒì‹D$ = -1w‰ÁÁá‹‘   ƒútƒút%1ÀƒÄÃv ‹    Áàƒ¸   ”À¶ÀƒÄÃf‰$è    Áà‹€    Áàƒ¸   ”À¶ÀƒÄÃv ‹D$= -1wÁàƒ¸   ”À¶ÀÃ1ÀÃ‹D$‰ÂÁâ‹L$‰Š    Ã‹D$‰ÂÁâ‹L$‰Š   ÃUWVSƒìL‹\$`‹t$dû -1w‰ØÁàƒ¸   tN‰ØÁà‹¸   ÿ -1wH‰øÁàƒ¸   u:‰÷Áã‹›    è    ‰Æ‰ÂÁâÇ‚      ‰š    ‰º   ‰ğƒÄL[^_]Ãv ‰øÁà‹¨   ı -1w‰èÁàƒ¸   „ã  ‰èÁà‹   ú -1†ü  ‰ĞÁà‹€   ‰D$(= -1wÁàƒ¸   „?  ‹D$(Áà‹€   ‰D$,= -1wÁàƒ¸   „Æ  ‹D$,Áà‹€   ‰D$0= -1wÁàƒ¸   „Q  ‹D$0Áà‹€   ‰D$4= -1wÁà‰t$8ƒ¸   „Õ   ‹D$4Áà‹ˆ   ù -1w‰ÈÁàƒ¸   td‰t$‰ÎÁæ‹†   ‰$‰T$$èdşÿÿ‰D$8‹¶    ‰t$<è    ‰ÆÁà‰D$     ‰D$Ç@   ‹D$<‹L$ ‰    ‹D$8‹L$‰A‹T$$‹D$4Áà‹€    ‰D$4‰T$$è    ‰D$8Áà‰D$<    ‰D$ Ç@   ‹D$4‹L$<‰    ‹L$ ‰q‹T$$‹D$0Áà‹€    ‰D$0‰T$$è    ‰ÆÁà‰D$4    ‰D$<Ç@   ‹D$0‹L$4‰    ‹D$8‹L$<‰A‹T$$‹D$,Áà‹€    ‰D$0‰T$$è    ‰D$,Áà‰D$4    ‰D$8Ç@   ‹D$0‹L$4‰    ‹L$8‰q‹T$$‹D$(Áà‹€    ‰D$(‰T$$è    ‰ÆÁà‰D$0    ‰D$4Ç@   ‹D$(‹L$0‰    ‹D$,‹L$4‰A‹T$$Áâ‹Š    ‰L$$è    ‰D$(‰ÂÁâÇ‚      ‹L$$‰Š    ‰²   Áå‹­    è    ‰Æ‰ÂÁâ‚    Ç‚      ‰ª    ‹T$(‰PÁç‹¯    è    ‰Ç‰ÂÁâÇ‚      ‰ª    ‰²   éüÿÿ‰ĞÁàƒ¸   …òüÿÿ‰t$(ë†‰t$,éøşÿÿv S‹D$‰ÂÁâŠ    ‹’   ú -1wé‰ÓÁãƒ»   uÛ‹T$‰Q[Ãcar cdr  -aligncomm:"_empty_set",2 -aligncomm:"_end_of_file",2 -aligncomm:"_undef",2 -aligncomm:"_unquote_splicing",2 -aligncomm:"_unquote",2 -aligncomm:"_quasiquote",2 -aligncomm:"_quote",2 -aligncomm:"_dyna_env_p2",2 -aligncomm:"_dyna_env_p1",2 -aligncomm:"_cell_hash_table",5 -aligncomm:"_cell_free",2 -aligncomm:"_cell_heap_p",2       zR |ˆ                     0                D   $   J    C y
DI      d   p   G    C |
AF      „   ¸             ˜   Ğ             ¬   è              À               Ô                 è   @             ü   `              x             $  ˜             8  ¸  )          L  ä  4    AƒCnAÃ4   l    d    A†AƒC S
AÃAÆBEAÃAÆ4   ¤  |  d    A†AƒC S
AÃAÆBEAÃAÆ0   Ü  à  X    A‡A†AƒC NAÃAÆAÇ 0     8  X    A‡A†AƒC NAÃAÆAÇ    D    =          X  Ğ  B          l    9          €  P  =       T   ”    V   A…A‡A†AƒC`Ä
AÃAÆAÇAÅAë
AÃAÆAÇAÅE    ì  è  1    AƒCkAÃ(     	  U    A†AƒAOAÃAÆ  (   8  t	  {    A†AƒAuAÃAÆ  (   d  ğ	  ¡    A†AƒA›AÃAÆ  (     ”
  Ç    A†AƒAÁAÃAÆ  (   ¼  \  í    A†AƒAçAÃAÆ  (   è  L     A†AƒAAÃAÆ (     `  9   A†AƒA3AÃAÆ T   @  œ     A…A‡A†AƒC`m
AÃAÆAÇAÅDI
AÃAÆAÇAÅC ,   ˜  °  o    A‡A†AƒiÃAÆAÇ      È     J    AƒHÃ    ä  l  +       ,   ø  ˜  §    A‡A†Aƒ¡ÃAÆAÇ       (  @  `    AƒC D
AÃC   L            8   `  À      A†AƒC f
AÃAÆCE
AÃAÆA     œ  @            °  `         (   Ä  €  W    AƒC G
AÃDEAÃ    ğ  Ø              ø                          ,  8  :          @  t            T  ”            h  ´            |  Ô         h     ô  Ó   A…A‡A†AƒC@
AÃAÆAÇAÅCl
AÃAÆAÇAÅDh
AÃAÆAÇAÅH0   ü  È  X    A‡A†AƒC NAÃAÆAÇ 4   0     d    A†AƒC S
AÃAÆBEAÃAÆ   h  „            |  ¤              Ä             ¤  ä  m    C e
DY
Cd     È  T;;ƒ}ƒNƒƒeƒXƒg

(define (fact-let n)
  (let loop((n1 n) (p n))
    (if (= n1 1)                    
        p
        (loop (- n1 1) (* p (- n1 1))))))     

(define (fact-letrec n)
  (letrec ((iter (lambda (n1 p)
                   (if (= n1 1)
                       p
                       (let ((m (- n1 1)))
                         (iter m (* p m)))))))
    (iter n n)))

(define (fact-do n)
  (do ((n1 n (- n1 1)) (p n (* p (- n1 1)))) ((= n1 1) p)))

(define (remove x ls)
  (let loop((ls0 ls) (ls1 ()))
    (if (null? ls0) 
        (reverse ls1)
        (loop
          (cdr ls0)
          (if (eqv? x (car ls0))
              ls1
              (cons (car ls0) ls1))))))

(define (my-reverse-let ls)
  (let loop((ls0 ls) (ls1 ()))
    (if (null? ls0)
        ls1
        (loop (cdr ls0) (cons (car ls0) ls1)))))
// Normal Scheme compiler

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <setjmp.h>
#include <windows.h>
#include <signal.h>
#include <math.h>
#include <time.h>
#include "norm.h"


cell memory[CELLSIZE];
token stok = {GO,OTHER};
jmp_buf toplevel;
int asmflag = 0;
int gbcflag = 0;
int loadflag = 0;
int profflag = 0;
int stepflag = 0;
int contflag = 0;
int exitflag = 0;
int initflag = 1;
int debugflag = 0;
int safeflag = 0;
int step_on = 0;
int prof_on = 0;
clock_t gctime;
clock_t start_time;
clock_t end_time;
FILE *input_port;
FILE *output_port;
int genint = 1;

int pc; // program counter
int sp; //stack pointer
int env; //environment
int n_args; 
int head; //head of code address
int tail; //tail ofcode address 
int code[CODESIZE];
int stack[STACKSIZE];
int emem1[ENVSIZE];
int emem2[ENVSIZE2];
int code_pointer[CLOSIZE][2]; 
int code_pointer_end = 0;
int trace_list = NIL; //closures to trace
int current_module = 2; //(normal compile)
int module_table[MODULESIZE][2]; //[0]= symbol, [1]=export_list
int module_table_end;
int export_id;
int export_sym;
int export_rename;
int back_trace[TRACE_DEPTH][2];
int back_trace_end = 0;
int cont_count = 0;


//------vm2‹N“®‚Ìƒf[ƒ^•Û‘¶—p------

int s_pc; // program counter
int s_sp; //stack pointer
int s_env; //environment
int s_n_args; 
int s_head; //head of code address
int s_tail; //tail ofcode address 
int s_code[CODESIZE];
int s_stack[STACKSIZE];
int s_code_pointer[CLOSIZE][2]; 
int s_code_pointer_end = 0;

//------main-----------------------
int main( int argc, char *argv[] ){
	int addr,sexp,i;
    char szPath[128],szDrive[4],szDir[128],szFileName[32],szExt[4];
    char initfile[128],compfile[128],normfile[128],kidsfile[128];
    char *p;
	

    printf("Scheme compiler Normal Ver 2013.5.7 (written by Kenichi.Sasagawa)\n");
    initcell();
    initsubr();
    initsyntax();
    initmodule();
    init_r7rs();
    SetConsoleCtrlHandler(NULL, FALSE ); //CTRL+C‚ğ—LŒø‚É‚·‚éB
    SetConsoleCtrlHandler(CtrlHandler, TRUE );
    //‰Šú‰»ƒtƒ@ƒCƒ‹‚Ìƒtƒ‹path‚ğ¶¬
    memset(szPath,0,sizeof(szPath));
	memset(szDrive,0,sizeof(szDrive));
	memset(szDir,0,sizeof(szDir));
	memset(szExt,0,sizeof(szExt));
    memset(initfile,0,sizeof(initfile));
    memset(compfile,0,sizeof(compfile));
    memset(normfile,0,sizeof(normfile));
    memset(kidsfile,0,sizeof(kidsfile));
    GetModuleFileName(NULL, szPath, sizeof(szPath));
	_splitpath(szPath, szDrive, szDir, szFileName, szExt);
	
    _makepath(initfile,szDrive, szDir, "initlib", "o"); 
    _makepath(compfile,szDrive, szDir, "ncomp", "o");
    for(i=0; i<argc; i++){
    	p=argv[i];
        	if(*p=='-'){  /* ƒIƒvƒVƒ‡ƒ“‚Ìˆø” */
        		p++;
                switch(*p){
                	case '2': /* -T(tail compiler2) */
						_makepath(compfile,szDrive, szDir, "xcomp", "o"); 
                    	break;
                	case '1': /* -R(recursive compiler1) */
                    	_makepath(compfile,szDrive, szDir, "ncomp", "o");
                    	break;
                    case 'S': /*ƒZ[ƒtƒ‚[ƒh*/
                    	safeflag = 1;
                        break;
                }
           }
       }
    _makepath(normfile,szDrive, szDir, "normmacs", "o");
    _makepath(kidsfile,szDrive, szDir, "kids", "scm"); 
    
    
    int ret = setjmp(toplevel);
    fflush(stdin);
    
    //----‰Šúƒtƒ@ƒCƒ‹‚ğ“Ç‚İ‚Ş-----------
    if(initflag == 1 && safeflag == 0){
    	pc = 0;
        sp = 0;
        tail = 0;
        stepflag = 0;
        back_trace_end = 0;
        push_s(make_str(compfile));
        f_load(1);
		//push_s(make_str(normfile));
        //f_load(1);
		//Å’áŒÀ•K—v‚Ècompile,assemble,compile-file‚ğ(normal user)‚Éexport‚·‚éB
        export_id = list3(make_sym("compile"),make_sym("assemble"),make_sym("compile-file"));
        current_module = 0;
        while(!nullp(export_id)){
        		export_sym = car(export_id);
            	SET_CAR(remake(export_sym),GET_CAR(export_sym));
            	export_id = cdr(export_id);
        }
        push_s(make_str(initfile));
        f_load(1);
        //push_s(make_str(kidsfile));
        //f_load(1);
        initflag = 0;
    }    
    
    repl:
	
    if(ret == 0)
    	while(1){
            input_port = stdin;
            output_port = stdout;
            loadflag = 0;
            contflag = 0;
        
            if(!debugflag)
            	printf("norm> ");
            else
            	printf("debug> ");
            fflush(stdout);
            sexp = read();
            
            pc = 0;
        	sp = 0;
            env = make_env(0,0);
			tail = 0;
			gctime = 0;
            if(!safeflag){
            	print(eval(sexp));
            }
            else{
            	if(eqvp(sexp,make_sym("q")))
                	return 0;
            	list_to_code(sexp);
                stepflag = 1;
                print(vm2());
            }
            printf("\n"); fflush(stdout);
		
        }
    else
    	if(ret == 1){
        	ret = 0;
            goto repl;
        }
        else{
    		for(addr=0; addr<= CELLSIZE; addr++)
    			free(memory[addr].name);
			printf("- good bye. -\n");
			return 0;
        }
}
//-----eval-------------------
int eval(int x){
	int arg1,arg2,res,savehead,savetail,savepc,savesp;
    
	savehead = head;
    savetail = tail;
    savepc = pc;
    savesp = sp;
    
	//(set! arg1 (asm (compile x)))‘Š“–‚ÌVM‹@ŠBŒê‚ğ¶¬B
    
    arg1 = cons(make_int(2),
    	cons(x,
         cons(make_int(4),
          cons(make_sym("compile"),
           cons(make_int(13),
             cons(make_int(1),
              cons(make_int(4),
               cons(make_sym("assemble"),
                cons(make_int(13),
                 cons(make_int(1),
                  cons(make_int(1),NIL)))))))))));	
        	
    //ƒAƒZƒ“ƒuƒ‹‚µ‚ÄVM‹@ŠBŒê‚ğ“¾‚éB
    list_to_code(arg1);
    pc = head;
    arg2 = vm1();
        
         
    //‚»‚Ì‹@ŠBŒê‚ğƒR[ƒh—Ìˆæ‚É“WŠJ‚µ‚ÄVMÀsB
    head = savehead;
    tail = savetail;
    list_to_code(arg2);
    pc = head;
    
    if(!debugflag)
    	res = vm1();
    else{
    	back_trace_end = 0;
		if(prof_on)
        	profflag = 1;
        if(step_on)
        	stepflag = 1;
		res = vm2();
        profflag = 0;
        stepflag = 0;
    }
	pc = savepc;
    sp = savesp;  
    return(res);
}


//-----ctrl+C,D---------------
BOOL WINAPI CtrlHandler(DWORD CtrlEvent){
	switch(CtrlEvent){
		case CTRL_C_EVENT:		exitflag = 1;
        						return TRUE;
        case CTRL_BREAK_EVENT:	exitflag = 2;
        						return TRUE;
        default:        		return FALSE;
    }
}


//---------error-----------

void exception(char *fn, int code, int arg){
	int i;
    
	switch(code){
    	case UNBOUND_VARIABLE:	printf("Exception: variable ");
        						print(arg); printf(" is not bound\n");
                                break;
		case CANT_READ:			printf("Exception: expr ");
        						print(arg); printf(" is not readable\n");
                                break;
        case CANT_OPEN:			printf("Exception in %s: ",fn);
        						print(arg); printf(" is not exist\n");
                                break;
        case VM_ILLEGAL_CODE:	printf("Exception in VM :");
        						print(arg); printf(" is illegal op code\n");
                                break;
        case LACK_CELL:			printf("Exception: lack of cell\n");
								gbc();
        						break;
        case LACK_VEC:			printf("Exception: lack of vector\n");
        						break;
    	case NOT_PAIR:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is not pair\n");
                                break;
        case NOT_NUMBER:		printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a number\n");
                                break;
        case NOT_INTEGER:		printf("Exception in %s: ", fn);
        						print(arg); printf(" is not an integer\n");
                                break;
        case NOT_EXACT:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is not an exact nonnegative number\n");
                                break;                        
        case NOT_REAL:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a real number\n");
                                break;
        case NOT_SYMBOL:		printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a symbol\n");
                                break;
        case NOT_STRING:		printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a string\n");
                                break;
        case NOT_CHAR:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a character\n");
                                break;
        case NOT_PORT:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a port\n");
                                break;
        case NOT_PROCEDURE:		printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a procedure\n");
                                break;
        case NOT_CLOSURE:		printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a closure\n");
                                break;
        case NOT_MACRO:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a macro\n");
                                break;
        case NOT_HYGIENIC:		printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a hygienic\n");
                                break;
        case NOT_LIST:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a list\n");
                                break;
        case NOT_BOOL:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a boolean\n");
                                break;
        case NOT_IDENTIFIER:	printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a identifier\n");
                                break;
        case NOT_SYNTACTIC:		printf("Exception in %s: ", fn);
        						print(arg); printf(" is not a syntactic closure\n");
                                break;
        case INCORRECT_ARG_CNT:	printf("Exception: incorrect argument count in call (%s)\n", fn);
        						break;
        case ILLEGAL_ARGUMENT:	printf("Exception in %s: ", fn);
        						print(arg); printf(" is illegal argument\n");
                                break;
        case DIVIDE_ZERO:		printf("Exception in %s: divide by zero\n", fn);
        						break;
        case TOO_BIG:			printf("Exception in %s: ", fn);
        						print(arg); printf(" is too big number\n");
                                break;
        case INVALID_SYNTAX:	printf("Exception: invalid syntax ");
        						print(arg); printf("\n");
                                break;
        case INVALID_APP:		printf("Exception: invalid application ");
        						print(arg); printf("\n");
                                break;
        case EXTRA_PAREN:		printf("Exception: extra close parenthesis\n");
        						break;
        case STACK_OVERF:		printf("Exception: stack overflow\n");
        						break;
        case CODE_OVERF:		printf("Exception: code overflow\n");
        						break;
		case NOT_MODULE:		printf("Exception in %s: not exist module ", fn);
        						print(arg);
								printf("\n");
        						break;
        case MODULE_OVERF:		printf("Exception: module overflow\n");
        						break;
        case CLOSURE_OVERF:		printf("Exception: closure overflow\n");
        						break;
        case ILLEGAL_VMCODE:	printf("Exception: illegal VM code pc=%d \n", pc);
        						break;
        case MALLOC_OVERF:		printf("Exception in %s: memory allocation over flow\n", fn);
        						break;
        case NOT_EXIST_LIB:		printf("Exception in import: not exist library ");
        						print(arg);
                                printf("\n");
        						break;				
    }
    //ƒXƒeƒbƒvÀs’†~
    stepflag = 0;
    
    //ƒfƒoƒbƒOƒ‚[ƒh‚È‚çƒoƒbƒNƒgƒŒ[ƒX‚ğo—Í
    if(debugflag){
    	printf("back trace\n");
    	for(i=0; i<back_trace_end; i++){
			printf("[%d] ", i - back_trace_end);
        	print(cons(back_trace[i][0],back_trace[i][1]));
            printf("\n");
        }
    }
    	
    //load’†‚È‚çƒNƒ[ƒY‚µ‚ÄƒgƒbƒvƒŒƒxƒ‹‚Ö•œ‹AB
    if(loadflag == 1)
    	fclose(input_port);
	
    //ƒNƒ[ƒWƒƒ‚É‹L‰¯‚µ‚½–½—ß—ñ‚ÌŠJnƒAƒhƒŒƒX‚ğÁ‹B
    for(i=0; i< code_pointer_end; i++){
            SET_AUX(code_pointer[i][0] , -1);
        }
    code_pointer_end = 0;
	
    //ƒ‚ƒWƒ…[ƒ‹‚ğ(normal user)‚É•œ‹A
    current_module = 0;
    
	longjmp(toplevel,1);
}


//----------VM1----------------------------
int vm1(void){
	int arg,res,clo,m,n,o,i,j,x,y,z,size,clo_code,cont,cont_code,cont_stack,
    	new_env,env_i,env_j,new_env_i,new_env_j,savepc,savesp,saveenv;
    char str[SYMSIZE];
	
	
	static const void *JUMPTABLE[] = 
    {&&CASE_NOP,  //0
    &&CASE_HALT,  //1
    &&CASE_CONST, //2
    &&CASE_LVAR,  //3
    &&CASE_GVAR,  //4
    &&CASE_LSET,  //5
    &&CASE_GSET,  //6
    &&CASE_POP,   //7
    &&CASE_JUMP,  //8
	&&CASE_TJUMP, //9
    &&CASE_FJUMP, //10
    &&CASE_RETURN,//11
    &&CASE_ARGS,  //12
    &&CASE_CALL,  //13
    &&CASE_CALLJ, //14
    &&CASE_FN,    //15
    &&CASE_SAVE,  //16
    &&CASE_PRIM,  //17
    &&CASE_DEF,   //18
    &&CASE_DEFM,  //19
    &&CASE_DEFH,  //20
    &&CASE_NEQP,  //21
    &&CASE_SMLP,  //22
    &&CASE_ESMLP, //23
    &&CASE_GRTP,  //24
    &&CASE_EGRTP, //25
    &&CASE_ZEROP, //26
    &&CASE_ADD1,  //27
    &&CASE_SUB1,  //28
    &&CASE_ADD2,  //29
    &&CASE_SUB2,  //30
    &&CASE_GREF,  //31
    &&CASE_CATCH, //32
    &&CASE_PAUSE, //33
    &&CASE_CAR,   //34
    &&CASE_CDR,   //35
    &&CASE_CONS,  //36
    &&CASE_ADAPT, //37
    &&CASE_DEFLIB,//38
    &&CASE_EXPLIB,//39
    &&CASE_IMPLIB //40
    };
	
	env_i = GET_CDR(env);
    env_j = GET_AUX(env);
    n_args = 0;
    goto *JUMPTABLE[code[pc]];
    
    CASE_NOP:
        pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_HALT:
    	for(i=0; i< code_pointer_end; i++){
        	SET_AUX(code_pointer[i][0], -1);
        }
        code_pointer_end = 0;
    	return(TOP_STACK);
        
    CASE_CONST:
    	push_s(ARG1);
        pc = pc + 2;
		goto *JUMPTABLE[code[pc]];
        
    CASE_LVAR:
    	if(ARG1 == 0)
    		push_s(GET_ENV_VEC_ELT(env,ARG2));
    	else
        	push_s(get_lvar(ARG1, ARG2));
    
        pc = pc + 3;
        goto *JUMPTABLE[code[pc]];
        
    CASE_GVAR:
    	arg = ARG1;
    	res = GET_CAR(arg);
        
        if(res == undef)
            	exception("", UNBOUND_VARIABLE, arg);
        
        push_s(res);
        
        //ƒNƒ[ƒWƒƒ‚Ìê‡‚É‚Ígref–½—ß‚É’uŠ·‚·‚éB
        if(IS_CLOSURE(res)){
        	code[pc] = 31; //(gref addr)
        	code[pc+1] = res;
        }
        
        pc = pc + 2;
        goto *JUMPTABLE[code[pc]];

    CASE_LSET:
		res = POP_S;
        set_lvar(ARG1,ARG2,res);
        push_s(res);
        pc = pc + 3;
        goto *JUMPTABLE[code[pc]];
        
    CASE_GSET:
        x = POP_S;
        arg = ARG1;

		if(GET_CAR(arg) != undef)
    		SET_CAR(arg,x);
    	else
        	exception("", UNBOUND_VARIABLE, arg);
       	
        push_s(x);
        pc = pc + 2;
        goto *JUMPTABLE[code[pc]];
    
    CASE_POP:
    	pop_s();
        pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
        
    CASE_JUMP:
        pc = pc + ARG1;
        goto *JUMPTABLE[code[pc]];
	
    
    CASE_TJUMP:
        if(POP_S != BOOLF)
        	pc = pc + ARG1;
        else
        	pc = pc + 2;
        
        goto *JUMPTABLE[code[pc]];
        	
        
    CASE_FJUMP:
        if(POP_S == BOOLF)
        	pc = pc + ARG1;
        else
        	pc = pc + 2;
        
        goto *JUMPTABLE[code[pc]];
        
    CASE_RETURN:
        pc = THIRD_STACK;
        env = SECOND_STACK;
        stack[sp-3] = stack[sp-1];
        sp = sp - 2;
        goto *JUMPTABLE[code[pc]];
    	
    CASE_ARGS:
    	check_ctrl();
    	m = ARG1;
        n = abs(m);
		
        
		new_env_i = env_i+1;
        if(n > env_j)
        	new_env_j = n;
        else
        	new_env_j = env_j;
        
        new_env = make_env(new_env_i,new_env_j);
		
        
        //ƒRƒs[Œ³‚ÌŠÂ‹«‚ÌƒAƒhƒŒƒX‚ğ‹L‰¯‚·‚éB
        SET_ENV_ORG(new_env,env);
        
        
        //’Êí‚Ìˆø”‚Ìê‡B
        if(m >= 0){
			for(j=n-1; j>=0; j--) 
                SET_ENV_VEC_ELT(new_env, j ,pop_s());        
		}
        //—]èˆø”‚Ìê‡B
		else{
        	x = count_stack() - (n-1);//è—]ˆø”‚ÌŒÂ”
            //—]èˆø”‚ğƒŠƒXƒg‚É‚Ü‚Æ‚ß‚éB
			arg = NIL;
            for(i=x; i>0; i--)
            	arg = cons(POP_S,arg);
            SET_ENV_MAT_ELT(new_env, 0 , n-1, arg);
            n--;
            //—]èˆÈŠO‚Ìˆø”‚ğŠÂ‹«‚ÉƒZƒbƒg‚·‚éB
            for(j=n-1; j>=0; j--) 
                SET_ENV_VEC_ELT(new_env, j ,pop_s()); 	
        }
        	
        env = new_env;
        env_i = new_env_i;
        env_j = new_env_j;
        pc = pc + 2;
        goto *JUMPTABLE[code[pc]];
    
    
    
    CASE_CALL:
		check_ctrl();
        n = ARG1;
    	clo = POP_S;
        
		if(closurep(clo)){
        	m = GET_ARGS_CNT(clo);
            if(((m >=0 ) && m != n) ||
               ( m < 0 && n < abs(m)-1))
            	exception(GET_NAME(clo),INCORRECT_ARG_CNT,NIL);
            
        	//‚Ü‚¾“WŠJ‚³‚ê‚Ä‚¢‚È‚¢–½—ß—ñ‚Ìê‡
			if((x=GET_AUX(clo)) == -1){
                clo_code = GET_CAR(clo);
                size = GET_CDR(clo_code);
                for(i=0; i<size; i++)
                	code[i+tail] = GET_VEC_ELT(clo_code,i);
                head = tail;
                tail = tail+size;
                SET_AUX(clo,head);
                code_pointer[code_pointer_end][0] = clo;
                code_pointer[code_pointer_end][1] = head;
                code_pointer_end++;
                if(code_pointer_end > CLOSIZE)
                	exception("call", CLOSURE_OVERF,NIL);
            	insert_stack(env,pc+2,n);
                env = GET_CDR(clo);
                env_i = GET_CDR(env);
   				env_j = GET_AUX(env);
            	pc = head;
        	}
            //Šù‚É“WŠJ‚³‚ê‚Ä‚¢‚é–½—ß—ñ‚Ìê‡B
        	else{
                i = sp-1;
    			for(j=n; j>0; j--){
    				stack[i+2] = stack[i];
        			i--;
    			}
    			stack[sp-n] = pc+2;
    			stack[sp-n+1] = env;
    			sp = sp + 2; 
				//insert_stack(env,pc+2,n);
                env = GET_CDR(clo);
                env_i = GET_CDR(env);
    			env_j = GET_AUX(env);
            	pc = x;
        	}
        	goto *JUMPTABLE[code[pc]];
        }
        if(continuationp(clo)){
			//Œp‘±‚©‚ç“n‚³‚ê‚½ˆø”
            if(n == 0)
            	arg = empty_set;
            else if (n == 1)
            	arg = pop_s();
            else{
            	arg = NIL;
            	for(i=0; i<n; i++)
            		arg = cons(pop_s(),arg);
            }
                
            contflag = 1;
            //ƒƒ‚ƒŠ“WŠJî•ñ‚ÌƒNƒŠƒA
            for(i=0; i< code_pointer_end; i++){
        		SET_AUX(code_pointer[i][0], -1);
        	}
        	code_pointer_end = 0;

 			
            //Œp‘±‚Ì•Û‚·‚é–½—ß—ñ‚ğ•œŒ³
        	cont_code = GET_CAR(clo);
            pc = GET_VEC_ELT(cont_code,0); //pc‚È‚Ç‚ğ•œŒ³
            code_pointer_end = GET_VEC_ELT(cont_code,1);
            head = GET_VEC_ELT(cont_code,2);
            tail = GET_VEC_ELT(cont_code,3);
            
            
            j = 4;
            for(i=0; i<code_pointer_end; i++){
            	code_pointer[i][0] = GET_VEC_ELT(cont_code,j);    //closure
            	code_pointer[i][1] = GET_VEC_ELT(cont_code,j+1);  //start address
				SET_AUX(code_pointer[i][0],code_pointer[i][1]);
                x = code_pointer[i][0];
                clo_code = GET_CAR(x);
                size = GET_CDR(clo_code);
                y = code_pointer[i][1];
                for(z=0; z<size; z++)
                	code[z+y] = GET_VEC_ELT(clo_code,z);   
                j = j + 2;
			}
            y = code_pointer[0][1];
            for(i=0; i<y; i++){
            	code[i] = GET_VEC_ELT(cont_code,j);
                j++;
            }
            
            //Œp‘±‚Ì•Û‚·‚éƒXƒ^ƒbƒN‚ğ•œŒ³
            cont_stack = GET_CDR(clo);
			m = GET_CDR(cont_stack);
            for(i=0; i<m; i++)
            	stack[i] = GET_VEC_ELT(cont_stack,i);
            sp = m;
            
            //Œp‘±‚É“n‚³‚ê‚½ˆø”‚ğƒXƒ^ƒbƒNƒgƒbƒv‚Ö
            if(n == 0 || n == 1)
            	push_s(arg);
            else
            	push_s(make_multiple_values(arg));

			
            //Œp‘±‚Ì•Û‚·‚éŠÂ‹«‚ğ•œŒ³
            env = car(GET_AUX(clo));
            current_module = cadr(GET_AUX(clo));
            goto *JUMPTABLE[code[pc]];	
        }
        if(subrp(clo)){
        	pc = pc + 2;
        	push_s(((GET_SUBR(clo))(n)));
            goto *JUMPTABLE[code[pc]];  
        }   
        	
        
    CASE_CALLJ:
		check_ctrl();
        n = ARG1;
    	clo = POP_S;
        
        if((x=GET_AUX(clo)) == -1){
			clo_code = GET_CAR(clo);
            size = GET_CDR(clo_code);
            for(i=0; i<size; i++)
            	code[i+tail] = GET_VEC_ELT(clo_code,i);
            head = tail;
            tail = tail+size;
            SET_AUX(clo,head);
            code_pointer[code_pointer_end][0] = clo;
            code_pointer[code_pointer_end][1] = head;
            code_pointer_end++;
			if(code_pointer_end > CLOSIZE)
            	exception("callj", CLOSURE_OVERF,NIL);
            env = GET_CDR(clo);
            env_i = GET_CDR(env);
    		env_j = GET_AUX(env);
            pc = head;
        }
        else{
        	env = GET_CDR(clo);
            env_i = GET_CDR(env);
    		env_j = GET_AUX(env);
            pc = x;
        }
        goto *JUMPTABLE[code[pc]];  
        
    
    CASE_FN:
        n = ARG1;
        arg = ARG2;
        res = make_clo();
        if(IS_LIST(arg))
        	clo_code = list_to_code_obj(arg);
        else
        	clo_code = arg;
        SET_CAR(res,clo_code);
        SET_CDR(res,env);
        SET_ARGS_CNT(res,n);
        push_s(res);
        pc = pc + 3;
        goto *JUMPTABLE[code[pc]];
        
    CASE_SAVE:
		push_s(ARG1);
    	push_s(env);
        pc = pc + 2;
        goto *JUMPTABLE[code[pc]];
    
    CASE_PRIM:
		check_ctrl();
        x = ARG1;
        if(symbolp(x)){
        	clo = car(x);
            if(clo == undef) exception("", UNBOUND_VARIABLE, x);
        }
        else
        	clo = x;
        n = ARG2;
    	pc = pc + 3;
        push_s(((GET_SUBR(clo))(n)));
    	goto *JUMPTABLE[code[pc]];  
	
    CASE_DEF:
        arg = ARG1;
        if(closurep(TOP_STACK)){
        	clo = TOP_STACK;
            strcpy(str,GET_NAME(arg));
            SET_NAME(clo,str);
        }
        
		SET_CAR(arg,pop_s());
        
        push_s(arg);
        pc = pc + 2;
		goto *JUMPTABLE[code[pc]];
    	
    CASE_DEFM:
        arg = ARG1;
        clo = make_macro();
        SET_CAR(clo,pop_s());
        SET_CAR(arg,clo);
        strcpy(str,GET_NAME(arg));
        SET_NAME(clo,str);
        push_s(arg);
        pc = pc + 2;
    	goto *JUMPTABLE[code[pc]];
        
    CASE_DEFH:
        arg = ARG1; //symbol
        new_env = ARG2; //comp-env
        clo = make_hygienic();
        SET_CAR(clo,pop_s());
        SET_CDR(clo,env); //vm-env
        SET_AUX(clo,new_env);
        SET_CAR(arg,clo);
        strcpy(str,GET_NAME(arg));
        SET_NAME(clo,str);
        push_s(arg);
        pc = pc + 3;
    	goto *JUMPTABLE[code[pc]];
    
    CASE_NEQP:
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x == y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(numeqp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_SMLP:
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x < y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(smallerp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_ESMLP:
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x <= y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(eqsmallerp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
        
    
    CASE_GRTP:
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x > y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(greaterp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    	
    
    CASE_EGRTP:
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x >= y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(eqgreaterp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
        
    	
    
    CASE_ZEROP:
        x = pop_s();

    	if(IS_INTEGER(x)){
     		if(get_int(x) == 0)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(zerop(x))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    	
        
    CASE_ADD1:
    	arg = pop_s();
    	if(IS_INTEGER(arg)){
    		x = get_int(arg);
    		x++;
    		push_s(make_int(x));
		}
    	else{
    		if(!numberp(arg))
        		exception("add1",NOT_NUMBER,arg);
    		push_s(plus(arg,make_int(1)));
    	}
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_SUB1:
    	arg = pop_s();
    	if(IS_INTEGER(arg)){
    		x = get_int(arg);
    		x--;
    		push_s(make_int(x));
		}
    	else{
    		if(!numberp(arg))
        		exception("sub1",NOT_NUMBER,arg);
    		push_s(minus(arg,make_int(1)));
    	}
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_ADD2:
    	arg = pop_s();
    	if(IS_INTEGER(arg)){
    		x = get_int(arg);
    		x = x+2;
    		push_s(make_int(x));
		}
    	else{
    		if(!numberp(arg))
        		exception("add2",NOT_NUMBER,arg);
    		push_s(plus(arg,make_int(2)));
    	}
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_SUB2:
    	arg = pop_s();
    	if(IS_INTEGER(arg)){
    		x = get_int(arg);
    		x = x-2;
    		push_s(make_int(x));
		}
    	else{
    		if(!numberp(arg))
        		exception("add2",NOT_NUMBER,arg);
    		push_s(minus(arg,make_int(2)));
    	}
    	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_GREF:
		push_s(ARG1);
        pc = pc + 2;
        goto *JUMPTABLE[code[pc]];
    
    CASE_CATCH:
    	cont_code = make_memory();
    	cont_stack = make_stack();
        cont = make_cont();
        SET_CAR(cont,cont_code);
        SET_CDR(cont,cont_stack);
        SET_AUX(cont,cons(env,cons(current_module,NIL)));
    	push_s(cont);
        pc = pc + 1;
    	goto *JUMPTABLE[code[pc]];
    
    CASE_PAUSE:
    	return(TOP_STACK);
    
    CASE_CAR:
    	x = pop_s();
        if(pairp(x))
    		push_s(GET_CAR(x));
    	else
    		exception("car", NOT_PAIR, x);
      	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_CDR:
        x = pop_s();
        if(pairp(x))
    		push_s(GET_CDR(x));
    	else
    		exception("cdr", NOT_PAIR, x);
      	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_CONS:
        y = pop_s();
        x = pop_s();
        push_s(cons(x,y));
      	pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_ADAPT:
    	arg = pop_s();
    
		if(GET_TAG(arg) == MUL){
    		m = GET_VEC_ELT(arg,0);
    		for(i=1; i<=m; i++){
    			x = GET_VEC_ELT(arg,i);
        	push_s(x);
    		}
    	}
    	else if(arg == empty_set){
    		m = 0;
    	}
    	else{
    		m = 1;
			push_s(arg);
    	}
        
		code[pc + 5] = m;
        pc = pc + 1;
        goto *JUMPTABLE[code[pc]];
    
    CASE_DEFLIB:
    	export_id = NIL;
        export_rename = NIL;
        x = ARG1; //name
        y = ARG2; //body
        for(i=0; i<module_table_end; i++)
        	if(equalp(module_table[i][0],x))
            	goto deflib_exit;
        
        module_table[i][0] = x;
        module_table_end++;
        
        deflib_exit:
        current_module = i;
        y = remake(y);
		
        while(!nullp(y)){
        	current_module = 0;
        	arg = cons(make_int(2),
    		       cons(car(y),
                    cons(make_int(4),
                     cons(make_sym("compile"),
                      cons(make_int(13),
                       cons(make_int(1),
                        cons(make_int(4),
                         cons(make_sym("assemble"),
                          cons(make_int(13),
                           cons(make_int(1),
                            cons(make_int(1),NIL)))))))))));
        
        	savepc = pc;
        	savesp = sp;
        	saveenv = env;
            list_to_code(arg);
            pc = head;
        	m = vm1();
        	list_to_code(m);
            pc = head;
            current_module = i;
        	vm1();
        	pc = savepc;
        	sp = savesp;
        	env = saveenv;
            y = cdr(y);
        }
        while(!nullp(export_rename)){
        	m = car(export_rename);
            n = car(m);
            o = car(cdr(m));
            SET_CAR(o,GET_CAR(n));
            export_id = cons(o,export_id);
            export_rename = cdr(export_rename);
        }
        module_table[i][1] = export_id;
        
		y = module_table[i][1];
        while(!nullp(y)){
        	m = car(y);
        	if(GET_CAR(m) == undef)
            	exception("", UNBOUND_VARIABLE, m);
        	y = cdr(y);
        }
        current_module = 0;
        pc = pc + 3;
        goto *JUMPTABLE[code[pc]];
    
    CASE_EXPLIB:
        x = ARG1; //id-list
        while(!nullp(x)){
        	if(eqp(car(car(x)),make_sym("rename")))
        		export_rename = cons(cdr(car(x)),export_rename);
        	else
        		export_id = cons(car(x),export_id);
            
            x = cdr(x);
        }
        push_s(undef);
        pc = pc + 2;
        goto *JUMPTABLE[code[pc]];
    
    CASE_IMPLIB:
        x = ARG1; //<name idintifier>
        while(!nullp(x)){
        	m = car(x);
        	for(i=0; i<module_table_end; i++)
        		if(equalp(module_table[i][0],m))
            		goto implib_exit;
        
        	exception("", NOT_EXIST_LIB, m);
        
        	implib_exit:
        	y = module_table[i][1]; //export-list
        
        	while(!nullp(y)){
        		n = car(y);
            	SET_CAR(remake(n),GET_CAR(n));
            	y = cdr(y);
        	}
            x = cdr(x);
        }
        push_s(undef);
        pc = pc + 2;
        goto *JUMPTABLE[code[pc]];
   	
}
//----------VM2--------------------------

int vm2(void){
	int arg,res,clo,m,n,o,i,j,x,y,z,size,clo_code,cont,cont_code,cont_stack,
    	new_env,env_i,env_j,new_env_i,new_env_j,trace,level,savepc,savesp,saveenv;
    char str[SYMSIZE];
	prof prof_dt[OPCODE];
    clock_t start,end;
	double total,average;
    
	static const void *JUMPTABLE[] = 
    {&&CASE_NOP,  //0
    &&CASE_HALT,  //1
    &&CASE_CONST, //2
    &&CASE_LVAR,  //3
    &&CASE_GVAR,  //4
    &&CASE_LSET,  //5
    &&CASE_GSET,  //6
    &&CASE_POP,   //7
    &&CASE_JUMP,  //8
	&&CASE_TJUMP, //9
    &&CASE_FJUMP, //10
    &&CASE_RETURN,//11
    &&CASE_ARGS,  //12
    &&CASE_CALL,  //13
    &&CASE_CALLJ, //14
    &&CASE_FN,    //15
    &&CASE_SAVE,  //16
    &&CASE_PRIM,  //17
    &&CASE_DEF,   //18
    &&CASE_DEFM,  //19
    &&CASE_DEFH,  //20
	&&CASE_NEQP,  //21
    &&CASE_SMLP,  //22
    &&CASE_ESMLP, //23
    &&CASE_GRTP,  //24
    &&CASE_EGRTP, //25
    &&CASE_ZEROP, //26
    &&CASE_ADD1,  //27
    &&CASE_SUB1,  //28
    &&CASE_ADD2,  //29
    &&CASE_SUB2,   //30
	&&CASE_GREF,   //31
    &&CASE_CATCH,  //32
	&&CASE_PAUSE,  //33
    &&CASE_CAR,    //34
    &&CASE_CDR,    //35
    &&CASE_CONS,   //36
    &&CASE_ADAPT,  //37
    &&CASE_DEFLIB, //38
    &&CASE_EXPLIB, //39
    &&CASE_IMPLIB  //40
};
    
    prof_dt[0].name = "nop    ";
    prof_dt[1].name = "halt   ";
    prof_dt[2].name = "const  ";
    prof_dt[3].name = "lvar   ";
    prof_dt[4].name = "gvar   ";
    prof_dt[5].name = "lset   ";
    prof_dt[6].name = "gset   ";
    prof_dt[7].name = "pop    ";
    prof_dt[8].name = "jump   ";
    prof_dt[9].name = "tjump  ";
    prof_dt[10].name = "fjump  ";
    prof_dt[11].name = "return ";
    prof_dt[12].name = "args   ";
    prof_dt[13].name = "call   ";
    prof_dt[14].name = "callj  ";
    prof_dt[15].name = "fn     ";
    prof_dt[16].name = "save   ";
    prof_dt[17].name = "prim   ";
    prof_dt[18].name = "def    ";
    prof_dt[19].name = "defm   ";
    prof_dt[20].name = "defh   ";
    prof_dt[21].name = "neqp   ";
    prof_dt[22].name = "smlp   ";
    prof_dt[23].name = "esmlp  ";
    prof_dt[24].name = "grtp   ";
    prof_dt[25].name = "egrtp  ";
    prof_dt[26].name = "zerop  ";
    prof_dt[27].name = "add1   ";
    prof_dt[28].name = "sub1   ";
    prof_dt[29].name = "add2   ";
    prof_dt[30].name = "sub2   ";
	prof_dt[31].name = "gref   ";
    prof_dt[32].name = "catch  ";
    prof_dt[33].name = "pause  ";
    prof_dt[34].name = "car    ";
    prof_dt[35].name = "cdr    ";
    prof_dt[36].name = "cons   ";
    prof_dt[37].name = "adapt  ";
    prof_dt[38].name = "deflib ";
    prof_dt[39].name = "explib ";
    prof_dt[40].name = "implib ";
    
    for(i=0; i<OPCODE; i++){
    	prof_dt[i].count = 0;
        prof_dt[i].time = 0;
    }
	
	env_i = GET_CDR(env);
    env_j = GET_AUX(env);
    n_args = 0;
    trace = 0;
    level = 0;
    
    goto *JUMPTABLE[code[pc]];
    
    CASE_NOP:
		step();
        start = clock();
        pc = pc + 1;
        end = clock();
        prof_dt[0].count++;
        prof_dt[0].time = prof_dt[0].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_HALT:
    	step();
        start = clock();
        
    	for(i=0; i< code_pointer_end; i++){
            SET_AUX(code_pointer[i][0] , -1);
        }
        code_pointer_end = 0;
        		 
        end = clock();
        prof_dt[1].count++;
        prof_dt[1].time = prof_dt[1].time + (end - start);
        
        if(profflag){
        	printf("inst    total(s) average(s)         count\n");
        	for(i=0; i<OPCODE; i++){
            	total = (double)(double)prof_dt[i].time / CLOCKS_PER_SEC;
                if(prof_dt[i].count != 0)
                	average = total / (double)prof_dt[i].count;
                else
                	average = 0;
        		printf("%s %f %1.16f %d \n", prof_dt[i].name,
                        	          total,
                     				  average,
                                      prof_dt[i].count);
        	}
        }    
    	return(TOP_STACK);
    
    CASE_CONST:
    	step();
        start = clock();
        
    	push_s(ARG1);
        pc = pc + 2;
        
        end = clock();
        prof_dt[2].count++;
        prof_dt[2].time = prof_dt[2].time + (end - start);
        VM_ERR_CHK;
		goto *JUMPTABLE[code[pc]];
        
    CASE_LVAR:
    	step();
        start = clock();
        
		if(ARG1 == 0)
    		push_s(GET_ENV_VEC_ELT(env,ARG2));
    	else
        	push_s(get_lvar(ARG1, ARG2));
    
        pc = pc + 3;

        end = clock();
        prof_dt[3].count++;
        prof_dt[3].time = prof_dt[3].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        
    CASE_GVAR:
    	step();
        start = clock();
        
    	arg = ARG1;
        if(GET_CDR(arg) == 1)
        	trace = 1;
    	res = GET_CAR(arg);
        
        if(res == undef)
        	exception("", UNBOUND_VARIABLE, arg);
        
		push_s(res);
        
        if(GET_CDR(arg) == 0 && IS_CLOSURE(arg)){
        //ƒgƒŒ[ƒX‚ª‚Æ‚ê‚È‚­‚È‚é‚Ì‚ÅƒgƒŒ[ƒX’†‚Ígref‚Íg‚í‚È‚¢B
        	code[pc] = 31; //(gref addr);
        	code[pc+1] = res;
        }
        
        
        pc = pc + 2;
        
        end = clock();
        prof_dt[4].count++;
        prof_dt[4].time = prof_dt[4].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];

    CASE_LSET:
    	step();
        start = clock();
        
		res = POP_S;
        set_lvar(ARG1,ARG2,res);
        push_s(res);
        pc = pc + 3;
        
        end = clock();
        prof_dt[5].count++;
        prof_dt[5].time = prof_dt[5].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        
    CASE_GSET:
    	step();
        start = clock();
        
        x = POP_S;
        arg = ARG1;
        
        if(GET_CAR(arg) != undef)
    		SET_CAR(arg,x);
    	else
        	exception("", UNBOUND_VARIABLE, arg);
        
        push_s(x);
        pc = pc + 2;
        
        end = clock();
        prof_dt[6].count++;
        prof_dt[6].time = prof_dt[6].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_POP:
    	step();
        start = clock();
        
    	pop_s();
        pc = pc + 1;
        
        end = clock();
        prof_dt[7].count++;
        prof_dt[7].time = prof_dt[7].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        
    CASE_JUMP:
    	step();
        start = clock();
        
        pc = pc + ARG1;
        
        end = clock();
        prof_dt[8].count++;
        prof_dt[8].time = prof_dt[8].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
	
    
    CASE_TJUMP:
    	step();
        start = clock();
        
        if(POP_S != BOOLF)
        	pc = pc + ARG1;
        else
        	pc = pc + 2;
        
        end = clock();
        prof_dt[9].count++;
        prof_dt[9].time = prof_dt[9].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        	
        
    CASE_FJUMP:
    	step();
        start = clock();
        
        if(POP_S == BOOLF)
        	pc = pc + ARG1;
        else{
        	//pc = pc + 2;
            pc++; pc++;
        }
        
        end = clock();
        prof_dt[10].count++;
        prof_dt[10].time = prof_dt[10].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        
    CASE_RETURN:
    	step();
        start = clock();
        
        if(level > 0){
			level--;
			for(i=0; i<level; i++){
				if(i >= 10){
                	printf("[%d]",level);
                    break;
                }	
            	else if(i % 2 == 0)
                	printf("|");
                else
                	printf(" ");
                }
			print(stack[sp-1]);
			printf("\n");
        }
        pc = THIRD_STACK;
        env = SECOND_STACK;
        stack[sp-3] = stack[sp-1];
        sp = sp - 2;
        
        end = clock();
        prof_dt[11].count++;
        prof_dt[11].time = prof_dt[11].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    	
    CASE_ARGS:
    	check_ctrl();
    	step();
        start = clock();
        
    	m = ARG1;
        n = abs(m);
		
    	new_env_i = env_i+1;
        if(n > env_j)
        	new_env_j = n;
        else
        	new_env_j = env_j;
        
        new_env = make_env(new_env_i,new_env_j);
		
        
        //ƒRƒs[Œ³‚ÌŠÂ‹«‚ÌƒAƒhƒŒƒX‚ğ‹L‰¯‚·‚éB
        SET_ENV_ORG(new_env,env);
        
        
        //’Êí‚Ìˆø”‚Ìê‡B
        if(m >= 0){
        	for(j=n-1; j>=0; j--) 
                SET_ENV_VEC_ELT(new_env, j ,pop_s());        
		}
        //—]èˆø”‚Ìê‡B
		else{
        	x = count_stack() - (n-1);//è—]ˆø”‚ÌŒÂ”
            //—]èˆø”‚ğƒŠƒXƒg‚É‚Ü‚Æ‚ß‚éB
			arg = NIL;
            for(i=x; i>0; i--)
            	arg = cons(POP_S,arg);
            SET_ENV_MAT_ELT(new_env, 0 , n-1, arg);
            n--;
            //—]èˆÈŠO‚Ìˆø”‚ğŠÂ‹«‚ÉƒZƒbƒg‚·‚éB
            for(j=n-1; j>=0; j--)
            	SET_ENV_VEC_ELT(new_env, j ,pop_s());	
        }
        	
        env = new_env;
        env_i = new_env_i;
        env_j = new_env_j;
        pc = pc + 2;
        
        end = clock();
        prof_dt[12].count++;
        prof_dt[12].time = prof_dt[12].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    
    
    CASE_CALL:
    	step();
        
		check_ctrl();        
        n = ARG1;
    	clo = POP_S;
        push_back_trace(clo, stack_to_list(n));
        start = clock();
        
		if(closurep(clo)){
        	if(trace == 1){
                for(i=0; i<=level; i++){
					if(i >= 10){
                    	printf("[%d]", level);
                    	break;
                    }
                	else if(i % 2 == 0)
                    	printf("|");
                    else
                    	printf(" ");
                	}
				printf("(%s", GET_NAME(clo));
				for(i=n; i>0; i--){
                	printf(" ");
                	print(stack[sp-i]);
                    }
                printf(")\n");
                level++;
            	trace = 0;
            }
        	m = GET_ARGS_CNT(clo);
            if(((m >=0 ) && m != n) ||
               ( m < 0 && n < abs(m)-1))
            	exception(GET_NAME(clo),INCORRECT_ARG_CNT,NIL);
            
        	//‚Ü‚¾“WŠJ‚³‚ê‚Ä‚¢‚È‚¢–½—ß—ñ‚Ìê‡
			if((x=GET_AUX(clo)) == -1){
                clo_code = GET_CAR(clo);
                size = GET_CDR(clo_code);
                for(i=0; i<size; i++)
                	code[i+tail] = GET_VEC_ELT(clo_code,i);
                head = tail;
                tail = tail+size;
                SET_AUX(clo,head);
                code_pointer[code_pointer_end][0] = clo;
                code_pointer[code_pointer_end][1] = head;
                code_pointer_end++;
                if(code_pointer_end > CLOSIZE)
                	exception("call", CLOSURE_OVERF,NIL);
            	insert_stack(env,pc+2,n);
                env = GET_CDR(clo);
                env_j = GET_AUX(env);
				env_i = GET_CDR(env);
            	pc = head;
        	}
            //Šù‚É“WŠJ‚³‚ê‚Ä‚¢‚é–½—ß—ñ‚Ìê‡B
        	else{
                insert_stack(env,pc+2,n);
                env = GET_CDR(clo);
                env_j = GET_AUX(env);
				env_i = GET_CDR(env);
            	pc = x;
        	}
        }
        if(continuationp(clo)){
			//Œp‘±‚©‚ç“n‚³‚ê‚½ˆø”
            if(n == 0)
            	arg = empty_set;
            else if (n == 1)
            	arg = pop_s();
            else{
            	arg = NIL;
            	for(i=0; i<n; i++)
            		arg = cons(pop_s(),arg);
            }
                
            contflag = 1;
            //ƒƒ‚ƒŠ“WŠJî•ñ‚ÌƒNƒŠƒA
            for(i=0; i< code_pointer_end; i++){
        		SET_AUX(code_pointer[i][0], -1);
        	}
        	code_pointer_end = 0;
	
            
            //Œp‘±‚Ì•Û‚·‚é–½—ß—ñ‚ğ•œŒ³
        	cont_code = GET_CAR(clo);
            pc = GET_VEC_ELT(cont_code,0); //pc‚È‚Ç‚ğ•œŒ³
            code_pointer_end = GET_VEC_ELT(cont_code,1);
            head = GET_VEC_ELT(cont_code,2);
            tail = GET_VEC_ELT(cont_code,3);
            
            
            j = 4;
            for(i=0; i<code_pointer_end; i++){
            	code_pointer[i][0] = GET_VEC_ELT(cont_code,j);    //closure
            	code_pointer[i][1] = GET_VEC_ELT(cont_code,j+1);  //start address
				SET_AUX(code_pointer[i][0],code_pointer[i][1]);
   			    x = code_pointer[i][0];
                clo_code = GET_CAR(x);
                size = GET_CDR(clo_code);
                y = code_pointer[i][1];
                for(z=0; z<size; z++)
                	code[z+y] = GET_VEC_ELT(clo_code,z);   
                j = j + 2;
			}
            y = code_pointer[0][1];
            for(i=0; i<y; i++){
            	code[i] = GET_VEC_ELT(cont_code,j);
                j++;
            }
            
            //Œp‘±‚Ì•Û‚·‚éƒXƒ^ƒbƒN‚ğ•œŒ³
            cont_stack = GET_CDR(clo);
			m = GET_CDR(cont_stack);
            for(i=0; i<m; i++)
            	stack[i] = GET_VEC_ELT(cont_stack,i);
            sp = m;
            
            //Œp‘±‚É“n‚³‚ê‚½ˆø”‚ğƒXƒ^ƒbƒNƒgƒbƒv‚Ö
            if(n == 0 || n == 1)
            	push_s(arg);
            else
            	push_s(make_multiple_values(arg));
            	
            
            
            //Œp‘±‚Ì•Û‚·‚éŠÂ‹«‚ğ•œŒ³
            env = car(GET_AUX(clo));
            current_module = cadr(GET_AUX(clo));
    
        }
        if(subrp(clo)){
        	pc = pc + 2;
        	push_s(((GET_SUBR(clo))(n))); 
        }
        end = clock();
        prof_dt[13].count++;
        prof_dt[13].time = prof_dt[13].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];    
        	
        
    CASE_CALLJ:
    	step();
        
		check_ctrl();
    	n = ARG1;
    	clo = POP_S;
        push_back_trace(clo, stack_to_list(n));
        start = clock();
        
		if(trace == 1){
        	for(i=0; i<=level; i++){
				if(i >= 10){
                	printf("[%d]", level);
                    break;
                }
                else if(i % 2 == 0)
                	printf("|");
                else
                	printf(" ");
            }
			printf("(%s", GET_NAME(clo));
			for(i=n; i>0; i--){
            	printf(" ");
                print(stack[sp-i]);
            }
            printf(")\n");
            trace = 0;
        }
        if((x=GET_AUX(clo)) == -1){
			clo_code = GET_CAR(clo);
            size = GET_CDR(clo_code);
            for(i=0; i<size; i++)
            	code[i+tail] = GET_VEC_ELT(clo_code,i);
            head = tail;
            tail = tail+size;
            SET_AUX(clo,head);
            code_pointer[code_pointer_end][0] = clo;
            code_pointer[code_pointer_end][1] = head;
            code_pointer_end++;
            if(code_pointer_end > CLOSIZE)
            	exception("callj", CLOSURE_OVERF,NIL);
            env = GET_CDR(clo);
            env_j = GET_AUX(env);
			env_i = GET_CDR(env);
            pc = head;
        }
        else{
        	env = GET_CDR(clo);
            env_j = GET_AUX(env);
			env_i = GET_CDR(env);
            pc = x;
        }
        
        end = clock();
        prof_dt[14].count++;
        prof_dt[14].time = prof_dt[14].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];  
        
    
    CASE_FN:
    	step();
        start = clock();
        
        n = ARG1;
        arg = ARG2;
        res = make_clo();
        if(IS_LIST(arg))
        	clo_code = list_to_code_obj(arg);
        else
        	clo_code = arg;
        SET_CAR(res,clo_code);
        SET_CDR(res,env);
        SET_ARGS_CNT(res,n);
        push_s(res);
        pc = pc + 3;
        
        end = clock();
        prof_dt[15].count++;
        prof_dt[15].time = prof_dt[15].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        
    CASE_SAVE:
    	step();
        start = clock();
        
		push_s(ARG1);
    	push_s(env);
        pc = pc + 2;
        
        end = clock();
        prof_dt[16].count++;
        prof_dt[16].time = prof_dt[16].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_PRIM:
    	check_ctrl();
    	step();
        start = clock();
        
        x = ARG1;
        if(symbolp(x)){
        	clo = car(x);
            if(clo == undef) exception("", UNBOUND_VARIABLE, x);
        }
        else
        	clo = x;
        
        n = ARG2;
        push_back_trace(clo, stack_to_list(n));
    	pc = pc + 3;
        push_s(((GET_SUBR(clo))(n)));
        
        end = clock();
        prof_dt[17].count++;
        prof_dt[17].time = prof_dt[17].time + (end - start);
        VM_ERR_CHK;
    	goto *JUMPTABLE[code[pc]];  
	
    CASE_DEF:
    	step();
        start = clock();
        
        arg = ARG1;
        if(closurep(TOP_STACK)){
        	clo = TOP_STACK;
            strcpy(str,GET_NAME(arg));
            SET_NAME(clo,str);
        }
        
        SET_CAR(arg,pop_s());
        
        push_s(arg);
        pc = pc + 2;
        
        end = clock();
        prof_dt[18].count++;
        prof_dt[18].time = prof_dt[18].time + (end - start);
        VM_ERR_CHK;
		goto *JUMPTABLE[code[pc]];
    	
    CASE_DEFM:
    	step();
        start = clock();
        
        arg = ARG1;
        clo = make_macro();
        SET_CAR(clo,pop_s());
        SET_CAR(arg,clo);
        strcpy(str,GET_NAME(arg));
        SET_NAME(clo,str);
        push_s(arg);
        pc = pc + 2;
        
        end = clock();
        prof_dt[19].count++;
        prof_dt[19].time = prof_dt[19].time + (end - start);
        VM_ERR_CHK;
    	goto *JUMPTABLE[code[pc]];
        
    CASE_DEFH:
    	step();
        start = clock();
        
        arg = ARG1; //symbol
        new_env = ARG2; //comp-env
        clo = make_hygienic();
        SET_CAR(clo,pop_s());
        SET_CDR(clo,env); //vm-env
        SET_AUX(clo,new_env);
        SET_CAR(arg,clo);
        strcpy(str,GET_NAME(arg));
        SET_NAME(clo,str);
        push_s(arg);
        pc = pc + 3;
        
        end = clock();
        prof_dt[20].count++;
        prof_dt[20].time = prof_dt[20].time + (end - start);
        VM_ERR_CHK;
    	goto *JUMPTABLE[code[pc]];
        
    CASE_NEQP:
    	step();
        start = clock();
        
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x == y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(numeqp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        
        end = clock();
        prof_dt[21].count++;
        prof_dt[21].time = prof_dt[21].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_SMLP:
    	step();
        start = clock();
        
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x < y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(smallerp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        
        end = clock();
        prof_dt[22].count++;
        prof_dt[22].time = prof_dt[22].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_ESMLP:
    	step();
        start = clock();
        
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x <= y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(eqsmallerp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        
        end = clock();
        prof_dt[23].count++;
        prof_dt[23].time = prof_dt[23].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        
    
    CASE_GRTP:
    	step();
        start = clock();
        
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x > y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(greaterp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        
        end = clock();
        prof_dt[24].count++;
        prof_dt[24].time = prof_dt[24].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    	
    
    CASE_EGRTP:
    	step();
        start = clock();
        
    	y = pop_s();
        x = pop_s();

    	if(IS_INTEGER(x) && IS_INTEGER(y)){
     		if(x >= y)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(eqgreaterp(x,y))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        
        end = clock();
        prof_dt[25].count++;
        prof_dt[25].time = prof_dt[25].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        
    	
    
    CASE_ZEROP:
    	step();
        start = clock();
        
        x = pop_s();

    	if(IS_INTEGER(x)){
     		if(get_int(x) == 0)
    			push_s(BOOLT);
        	else
        		push_s(BOOLF);
    	}
		else{
        	if(zerop(x))
            	push_s(BOOLT);
            else
            	push_s(BOOLF);
        }
        
    	pc = pc + 1;
        
        end = clock();
        prof_dt[26].count++;
        prof_dt[26].time = prof_dt[26].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    	
        
    CASE_ADD1:
    	step();
        start = clock();
        
    	arg = pop_s();
    	if(IS_INTEGER(arg)){
    		x = get_int(arg);
    		x++;
    		push_s(make_int(x));
		}
    	else{
    		if(!numberp(arg))
        		exception("add1",NOT_NUMBER,arg);
    		push_s(plus(arg,make_int(1)));
    	}
    	pc = pc + 1;
        
        end = clock();
        prof_dt[27].count++;
        prof_dt[27].time = prof_dt[27].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_SUB1:
    	step();
        start = clock();
        
    	arg = pop_s();
    	if(IS_INTEGER(arg)){
    		x = get_int(arg);
    		x--;
    		push_s(make_int(x));
		}
    	else{
    		if(!numberp(arg))
        		exception("sub1",NOT_NUMBER,arg);
    		push_s(minus(arg,make_int(1)));
    	}
    	pc = pc + 1;
        
        end = clock();
        prof_dt[28].count++;
        prof_dt[28].time = prof_dt[28].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_ADD2:
    	step();
        start = clock();
        
    	arg = pop_s();
    	if(IS_INTEGER(arg)){
    		x = get_int(arg);
    		x = x+2;
    		push_s(make_int(x));
		}
    	else{
    		if(!numberp(arg))
        		exception("add2",NOT_NUMBER,arg);
    		push_s(plus(arg,make_int(2)));
    	}
    	pc = pc + 1;
        
        end = clock();
        prof_dt[29].count++;
        prof_dt[29].time = prof_dt[29].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_SUB2:
    	step();
        start = clock();
        
    	arg = pop_s();
    	if(IS_INTEGER(arg)){
    		x = get_int(arg);
    		x = x-2;
    		push_s(make_int(x));
		}
    	else{
    		if(!numberp(arg))
        		exception("add2",NOT_NUMBER,arg);
    		push_s(minus(arg,make_int(2)));
    	}
    	pc = pc + 1;
        
        end = clock();
        prof_dt[30].count++;
        prof_dt[30].time = prof_dt[30].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_GREF:
    	step();
        start = clock();
        
        push_s(ARG1);
        pc = pc + 2;
        
        end = clock();
        prof_dt[31].count++;
        prof_dt[31].time = prof_dt[31].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_CATCH:
    	step();
        start = clock();
    
    	cont_code = make_memory();
    	cont_stack = make_stack();
        cont = make_cont();
		SET_CAR(cont,cont_code);
        SET_CDR(cont,cont_stack);
        SET_AUX(cont,cons(env,cons(current_module,NIL)));
    	push_s(cont);
        pc = pc + 1;
        
        end = clock();
        prof_dt[32].count++;
        prof_dt[32].time = prof_dt[32].time + (end - start);
        VM_ERR_CHK;
    	goto *JUMPTABLE[code[pc]];
    
    CASE_PAUSE:
    	step();
        start = clock();
        
    	end = clock();
        prof_dt[33].count++;
        prof_dt[33].time = prof_dt[33].time + (end - start);
        VM_ERR_CHK;
    	return(TOP_STACK);
    
    CASE_CAR:
    	step();
        start = clock();
        
        x = pop_s();
        if(pairp(x))
    		push_s(GET_CAR(x));
    	else
    		exception("car", NOT_PAIR, x);
      	pc = pc + 1;
        
    	end = clock();
        prof_dt[34].count++;
        prof_dt[34].time = prof_dt[34].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_CDR:
    	step();
        start = clock();
        
        x = pop_s();
        if(pairp(x))
    		push_s(GET_CDR(x));
    	else
    		exception("cdr", NOT_PAIR, x);
      	pc = pc + 1;
       
    	end = clock();
        prof_dt[35].count++;
        prof_dt[35].time = prof_dt[35].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_CONS:
    	step();
        start = clock();
        
        y = pop_s();
        x = pop_s();
        push_s(cons(x,y));
      	pc = pc + 1;
        
    	end = clock();
        prof_dt[36].count++;
        prof_dt[36].time = prof_dt[36].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_ADAPT:
    	step();
        start = clock();
        
    	arg = pop_s();
    
		if(GET_TAG(arg) == MUL){
    		m = GET_VEC_ELT(arg,0);
    		for(i=1; i<=m; i++){
    			x = GET_VEC_ELT(arg,i);
        	push_s(x);
    		}
    	}
    	else if(arg == empty_set){
    		m = 0;
    	}
    	else{
    		m = 1;
			push_s(arg);
    	}
		code[pc + 5] = m;
        pc = pc + 1;
        end = clock();
        prof_dt[37].count++;
        prof_dt[37].time = prof_dt[37].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
        
    CASE_DEFLIB:
     	step();
        start = clock();
        
        export_id = NIL;
        export_rename = NIL;
        x = ARG1; //name
        y = ARG2; //body
        for(i=0; i<module_table_end; i++)
        	if(equalp(module_table[i][0],x))
            	goto deflib_exit;
        
        module_table[i][0] = x;
        module_table_end++;
        
        deflib_exit:
        current_module = i;
        y = remake(y);
		
        while(!nullp(y)){
        	current_module = 0;
        	arg = cons(make_int(2),
    		       cons(car(y),
                    cons(make_int(4),
                     cons(make_sym("compile"),
                      cons(make_int(13),
                       cons(make_int(1),
                        cons(make_int(4),
                         cons(make_sym("assemble"),
                          cons(make_int(13),
                           cons(make_int(1),
                            cons(make_int(1),NIL)))))))))));
        
        	savepc = pc;
        	savesp = sp;
        	saveenv = env;
            list_to_code(arg);
            pc = head;
        	m = vm1();
        	list_to_code(m);
            pc = head;
            current_module = i;
        	vm1();
        	pc = savepc;
        	sp = savesp;
        	env = saveenv;
            y = cdr(y);
        }
        while(!nullp(export_rename)){
        	m = car(export_rename);
            n = car(m);
            o = car(cdr(m));
            SET_CAR(o,GET_CAR(n));
            export_id = cons(o,export_id);
            export_rename = cdr(export_rename);
        }
        module_table[i][1] = export_id;
        
		y = module_table[i][1];
        while(!nullp(y)){
        	m = car(y);
        	if(GET_CAR(m) == undef)
            	exception("", UNBOUND_VARIABLE, m);
        	y = cdr(y);
        }
        current_module = 0;
        pc = pc + 3;
        
        end = clock();
        prof_dt[38].count++;
        prof_dt[38].time = prof_dt[38].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_EXPLIB:
    	step();
        start = clock();
        
        x = ARG1; //id-list
        while(!nullp(x)){
        	if(eqp(car(car(x)),make_sym("rename")))
        		export_rename = cons(cdr(car(x)),export_rename);
        	else
        		export_id = cons(car(x),export_id);
            
            x = cdr(x);
        }
        push_s(undef);
        pc = pc + 2;
        
        end = clock();
        prof_dt[39].count++;
        prof_dt[39].time = prof_dt[39].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
    
    CASE_IMPLIB:
    	step();
        start = clock();
        
        x = ARG1; //<name idintifier>
        while(!nullp(x)){
        	m = car(x);
        	for(i=0; i<module_table_end; i++)
        		if(equalp(module_table[i][0],m))
            		goto implib_exit;
        
        	exception("", NOT_EXIST_LIB, m);
        
        	implib_exit:
        	y = module_table[i][1]; //export-list
        
        	while(!nullp(y)){
        		n = car(y);
            	SET_CAR(remake(n),GET_CAR(n));
            	y = cdr(y);
        	}
            x = cdr(x);
        }
        push_s(undef);
        pc = pc + 2;
        
        end = clock();
        prof_dt[40].count++;
        prof_dt[40].time = prof_dt[40].time + (end - start);
        VM_ERR_CHK;
        goto *JUMPTABLE[code[pc]];
}


//--------------------------------------
void push_s(int x){
	stack[sp] = x;
    sp++;
    if(sp > STACKSIZE)
     	exception("",STACK_OVERF,NIL);
}

int pop_s(void){
	sp--;
	return(stack[sp]);
}


void insert_stack(int env, int pc, int n){
	int i,j;
    
    i = sp-1;
    for(j=n; j>0; j--){
    	stack[i+2] = stack[i];
        i--;
    }
    stack[sp-n] = pc;
    stack[sp-n+1] = env;
    sp = sp + 2;	
}


void list_to_code(int lis){
    int addr,i;
    
    head = tail;
    addr = tail;
    while(!nullp(lis)){
    	i = get_int(car(lis));
        switch(i){	
			case 1:	code[addr] = i;
            		break;
            case 2:	code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    break;
            case 3:	code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    break;
            case 4:	code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    break;
            case 5:	code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    addr++;
                    code[addr] = get_int(car(lis));
                    break;
            case 6:	code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    break;
            case 7:	code[addr] = i;
            		break;
            case 8:
            case 9:
            case 10:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    break;
            case 11:code[addr] = i;
            		break;
            case 12:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    break;
            case 13:
            case 14:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    break;
            case 15:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    break;
            case 16:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    break;
            case 17:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    if(symbolp(car(lis)))
                    	code[addr] = car(lis);
                    else
                    	code[addr] = get_int(car(lis));
                    addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
                    break;
            case 18:
            case 19:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    break;
            case 20:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    addr++;
                    lis = cdr(lis);
                    code[addr] = get_int(car(lis));
        			break;
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:code[addr] = i;
                    break;
            case 31:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    break;
            case 32:code[addr] = i;
                    break;
            case 33:code[addr] = i;
            		break;
            case 34:
            case 35:
            case 36:code[addr] = i;
                    break;
            case 37:code[addr] = i;
            		break;
            case 38:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    break;
            case 39:
            case 40:code[addr] = i;
            		addr++;
                    lis = cdr(lis);
                    code[addr] = car(lis);
                    break;  
        }
		addr++;
        if(addr > CODESIZE)
        	exception("",CODE_OVERF,NIL);
        lis = cdr(lis);
    }
    tail = addr;
}


int list_to_code_obj(int lis){
	int i,x,code_obj;

	code_obj = make_code(length(lis));
    i = 0;
    while(!nullp(lis)){
   	x = get_int(car(lis));
    switch(x){	
		case 1:	SET_VEC_ELT(code_obj,i,x);        		
    			break;
    	case 2:	SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,car(lis));
        		break;
    	case 3:	SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		break;
    	case 4:	SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,car(lis));
        		break;
    	case 5:	SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		i++;
				lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		break;
    	case 6:	SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,car(lis));
        		break;
    	case 7:	SET_VEC_ELT(code_obj,i,x);
    			break;
    	case 8:
    	case 9:
   		case 10:SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		break;
    	case 11:SET_VEC_ELT(code_obj,i,x);
    			break;
    	case 12:SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		break;
    	case 13:
    	case 14:SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		break;
    	case 15:SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		i++;
        		lis = cdr(lis);
       			SET_VEC_ELT(code_obj,i,list_to_code_obj(car(lis)));
        		break;
    	case 16:SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		break;
    	case 17:SET_VEC_ELT(code_obj,i,x);
    			i++;
        		lis = cdr(lis);
                if(symbolp(car(lis)))
                	SET_VEC_ELT(code_obj,i,car(lis));
                else
        			SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		break;
    	case 18:
    	case 19:SET_VEC_ELT(code_obj,i,x);
    			i++;
            	lis = cdr(lis);
            	SET_VEC_ELT(code_obj,i,car(lis));
            	break;
        case 20:SET_VEC_ELT(code_obj,i,x);
        		i++;
            	lis = cdr(lis);
            	SET_VEC_ELT(code_obj,i,car(lis));
            	i++;
            	lis = cdr(lis);
            	SET_VEC_ELT(code_obj,i,get_int(car(lis)));
        		break;   
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:SET_VEC_ELT(code_obj,i,x);
        		break;
        case 31:SET_VEC_ELT(code_obj,i,x);
        		i++;
                lis = cdr(lis);
                SET_VEC_ELT(code_obj,i,car(lis));
                break;
        case 32:SET_VEC_ELT(code_obj,i,x);
        		break;
        case 33:SET_VEC_ELT(code_obj,i,x);
        		break;
        case 34:
        case 35:
        case 36:SET_VEC_ELT(code_obj,i,x);
                break;
        case 37:SET_VEC_ELT(code_obj,i,x);
        		break;
        case 38:SET_VEC_ELT(code_obj,i,x);
        		i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,car(lis));
                i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,car(lis));
        		break;
        case 39:
        case 40:SET_VEC_ELT(code_obj,i,x);
        		i++;
        		lis = cdr(lis);
        		SET_VEC_ELT(code_obj,i,car(lis));
                break;
        }
		i++;
        lis = cdr(lis);
    }
    return(code_obj);
}


int count_stack(void){
	int i,count;
    
    i = sp -1;
    count = 0;
    while(i > 0 && (GET_TAG(stack[i]) != ENV)){
    	i--;
        count++;
    }
    return(count);   
}

int find_code_pointer(int addr){
	int i;
    
    for(i=0; i<code_pointer_end; i++)
    	if(code_pointer[i][0] == addr)
        	return(code_pointer[i][1]);
    
    return(-1);
}

void step(void){
	int i,j,size_n,size_m,addr;
    char c;
    
    if(stepflag == 0)
    	return;

    printf("pc: %d \n" ,pc);
    addr = pc;
    for(i=0; i<3; i++){
    	printf("code[%d] ",addr);
        addr = disasm(addr);
    }
	
	printf("sp: %d \n", sp);
	for(i=0; i<sp; i++){
    	printf("stack[%d] ", i);
        if(GET_TAG(stack[i+1]) == ENV && (i+1<sp))
        	printf("%d", stack[i]); //–ß‚èƒAƒhƒŒƒX‚Ìê‡
        else
        	print(stack[i]);
        printf("\n");
	}
    printf("env: \n");
	size_n = GET_AUX(env);
    size_m = GET_CDR(env);
    for(i=0; i<size_m ; i++){
		for(j=0; j<size_n; j++){
        	printf("[");
            print(GET_ENV_MAT_ELT(env,i,j));
        	printf("]");
        }
        printf("\n");
    }
            
	printf("> ");
	fflush(stdout);
    fflush(stdin);
	c = getc(stdin);
	if(c == 'q' || c == 'Q'){
    	stepflag = 0;
        longjmp(toplevel,1);	
    }
    if(c == 'c'){
    	for(i=0; i<=50; i++)
    		printf("[%d]", code[i]);
        printf("\n");
    }
}

int disasm(int addr){
	int op;
    
    op = code[addr];
    switch(op){
    	case 0:	printf("nop\n");
        		break;
        case 1: printf("halt\n");
        		break;
        case 2: printf("const ");
        		print(code[addr+1]);
                printf("\n");
                addr++;
                break;
        case 3: printf("lvar %d %d\n", code[addr+1], code[addr+2]);
                addr = addr + 2;
                break;
        case 4:	printf("gvar ");
				print(code[addr+1]);
                printf("\n");
        		break;
        case 5: printf("lset %d %d\n", code[addr+1], code[addr+2]);
                addr = addr + 2;
                break;
        case 6:	printf("gset\n");
        		print(code[addr+1]);
                printf("\n");
        		break;
        case 7:	printf("pop\n");
        		break;
        case 8: printf("jump %d\n", code[addr+1]);
        		addr++;
        		break;
        case 9:	printf("tump %d\n", code[addr+1]);
        		addr++;
        		break;
        case 10:printf("fump %d\n", code[addr+1]);
        		addr++;
        		break;
        case 11:printf("return\n");
        		break;
    	case 12:printf("args %d\n", code[addr+1]);
        		addr++;
        		break;
        case 13:printf("call %d\n", code[addr+1]);
        		addr++;
        		break;
        case 14:printf("callj %d\n", code[addr+1]);
        		addr++;
        		break;
        case 15:printf("fn %d <code>\n", code[addr+1]);
                addr = addr + 2;
        		break;
        case 16:printf("save %d", code[addr+1]);
        		break;
        case 17:printf("prim ");
        		print(code[addr+1]);
                printf(" ");
                printf("%d\n", code[addr+2]);
                addr = addr + 2;
        		break;
        case 18:printf("def ");
        		print(code[addr+1]);
                printf("\n");
                break;
        case 19:printf("defm ");
        		print(code[addr+1]);
                printf("\n");
                break;
        case 20:printf("defh ");
        		print(code[addr+1]);
                printf(" ");
                print(code[addr+2]);
                printf("\n");
                addr = addr + 2;
                break;
        case 21:printf("neqp\n");
        		break;
        case 22:printf("smlp\n");
        		break;
        case 23:printf("esmlp\n");
        		break;
        case 24:printf("grtp\n");
        		break;
        case 25:printf("egrtp\n");
        		break;
        case 26:printf("zerop\n");
        		break;
        case 27:printf("add1\n");
        		break;
        case 28:printf("sub1\n");
        		break;
        case 29:printf("add2\n");
        		break;
        case 30:printf("sub2\n");
        		break;
        case 31:printf("gref ");
        		print(code[addr+1]);
                printf("\n");
                addr++;
                break;
        case 32:printf("catch\n");
        		break;
        case 33:printf("pause\n");
        		break;
        case 34:printf("car\n");
        		break;
        case 35:printf("cdr\n");
        		break;
        case 36:printf("cons\n");
        		break;
		case 37:printf("adapt\n");
        		break;
        case 38:printf("deflib ");
        		print(code[addr+1]);
                printf(" ");
                print(code[addr+2]);
                printf("\n");
                addr = addr + 2;
                break;
        case 39:printf("explib ");
        		print(code[addr+1]);
                printf("\n");
                addr++;
                break;
        case 40:printf("implib ");
        		print(code[addr+1]);
                printf("\n");
                addr++;
                break;
    }
    addr++;
    return(addr);
}

int stack_to_list(int n){
	int res,i;
    
    res = NIL;
    for(i=0; i<n; i++){
    	res = cons(stack[sp-1-i],res);
    }
    return(res);
}

void push_back_trace(int proc, int args){
	int i;
    
    if(back_trace_end < TRACE_DEPTH){
    	back_trace[back_trace_end][0] = proc;
        back_trace[back_trace_end][1] = args;
        back_trace_end++;
    }
    else{
    	for(i=0; i<TRACE_DEPTH-1; i++){
        	back_trace[i][0] = back_trace[i+1][0];
            back_trace[i][1] = back_trace[i+1][1];
        }
        back_trace[i][0] = proc;
        back_trace[i][1] = args;
    }	
}

//-------read()--------
int read(void){
	char *e;
    double r,s,x,y;
    int tag;
                
    gettoken();
    tag = (int)stok.type;
    switch(tag){
    	case FILEEND:	return(end_of_file);
    	case INTEGER:	if(stok.exact == YES)
        					return(make_int(atoi(stok.buf)));
        				else
                        	return(exact_to_inexact(make_int(atoi(stok.buf))));
        case BIGNUM:	if(stok.exact == YES)
        					return(make_big(stok.buf));
        				else
                        	return(make_flt(bignumtofloat(make_big(stok.buf))));
        case BINARY:	return(make_int((int)strtol(stok.buf,&e,2)));
        case OCTAL:		return(make_int((int)strtol(stok.buf,&e,8)));
        case DECNUM:	return(make_int((int)strtol(stok.buf,&e,10)));
        case HEXNUM: 	return(make_int((int)strtol(stok.buf,&e,16)));
        case EXPTNUM:	return(make_flt(atof(stok.buf)));	
        case FLOAT_N:	if(stok.exact == NO)
        					return(make_flt(atof(stok.buf)));
        				else
                        	return(inexact_to_exact(make_flt(atof(stok.buf))));
        case RATIONAL:	if(stok.exact == YES)
        					return(make_rat(atoi(stok.before),atoi(stok.after)));
        				else
                        	return(exact_to_inexact(make_rat(atoi(stok.before),atoi(stok.after))));
        case COMPLEX:	if(stok.ctype == RECTANGLER)	
                            return(make_comp(atof(stok.before),atof(stok.after)));
                        //POLAR
                        else{
                        	r = atof(stok.before);
    						s = atof(stok.after);
    						x = r * cos(s);
    						y = r * sin(s);
    						return(make_comp(x,y));
                        }
        case SYMBOL:	return(make_sym(stok.buf));
        case SBOOL:		return(returnbool(stok.buf));
        case STRING:	return(make_str(stok.buf));
        case CHARACTER:	return(make_char(stok.buf));
        case QUOTE:		return(cons(quote, cons(read(),NIL)));
        case QUASIQUOTE:return(cons(quasiquote,cons(read(),NIL)));
        case UNQUOTE:  {gettoken();
        				switch(stok.type){
                        	case SPLICING:	return(cons(unquote_splicing,cons(read(),NIL)));
                            default:   {stok.flag = BACK;
                            			return(cons(unquote,cons(read(),NIL)));}
                        }}
        case LPAREN:	return(readlist());
        case VECTOR:	return(vector(readlist()));
        case RPAREN:	exception("",EXTRA_PAREN, NIL);
    }				
    exception("",CANT_READ,make_str(stok.buf));
    return(undef);
}

int readlist(void){
    int car_elt,cdr_elt;
    
    gettoken();      
    if(stok.type == RPAREN)
    	return(NIL);
    else
    if(stok.type == DOT){
    	cdr_elt = read();
        if(atomp(cdr_elt) 
        	|| (pairp(cdr_elt) && eqp(car(cdr_elt),unquote)) 
        	|| (pairp(cdr_elt) && eqp(car(cdr_elt),unquote_splicing)))
        	gettoken();
        return(cdr_elt);
    }
    else{
    	stok.flag = BACK;
    	car_elt = read();
        cdr_elt = readlist();
        return(cons(car_elt,cdr_elt));
    }
}

int issymch(char c){
	switch(c){
    	case '!':
        case '?':
        case '+':
        case '-':
        case '*':
        case '/':
        case '=':
        case '<':
        case '>': 
        case '_':
        case '.': 
        case ':': 
        case '#': 
        case '$': 
        case '@':
        case '%':
        case '&':
        case '~':
        case '^': return(1);
        default:  return(0);
    }
}  



void gettoken(void){
	char c;
    int pos;
    
    if(stok.flag == BACK){
    	stok.flag = GO;
        return;
    }
    
    if(stok.ch == ')'){
    	stok.type = RPAREN;
        stok.ch = NUL;
        return;
    }
    
    if(stok.ch == '('){
    	stok.type = LPAREN;
        stok.ch = NUL;
        return;
    }

	c = tolower(getc(input_port));
    
 	skip:
    //ƒXƒy[ƒX“™‚ÌƒXƒLƒbƒv
    while((c == SPACE) || (c == EOL) || (c == TAB))
    	c = getc(input_port);
    
    //ƒRƒƒ“ƒgs‚ÌƒXƒLƒbƒv
    //ƒRƒƒ“ƒgs‚Ìs––‚ÉEOF‚ª‚ ‚Á‚½ê‡‚É‚ÍFILEEND‚ğ•Ô‚·B
    if(c == ';'){
    	while(!(c == EOL)){
        	c = getc(input_port);
        	if(c == EOF){
    			stok.type = FILEEND;
                return;
            }
        }
        goto skip;
    }
    
    //ƒtƒ@ƒCƒ‹‚ÌI’[‚È‚çFILEEND‚ğ•Ô‚·B
    if(c == EOF){
    	stok.type = FILEEND;
    	return;
    }
    
    switch(c){
    	case '(':	stok.type = LPAREN; break;
        case ')':	stok.type = RPAREN; break;
        case '\'':	stok.type = QUOTE; break;
        case '`':	stok.type = QUASIQUOTE; break;
        case ',':  	stok.type = UNQUOTE; break;
        case '@':	stok.type = SPLICING; break;
        case '.':  {c = getc(input_port);
        			//Œã‚ë‚ª‹ó”’‚Ìdot‚Ídot-pair‚Æ‰ğß
        			if(c == SPACE){
        				stok.type = DOT;
                        break;
                    }
                    //‚»‚êˆÈŠO‚ÍƒVƒ“ƒ{ƒ‹‚Æ‰ğß
        			else{
                    	stok.buf[0] = '.';
                        stok.buf[1] = c;
                        pos = 2;
                        goto dot_exception;
                    }
                    }	
        case '"':  {c = getc(input_port);
        			pos = 0;
               		while(c != '"'){
                    	switch(c){
                    		case EOL:	stok.buf[pos++] = '\\';
                            			stok.buf[pos++] = 'n'; break;
                            case RET:	stok.buf[pos++] = '\\';
                            			stok.buf[pos++] = 'r'; break;
                            case TAB:	stok.buf[pos++] = '\\';
                            			stok.buf[pos++] = 't'; break;
                            case '\\':	stok.buf[pos++] = c;
                            			c = getc(input_port);
                                        stok.buf[pos++] = c; break;
                            default:	stok.buf[pos++] = c;
                        }
                        c = getc(input_port);
                    }
                    stok.buf[pos] = NUL;
                    stok.type = STRING;
                    break;
                    }
        case '#':  {c = getc(input_port);
        			if(c == '(' ){
                    	stok.type = VECTOR;
                        break;
                    }
                    if(c == '\\'){
                		pos = 0;
                    	c = getc(input_port);
                        stok.buf[pos++] = c;
                        while(((c=getc(input_port)) != EOL) && (pos < BUFSIZE) && 
            					(c != SPACE) && (c != '(') && (c != ')'))
            				stok.buf[pos++] = c;
            
            			stok.buf[pos] = NUL;
                        stok.type = CHARACTER;
            			stok.ch = c;
                        break;
                    }
                    ungetc(c, input_port);
                    c = '#';
                    }		
        default: {
        	pos = 0; stok.buf[pos++] = c;
            dot_exception:
        	while(((c=tolower(getc(input_port))) != EOL) && (pos < BUFSIZE) && 
            		(c != SPACE) && (c != '(') && (c != ')'))
            	stok.buf[pos++] = c;
            
            stok.buf[pos] = NUL;
            stok.ch = c;
        	
            //æ‚É•¡‘f”‚Ì”»’è‚ğ‚µ‚È‚¢‚Æ-1-2i‚Ì‚æ‚¤‚ÈƒP[ƒX‚ÅƒVƒ“ƒ{ƒ‹‚É‚È‚Á‚Ä‚µ‚Ü‚¤B
            if(comptoken(stok.buf)){
            	stok.type = COMPLEX;
                stok.ctype = RECTANGLER;
                break;
            }
            if(polar_comptoken(stok.buf)){
            	stok.type = COMPLEX;
                stok.ctype = POLAR;
                break;
            }
            //æ‚Ébignum‚Ì”»’è‚ğ‚·‚éBinttoken()‚ÍŒ…”‚Ì”»’è‚ğ‚µ‚Ä‚¢‚È‚¢B
            if(bignumtoken(stok.buf)){
            	stok.type = BIGNUM;
                break;
            }
            if(exact_bignumtoken(stok.buf)){
            	stok.type = BIGNUM;
                stok.exact = YES;
                break;
            }
            if(inexact_bignumtoken(stok.buf)){
            	stok.type = BIGNUM;
                stok.exact = NO;
                break;
            }
            if(inttoken(stok.buf)){
            	stok.type = INTEGER;
                stok.exact = YES;
                break;
            }
            if(exact_inttoken(stok.buf)){
            	stok.type = INTEGER;
                stok.exact = YES;
                break;
            }
            if(inexact_inttoken(stok.buf)){
            	stok.type = INTEGER;
                stok.exact = NO;
                break;
            }
            if(flttoken(stok.buf)){
            	stok.type = FLOAT_N;
                stok.exact = NO;
                break;
            }
            if(exact_flttoken(stok.buf)){
            	stok.type = FLOAT_N;
                stok.exact = YES;
                break;
            }
            if(inexact_flttoken(stok.buf)){
            	stok.type = FLOAT_N;
                stok.exact = NO;
                break;
            }
            if(rattoken(stok.buf)){
            	stok.type = RATIONAL;
                stok.exact = YES;
                break;
            }
            if(exact_rattoken(stok.buf)){
            	stok.type = RATIONAL;
                stok.exact = YES;
                break;
            }
            if(inexact_rattoken(stok.buf)){
            	stok.type = RATIONAL;
                stok.exact = NO;
                break;
            }
            if(bintoken(stok.buf)){
            	stok.type = BINARY;
                break;
            }
            if(octtoken(stok.buf)){
            	stok.type = OCTAL;
                break;
            }
    		if(dectoken(stok.buf)){
            	stok.type = DECNUM;
                break;
            }
            if(hextoken(stok.buf)){
            	stok.type = HEXNUM;
                break;
            }
            if(expttoken(stok.buf)){
            	stok.type = EXPTNUM;
                break;
            }
            if(booltoken(stok.buf)){
            	stok.type = SBOOL;
                break;
            }
            if(symtoken(stok.buf)){
            	stok.type = SYMBOL;
                break;
            }	
            stok.type = OTHER;  
        }
    }
}


septoken separater(char buf[], char sep){
	int i,j;
    char c;
    septoken res;
    
    res.sepch = NUL;
    res.before[0] = buf[0];
    i = 1; j = 1; 
    while((c=buf[i]) != NUL)
    	if(c == sep){
        	res.before[j] = NUL;
            res.sepch = sep;
        	i++;
            j = 0;
            while((c=buf[i]) != NUL){
            	res.after[j] = c;
                i++;j++;
            }
            res.after[j] = NUL;
        }     
        else{
        	res.before[j] = c;
        	i++; j++;
        }
    return(res);
}	

void insertstr(char ch, char buf[]){
	int i;
    
    i = laststr(buf)+1;
    while(i >= 0){
    	buf[i+1] = buf[i];
        i--;
    }
    buf[0] = ch;
}

    
   
int laststr(char buf[]){
	int i;
    
    i = 0;
    while(buf[i] != NUL)
    	i++;
    return(i-1);
}



//•¶š‚Ì#\a -> a @#\‚ğæ‚èœ‚­
void dropchar(char buf[]){
	int i,j;
    
    j = laststr(buf);
    for(i=2; i<=j; i++)
    	buf[i-2] = buf[i];
    buf[i-2] = NUL;
}

//•„†‚ ‚è®” Œ…”‚Í”»’è‚µ‚Ä‚¢‚È‚¢B
int inttoken(char buf[]){
	int i;
    char c;
    
    if(((buf[0] == '+') || (buf[0] == '-'))){
		if(buf[1] == NUL)
        	return(0); // case {+,-} => symbol
    	i = 1;
    	while((c=buf[i]) != NUL)
        	if(isdigit(c))
            	i++;  // case {+123..., -123...}
            else
            	return(0);
    }
    else {       
    	i = 0;    // {1234...}
    	while((c=buf[i]) != NUL)
    		if(isdigit(c))
        		i++;
        	else 
        		return(0);
    }
    return(1);
}

// ³Šm‚È®”
int exact_inttoken(char buf[]){
    char buf1[BUFSIZE];
    
    if(buf[0] == '#' && buf[1] == 'e'){
    	strcpy(buf1,buf);
    	dropchar(buf1);
        if(inttoken(buf1)){
        	dropchar(buf);
    		return(1);
        }
        else
        	return(0);
	}
    else
    	return(0);
}

// ”ñ³Šm‚È®”
int inexact_inttoken(char buf[]){
    char buf1[BUFSIZE];
    
    if(buf[0] == '#' && buf[1] == 'i'){
    	strcpy(buf1,buf);
    	dropchar(buf1);
        if(inttoken(buf1)){
        	dropchar(buf);
    		return(1);
        }
        else
        	return(0);
	}
    else
    	return(0);
}

//•„†‚È‚µ®”
int inttoken_nsgn(char buf[]){
	int i;
    char c;
    
    i = 0;
	while((c=buf[i]) != NUL)
    	if(isdigit(c))
        	i++;
        else 
        	return(0);
    return(1);
}

//bignum
//•„†‚ğŠÜ‚ß‚È‚¢‚Å‚XƒPƒ^
int bignumtoken(char buf[]){
	int i;
    char c;
    
    if(((buf[0] == '+') || (buf[0] == '-'))){
		if(buf[1] == NUL)
        	return(0); // case {+,-} => symbol
    	i = 1;
    	while((c=buf[i]) != NUL)
        	if(isdigit(c))
            	i++;  // case {+123..., -123...}
            else
            	return(0);
        if(strlen(buf) <= 10)
        	return(0); //case not bignum 
    }
    else {       
    	i = 0;    // {1234...}
    	while((c=buf[i]) != NUL)
    		if(isdigit(c))
        		i++;
        	else 
        		return(0);
        if(strlen(buf) <= 9)
        	return(0); //case not bignum
    }
    return(1); //bignum
}

// ³Šm‚È‹‘å®”
int exact_bignumtoken(char buf[]){
    char buf1[BUFSIZE];
    
    if(buf[0] == '#' && buf[1] == 'e'){
    	strcpy(buf1,buf);
    	dropchar(buf1);
        if(bignumtoken(buf1)){
        	dropchar(buf);
    		return(1);
        }
        else
        	return(0);
	}
    else
    	return(0);
}

// ”ñ³Šm‚È‹‘å®”
int inexact_bignumtoken(char buf[]){
    char buf1[BUFSIZE];
    
    if(buf[0] == '#' && buf[1] == 'i'){
    	strcpy(buf1,buf);
    	dropchar(buf1);
        if(bignumtoken(buf1)){
        	dropchar(buf);
    		return(1);
        }
        else
        	return(0);
	}
    else
    	return(0);
}

int rattoken(char buf[]){
	septoken tok;
    
    tok = separater(buf, '/');
    
    if(tok.sepch == NUL)
    	return(0);
    
    if(inttoken(tok.before) && inttoken_nsgn(tok.after)){
    	strcpy(stok.before, tok.before);
       	strcpy(stok.after, tok.after);
       	return(1);
    }
    else
    	return(0);
}

int exact_rattoken(char buf[]){
    char buf1[BUFSIZE];
    
    if(buf[0] == '#' && buf[1] == 'e'){
    	strcpy(buf1,buf);
    	dropchar(buf1);
        if(rattoken(buf1)){
        	dropchar(buf);
    		return(1);
        }
        else
        	return(0);
	}
    else
    	return(0);
}

int inexact_rattoken(char buf[]){
    char buf1[BUFSIZE];
    
    if(buf[0] == '#' && buf[1] == 'i'){
    	strcpy(buf1,buf);
    	dropchar(buf1);
        if(rattoken(buf1)){
        	dropchar(buf);
    		return(1);
        }
        else
        	return(0);
	}
    else
    	return(0);
}

int bintoken(char buf[]){
	int i;
    char c;
    
    if(!(buf[0] == '#' && (buf[1] == 'b' || buf[1] == 'B')))
    	return(0);
    
    i = 2;
    while((c=buf[i]) != NUL)
    	if(c == '0' || c == '1')
        	i++;
        else
        	return(0);
    
    dropchar(buf);
    return(1);
}


int flttoken(char buf[]){
    septoken tok;
    char bufcp[SYMSIZE];
    
    if(buf[0] == '.'){
    	strcpy(bufcp,buf);
    	insertstr('0',bufcp);
        if(flttoken(bufcp))
        	return(1);
    }
    
    tok = separater(buf, '.'); 
    
    if(tok.sepch == NUL)
    	return(0);

    if(inttoken(tok.before) && inttoken_nsgn(tok.after))
    	return(1);
    else
    if((strcmp(tok.before,"-") == 0) && inttoken_nsgn(tok.after))
    	return(1);
    else
    	return(0);
}

int exact_flttoken(char buf[]){
    char buf1[BUFSIZE];
    
    if(buf[0] == '#' && buf[1] == 'e'){
    	strcpy(buf1,buf);
    	dropchar(buf1);
        if(flttoken(buf1)){
        	dropchar(buf);
    		return(1);
        }
        else
        	return(0);
	}
    else
    	return(0);
}

int inexact_flttoken(char buf[]){
    char buf1[BUFSIZE];
    
    if(buf[0] == '#' && buf[1] == 'i'){
    	strcpy(buf1,buf);
    	dropchar(buf1);
        if(flttoken(buf1)){
        	dropchar(buf);
    		return(1);
        }
        else
        	return(0);
	}
    else
    	return(0);
}

int comptoken(char buf[]){
	septoken tok;
    int lastindex;
    
    lastindex = laststr(buf);
    
    if(buf[lastindex] != 'i')
    	return(0);
    
    // +i -> 0+1i
    if(buf[0] == '+' && buf[1] == 'i' && buf[2] == NUL){
    	strcpy(stok.before,"0");
        strcpy(stok.after,"1");
        return(1);
    }
    
    // -i -> 0-1i
    if(buf[0] == '-' && buf[1] == 'i' && buf[2] == NUL){
    	strcpy(stok.before,"0");
        strcpy(stok.after,"-1");
        return(1);
    }
         
    buf[lastindex] = NUL; // ‹•”’PˆÊ‚Ìi‚ğíœ‚·‚éB
    
    tok = separater(buf, '+');
    
    if(tok.sepch == NUL)
    	goto minus;
    
    //1+i‚Ì‚æ‚¤‚Èê‡
    if((inttoken(tok.before) || flttoken(tok.before)) &&
    	tok.after[0] == NUL){
    	strcpy(stok.before, tok.before);
        stok.after[0] = '1';
        stok.after[1] = NUL;
    	return(1);
    }
    
    //’Êí‚Ìn+mi‚Ìê‡
    if((inttoken(tok.before)  || flttoken(tok.before)) &&
    	(inttoken(tok.after) || flttoken(tok.after))){
    	strcpy(stok.before, tok.before);
       	strcpy(stok.after, tok.after);
       	return(1);
    }
    
    minus: //—á 1-2i
    
    tok = separater(buf, '-');
    
    if(tok.sepch == NUL)
    	goto failexit;
    
    insertstr('-', tok.after);
    
    //1-i‚Ì‚æ‚¤‚Èê‡
    if((inttoken(tok.before) || flttoken(tok.before)) &&
    	tok.after[1] == NUL){
    	strcpy(stok.before, tok.before);
        stok.after[0] = '-';
        stok.after[1] = '1';
        stok.after[2] = NUL;
    	return(1);
    }
        
    //’Êí‚Ìn-mi‚Ìê‡
    if((inttoken(tok.before)  || flttoken(tok.before)) &&
    	(inttoken(tok.after) || flttoken(tok.after))){
       	strcpy(stok.before, tok.before);
       	strcpy(stok.after, tok.after);
       	return(1);
    }
    else
    	goto failexit;
    
    failexit: //•¡‘f”‚Å‚Í‚È‚¢ê‡
    
    buf[lastindex] = 'i'; //íœ‚µ‚½i‚ğ•œŒ³
    return(0);
}

int polar_comptoken(char buf[]){
	septoken tok;
    
    tok = separater(buf, '@');
    
    if(tok.sepch == NUL)
    	return(0);
    
    if((inttoken(tok.before)  || flttoken(tok.before)) &&
    	(inttoken(tok.after) || flttoken(tok.after))){
    	strcpy(stok.before, tok.before);
       	strcpy(stok.after, tok.after);
       	return(1);
    }
    return(0);
}

int octtoken(char buf[]){
	int i;
    char c;
    
    if(!(buf[0] == '#' && (buf[1] == 'o' || buf[1] == 'O')))
    	return(0);
    
    i = 2;
    while((c=buf[i]) != NUL)
    	if(c == '0' || c == '1' || c == '2' || c == '3' || c == '4' ||
           c == '5' || c == '6' || c == '7')
        	i++;
        else
        	return(0);
    
    dropchar(buf);
    return(1);
}

int dectoken(char buf[]){
	int i;
    char c;
    
    if(!(buf[0] == '#' && (buf[1] == 'd' || buf[1] == 'D')))
    	return(0);
    
    i = 2;
    while((c=buf[i]) != NUL)
    	if(isdigit(c))
        	i++;
        else
        	return(0);
    
    dropchar(buf);
    return(1);
}

int hextoken(char buf[]){
	int i;
    char c;
    
    if(!(buf[0] == '#' && (buf[1] == 'x' || buf[1] == 'X')))
    	return(0);
    
    i = 2;
    while((c=buf[i]) != NUL)
    	if(isdigit(c) ||
         c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' ||
         c == 'a' || c == 'b' || c == 'c' || c == 'd' || c == 'e' || c == 'f')
        	i++;
        else
        	return(0);
    
    dropchar(buf);
    return(1);
}

int expttoken(char buf[]){
	septoken tok;
    
    tok = separater(buf, 'e');
    if(tok.sepch == NUL)
    	return(0);
    
    if((inttoken(tok.before)  || flttoken(tok.before)) &&
    	inttoken(tok.after)){

       	return(1);
    }
    else
    	return(0);
}

int symtoken(char buf[]){
	int i;
    char c;
    
    //printf("%s\n", buf);
    
    i = 0;
    while((c=buf[i]) != NUL)
    	if((isalpha(c)) || (isdigit(c)) || (issymch(c)))
        	i++;
        else 
        	return(0);
    
    return(1);
}

int booltoken(char buf[]){
	if(!(buf[0] == '#'))
    	return(0);
    if(!(buf[1] == 't' || buf[1] == 'T' 
    	|| buf[1] == 'f' || buf[1] == 'F'))
        return(0);
    if(!(buf[2] == NUL))
    	return(0);
    
    return(1);
}


int charcmp(char buf[], char cmp[]){
	int i;
    
    i = 2;
    while(buf[i] != NUL){
    	if(buf[i] == cmp[i-2])
        	i++;
        else
        	return(0);
    }
    if(cmp[i-2] == NUL)
        return(1);
    else
    	return(0);
}



//-------internal define--------------
//internl-define‚ğletrec‚É’u‚«Š·‚¦‚éB
               
int define_to_letrec(int lis){
	int e;
    
    if(definep(lis)){
    	e = formal_define(lis);
        return(list3(car(e),cadr(e),replace(caddr(e))));
    }
    else
    	return(replace(lis));
    
}

//(define ...)‚©‚Ç‚¤‚©H
int definep(x){
	if(listp(x) && eqvp(car(x),make_sym("define")))
    	return(1);
    else
    	return(0);
    
    return(undef);
}

//letrec‚É’u‚«Š·‚¦‚éB
int replace(int lis){
    
    //lambda,let,let*,letrec‚Ìê‡
	if(listp(lis) && 
      (eqp(car(lis),make_sym("lambda")) || eqp(car(lis),make_sym("let")) ||
       eqp(car(lis),make_sym("letrec")) || eqp(car(lis),make_sym("let*"))))
        return(cons(car(lis),cons(cadr(lis),replace1(cddr(lis)))));
    else
    	return(lis);
    
    return(undef);
}

//®‚ğ’è‹`•”‚Æ–{‘Ì‚É•ª‚¯‚½‚à‚Ì‚ğó‚¯æ‚èletrec‚É’u‚«Š·‚¦‚éB
int replace1(int lis){
        int e,body,res;
    
    e = replace2(lis);
    if(nullp(car(e))){
        body = cdr(e);
        res = NIL;
        while(!nullp(body)){
        	res = cons(replace(car(body)),res);
        	body = cdr(body);
        }
        return(reverse(res));
    }
    else
        return(list1(cons(make_sym("letrec"),cons(reverse(car(e)),cdr(e)))));
    
    return(undef);
}


//®‚ğ’è‹`•”‚Æ–{‘Ì‚É•ª—£
int replace2(int lis){
                
	return(replace3(lis,NIL));
}

//ã‹L‚Ì–{‘ÌB
int replace3(int lis, int def){
	int e;
    
    if(definep(car(lis))){
    	e = formal_define(car(lis));
        return(replace3(cdr(lis),cons(list2(cadr(e),replace(caddr(e))),def)));
    }
    else
    	return(cons(def,lis));
    
    return(undef);
    	
}

//MITƒXƒ^ƒCƒ‹‚Ì’è‹`®‚ğ³®‚È(define sym (lambda (x) ...)‚É•ÏŠ·B
int formal_define(int lis){
	if(atomp(cadr(lis)))
    	return(lis);
    else
    	return(list3(car(lis),caadr(lis),cons(make_sym("lambda"),cons(cdadr(lis),cddr(lis)))));
}


//-------quasi->procedure-----------------
int quasi_to_procedure(int lis){
	if(nullp(lis))
    	return(NIL);
    if(atomp(lis))
    	return(lis);
    if(vectorp(lis))
    	return(lis);
    if(car(lis) == quasiquote)
    	return(transfer(cadr(lis),1));
    else
    	return(cons(quasi_to_procedure(car(lis)),quasi_to_procedure(cdr(lis))));
}

int transfer(int lis, int n){
                           
    if(pairp(lis))
    	if(pairp(car(lis))){
    		if(caar(lis) == unquote)
        		return(list3(make_sym("cons"),uq_transfer(cadar(lis),n-1),transfer(cdr(lis),n)));
    		if(caar(lis) == unquote_splicing)
        		return(list3(make_sym("append"),uqs_transfer(cadar(lis),n-1),transfer(cdr(lis),n)));
            if(caar(lis) == quasiquote)
            	return(list3(make_sym("cons"),
                			list3(make_sym("list"),
                					list2(quote,quasiquote),
                            		transfer(cadar(lis),n+1)),
                            transfer(cdr(lis),n)));
        	else
        		return(list3(make_sym("cons"),transfer(car(lis),n),transfer(cdr(lis),n)));
    	}
    	else
            if(car(lis) == unquote)
            	return(cadr(lis));
            else       
        		return(list3(make_sym("cons"),list2(quote,car(lis)),transfer(cdr(lis),n)));
    else
    	return(list2(quote,lis));     	
}

int uq_transfer1(int lis, int n){
	if(nullp(lis))
    	return(NIL);
    if(atomp(lis))
    	return(lis);
	if(pairp(lis) && (car(lis) == unquote))
    	if(n == 1)
            return(eval(cadr(lis)));
        else
        	return(list2(unquote,uq_transfer1(cadr(lis),n-1)));
    else
    	return(cons(uq_transfer1(car(lis),n),uq_transfer1(cdr(lis),n)));
}

int uq_transfer(int lis, int n){
    
    if(pairp(lis)){
    	if(car(lis) == unquote)
        	return(list3(make_sym("list"),list2(quote,unquote),uq_transfer(cadr(lis),n-1)));
        if(car(lis) == unquote_splicing)
        	return(list3(make_sym("list"),list2(quote,unquote_splicing),uq_transfer(cadr(lis),n-1)));	
    	if(car(lis) == quasiquote)
        	return(transfer(cadr(lis),n+1));
        if(n > 0){
            return(list3(make_sym("list"),
            			list2(quote,unquote),
                        list2(quote,uq_transfer1(lis,n))));
        }
        else
        	return(cons(uq_transfer(car(lis),n),uq_transfer(cdr(lis),n)));
    }
    else
    	if(n == 0)
    		return(lis);
        else
        	return(list2(quote,lis));
}

int uqs_transfer1(int lis, int n){
	if(nullp(lis))
    	return(NIL);
    if(atomp(lis))
    	return(lis);
	if(pairp(lis) && (car(lis) == unquote_splicing))
    	if(n == 1)
            return(cdr(eval(cadr(lis))));
        else
        	return(list2(unquote_splicing,uqs_transfer1(cadr(lis),n-1)));
    else
    	return(cons(uqs_transfer1(car(lis),n),uqs_transfer1(cdr(lis),n)));
}
                
                
int uqs_transfer(int lis, int n){
    
    if(pairp(lis)){
    	if(car(lis) == unquote)
        	return(list3(make_sym("list"),list2(quote,unquote),uq_transfer(cadr(lis),n-1)));
        if(car(lis) == unquote_splicing)
        	return(list3(make_sym("list"),list2(quote,unquote),uqs_transfer(cadr(lis),n-1)));	
    	if(car(lis) == quasiquote)
        	return(transfer(cadr(lis),n+1));
        if(n > 0)
        	return(list3(make_sym("list"),
            			list2(quote,unquote_splicing),
                        list2(quote,uqs_transfer1(lis,n))));
        else
        	return(cons(uqs_transfer(car(lis),n),uqs_transfer(cdr(lis),n)));
    }
    else
    	if(n == 0)
    		return(lis);
        else
        	return(list2(quote,lis));
}

//-----print------------------                           
void print(int x){
	char c;
    int tag,i,j,m,n;
    

    tag = (int)GET_TAG(x);
	switch(tag){
    	case EMP:	fprintf(output_port, "EMP"); break;
    	case BIGBANG:
        			fprintf(output_port, "()"); break;
        case EMPSET:fprintf(output_port, "#<empty-set>"); break;
    	case INTN:	fprintf(output_port, "%d", GET_INT(x)); break;
        case BIG:	printbig(x); break;
        case FLTN:	printflt(GET_FLT(x)); break;
        case RAT:  	fprintf(output_port, "%d", GET_CAR(x));
        			fprintf(output_port, "/");
                    fprintf(output_port, "%d", GET_CDR(x));
                    break;
                    
        case COMP: printflt(GET_REAL_FLT(x));
        			if(GET_IMAG_FLT(x) >= 0)
                    	fprintf(output_port, "+");
                    printflt(GET_IMAG_FLT(x));
                    fprintf(output_port, "i");
                    break;
        			
        case SYM:   if(x == undef)
                    	fprintf(output_port, "#<undef>");
        			else
                    if(inttoken(GET_NAME(x)) ||
                       flttoken(GET_NAME(x)) ||
                       rattoken(GET_NAME(x)) ||
                       comptoken(GET_NAME(x)))
                   		fprintf(output_port, "|%s|",GET_NAME(x));
                    else
        				fprintf(output_port, "%s", GET_NAME(x)); 
               		break;
        			
        case BOL:	fprintf(output_port, "%s", GET_NAME(x)); break;
        case STR:  	fprintf(output_port, "\"");
        			fprintf(output_port, "%s", GET_NAME(x));
                    fprintf(output_port, "\""); break;
                	
        case CHR:  	fprintf(output_port, "%c%c", '#', '\\');
        			c = GET_CHAR(x);
                    if(c == SPACE)
                    	fprintf(output_port, "space");
                    else
                    if(c == RET)
                    	fprintf(output_port, "\r");
                    else
                    if(c == EOL)
                    	fprintf(output_port, "\n");
                    else
                    if(c == TAB)
                    	fprintf(output_port, "\t");
                    else
        				fprintf(output_port, "%c", GET_CHAR(x))
                    ; break;
                    
        case SUBR:	fprintf(output_port, "#<subr %s>", GET_NAME(x)); break;
        case SYNT:	fprintf(output_port, "#<syntax %s>", GET_NAME(x)); break;
        case CLOS:	fprintf(output_port, "#<closure %s>", GET_NAME(x)); break;
        case HCONT:	fprintf(output_port, "#<continuation>"); break;
        case MAC:	fprintf(output_port, "#<macro %s>", GET_NAME(x)); break;
        case HYG:	fprintf(output_port, "#<hygienic %s>", GET_NAME(x)); break;
        case LIS:  	if(eqp(car(x),quote)){
        				fprintf(output_port, "'");
                        print(cadr(x));
                        break;
                    }
        			if(eqp(car(x),quasiquote)){
        				fprintf(output_port, "`");
                        print(cadr(x));
                        break;
                    }
                    if(eqp(car(x),unquote)){
        				fprintf(output_port, ",");
                        print(cadr(x));
                        break;
                    }
                    if(eqp(car(x),unquote_splicing)){
        				fprintf(output_port, ",@");
                        print(cadr(x));
                        break;
                    }
                    else{	
        				printlist(x);
                    	break;
                    }
        case VEC:  	printvec(x);
        			break;
        case MUL:  	n = GET_VEC_ELT(x,0);
        			for(i=1; i<n; i++){
                    	print(GET_VEC_ELT(x,i));
                    	fprintf(output_port, "\n");
        			}
                    print(GET_VEC_ELT(x,i));
                    break;   
        case PRT:	fprintf(output_port, "#<port>"); break;
        case EOFO:	fprintf(output_port, "#<eof>"); break;
        case IDNT:	fprintf(output_port, "#<id %s,", GET_NAME(x));
        			print(GET_AUX(x));
                    fprintf(output_port, ">"); break;
        case SYNCLO:
        			fprintf(output_port, "#<synclo "); print(GET_CAR(x)); 
                    fprintf(output_port, ">"); break;
        case ENV:	fprintf(output_port, "<env>\n"); 
                    m = GET_CDR(x);
                   	n = GET_AUX(x);
                    for(i=0; i<m; i++){
                    	for(j=0; j<n; j++){
                        	printf("[");
                            print(GET_ENV_VEC_ELT(x,j));
                            printf("]");
                        }
                    	printf("\n");
                        x = GET_ENV_ORG(x);
                    }    
                    break;
        case CODE:	fprintf(output_port, "<code>");
        			n = GET_CDR(x);
                    for(i=0; i<n; i++){
                        printf("[%d]", GET_VEC_ELT(x,i));
                    }
        			printf("\n");
                    break;
        case STACK:	fprintf(output_port, "<stack>"); break;
    }
}

//•‚“®¬”“_”‚Å®”‚Ìê‡‚ÉŒ…”‚ğ’²®‚µ‚Ä•\¦                            
void printflt(double x){
	if(x - ceil(x) != 0)
    	fprintf(output_port, "%0.16g", x);
    else
    	fprintf(output_port, "%0.1f", x);
}

void printbig(int x){
	int y;
    
    y = reverse(x);
    fprintf(output_port, "%d",GET_INT(car(y)));
    y = cdr(y);
    while(!nullp(y)){
    	fprintf(output_port, "%09d",abs(GET_INT(car(y))));
        y = cdr(y);
    }
}

void printlist1(int x){
	if(IS_NIL(x))
    	fprintf(output_port, ")");
    else
    if((!(pairp(cdr(x)))) && (! (nullp(cdr(x))))){
    	print(car(x));
        fprintf(output_port, " . ");
        print(cdr(x));
        fprintf(output_port, ")");
    }
    else {
    	print(GET_CAR(x));    
        if(! (IS_NIL(GET_CDR(x))))
        	fprintf(output_port, " ");
       	printlist1(GET_CDR(x));
    }
}

void printlist(int x){
	fprintf(output_port, "(");
    printlist1(x);
}

void printvec(int x){
	int len,i;
    
    fprintf(output_port, "#(");
    len = GET_CDR(x);
    for(i=0; i<len-1; i++){
    	print(GET_VEC_ELT(x,i));
        fprintf(output_port, " ");
    }
    print(GET_VEC_ELT(x,i));
    fprintf(output_port, ")");
}

                            
//-------ƒfƒoƒbƒO—p------------------  
void cellprint(int addr);

//ƒq[ƒvƒ_ƒ“ƒv	
void memorydump(int start, int end){
	int i;
    
    printf("addr      car     cdr     tag    val\n");
    for(i=start; i<= end; i++)
    	cellprint(i);
    
}

  
void cellprint(int addr){
	int flag,tag;
    
	printf("%07d ", addr);
    flag = (int)GET_FLAG(addr);
	switch(flag){
    	case FRE:	printf("F "); break;
        case USE:	printf("U "); break;
    }
    printf("%07d ", GET_CAR(addr));
    printf("%07d ", GET_CDR(addr));
    
    tag = (int)GET_TAG(addr);
	switch(tag){
    	case BIGBANG: 
        			printf("BigBang"); break;
    	case EMP:	printf("Emp    "); break;
        case INTN:	printf("Int    "); print(addr); break;
        case FLTN:	printf("Flt    "); print(addr); break;
        case COMP:	printf("Com    "); print(addr); break;
        case SYM:	printf("Sym    "); print(addr); printf(" = "); print(GET_CAR(addr)); break;
        case STR:	printf("Str    "); print(addr); break;
        case CHR:	printf("Chr    "); print(addr); break;
        case LIS:	printf("Lis    "); break;
        case BOL:	printf("Bol    "); print(addr); break;
        case BIG:	printf("Big    "); printf("%d",GET_INT(addr)); break;
        case RAT:	printf("Rat    "); print(addr); break;
        case SUBR:	printf("Sub    "); break;
        case CLOS:	printf("Clo    "); break;
		case MAC:	printf("Mac    "); break;
        case HYG:	printf("Hyg    "); break;
        case HCONT:	printf("Cnt    "); print(GET_CDR(addr)); break;
        case MUL:	printf("Mul    "); break;
        case VEC:	printf("Vec    "); break;
        case ELT:	printf("Elt    "); break;
        case IDNT:	printf("Idnt   "); break;
        case SYNCLO:printf("SynClo "); break;
        case ENV:	printf("Env    "); break;
        case CODE:	printf("Code   "); break;
        case STACK:	printf("Stack  "); break;
    }
    printf("\n");
}   


//---------ƒKƒx[ƒWƒRƒŒƒNƒVƒ‡ƒ“-----------

void gbc(void){
	register int addr;
    clock_t gctime1,gctime2;
	
    if(gbcflag == 1){
    	printf("enter GBC free= %d\n", cell_free); fflush(stdout);
    }
	gctime1 = clock();
    cont_count = 0;
	
    gbcmark();
    gbcsweep();
    cell_free = 0;
    for(addr=0; addr <= CELLSIZE; addr++)
    	if(IS_EMPTY(addr))
        	cell_free++;
    
    gctime2 = clock();
    gctime = gctime + (gctime2 - gctime1);
    
    if(gbcflag == 1){
		printf("exit  GBC free= %d\n", cell_free); fflush(stdout);
	}
}

           
void markcell(int addr){
	int n,i,j,x,y,tag;
    
    //¬®”‚Ìê‡‚Íƒ}[ƒN‚·‚é•K—v‚È‚µB
    if(addr < 0 || addr > CELLSIZE){    
    	return;
    }	
	if(IS_USE(addr))
    	return;
	SET_FLAG_USE(addr);
    tag = (int)GET_TAG(addr);
    switch(tag){
        case FLTN:
        case RAT:
        case STR:
        case CHR:	return;
        case COMP:	markcell(car(addr));
        			markcell(cdr(addr));
                    return;
        case SYM:	markcell(GET_CAR(addr));
        case SUBR:
        case PRT:	return;
        case BIG:	markcell(car(addr));
        			markcell(cdr(addr));
                    return;
        case LIS:   markcell(car(addr));
					markcell(cdr(addr));
        			return;
    	case CLOS:	markcell(GET_CAR(addr));
    				markcell(GET_CDR(addr));
        			return;
		case HCONT:	markcell(GET_CAR(addr));
        			markcell(GET_CDR(addr));
                    markcell(car(GET_AUX(addr)));
        			return;
    	case MAC:	markcell(GET_CAR(addr));
    				return;	
    	case VEC:	n = vector_length(addr);
        			for(i=0; i<n; i++){
          				x = GET_VEC_ELT(addr,i);
            			markcell(x);
                    }
                    return;
        case MUL:	markcell(car(addr));
        			markcell(cdr(addr));
                    return;
        case ENV:	j = GET_AUX(addr);
                    y = j + 1;
                    
                    for(x=0; x<j; x++)
                    	markcell(GET_ENV_VEC_ELT(addr,x));
          			
          			markcell(GET_ENV_ORG(addr));
                    n = dyna_env_cpy(GET_CAR(addr),y);
                    SET_CAR(addr,n);
                    return;
        case CODE:	i = GET_CDR(addr);		
                    x = 0;
                    while(x<i){
                    	y = GET_VEC_ELT(addr,x);
                        switch(y){
                        	case 0:		x = x + 1;
          								break;
                        	case 1:		x = x + 1;
                            			break;
                        	case 2:		markcell(GET_VEC_ELT(addr,x+1));
                            			x = x + 2;
                                    	break;
                        	case 3:		x = x + 3;
                            			break;
                            case 4:		x = x + 2;
                            			break;
                            case 5:		x = x + 3;
                            			break;
                            case 6:		x = x + 2;
                            			break;
                            case 7:		x = x + 1;
                            			break;
                            case 8:		x = x + 2;
                            			break;
                            case 9:		x = x + 2;
                            			break;
                            case 10:	x = x + 2;
                            			break;
                            case 11:	x = x + 1;
                            			break;
                            case 12:	x = x + 2;
                            			break;
                            case 13:	x = x + 2;
                            			break;
                            case 14:	x = x + 2;
										break ;
                        	case 15:	markcell(GET_VEC_ELT(addr,x+2));
                                    	x = x + 3;
                                        break;
          					case 16:	x = x + 2;
                            			break;
                            case 17:	x = x + 3;
                            			break;
                            case 18:	x = x + 2;
                            			break;
                            case 19:	x = x + 2;
                            			break;
                        	case 20:	x = x + 3;
                            			break;
                            case 21:
                            case 22:
                            case 23:
                            case 24:
                            case 25:
                            case 26:
                            case 27:
                            case 28:
                            case 29:
                            case 30:	x = x + 1;
                            			break;
                            case 31:	x = x + 2;
                            			break;
                            case 32:	x = x + 1;
                            			break;
                            case 33:	x = x + 1;
                            case 34:
                            case 35:
                            case 36:
                            case 37:	x = x + 1;
                            			break;
                            case 38:	x = x + 3;
                            			break;
                            case 39:
                            case 40:	x = x + 2;
                            			break;
                        }
                    }
                    return;
        case STACK:	i = GET_CDR(addr);
        			for(x=0; x<i; x++)
                    	markcell(GET_VEC_ELT(addr,x));
                    return;
        
        case MEM:	i = GET_VEC_ELT(addr,1);
        			for(x=0; x<i; x = x+2)
                    	markcell(GET_VEC_ELT(addr,x+4));
                    return;
        
    }
}



void gbcmark(void){
	int register addr,i;
    int x,y;
    
    dyna_env_p2 = 0;
    
    SET_FLAG_USE(0);  //NIL‚ğuseó‘Ô‚É‚·‚éB
    SET_FLAG_USE(1);  //#t
    SET_FLAG_USE(2);  //#f
    SET_FLAG_USE(15); //0
    SET_FLAG_USE(16); //1
    SET_FLAG_USE(17); //2
    SET_FLAG_USE(18); //-1
    SET_FLAG_USE(19); //3
    SET_FLAG_USE(20); //#\L
    SET_FLAG_USE(21); //"L"
    
    //Œ»ó‚ÌŠÂ‹«‚ğƒ}[ƒN
    markcell(env);
    
    //ƒgƒŒ[ƒXƒŠƒXƒg‚ğƒ}[ƒN
    markcell(trace_list);
    
    //ƒXƒ^ƒbƒN‚©‚ç‚Â‚È‚ª‚Á‚Ä‚¢‚écell‚ğƒ}[ƒNB
    for(i=sp-1; i>=0; i--){
    	addr = stack[i];
        markcell(addr);
    }
    //–½—ß—ñ‚©‚ç‚Â‚È‚ª‚Á‚Ä‚¢‚écell‚ğƒ}[ƒNB
    for(i=tail-1; i>=0; i--){
    	addr = stack[i];
        markcell(addr);
    }
    
    //‘åˆæ’è‹`ƒVƒ“ƒ{ƒ‹‚ğƒ}[ƒNB
    for(x=0; x<HASHTBSIZE; x++)
    	for(y=0; y<module_table_end; y++){
    		addr = cell_hash_table[x][y];	           
    		while(!(nullp(addr))){
        		//printf("%d ", addr);
    			SET_FLAG_USE(addr);
    			markcell(car(addr));
        		addr = cdr(addr);
    	}
    }
    
    //ƒ‰ƒCƒuƒ‰ƒŠ–¼‚ÌƒŠƒXƒg‚¨‚æ‚Ñexport‚³‚ê‚½ƒŠƒXƒg‚ğƒ}[ƒNB
    for(x=0; x<module_table_end; x++){
    	markcell(module_table[x][0]);	
    	markcell(module_table[x][1]);
    }
    //emem2 ‚©‚çemem1‚ÉƒRƒs[
    for(x=0; x<dyna_env_p2; x++){
    	emem1[x] = emem2[x];
        SET_FLAG_USE(emem1[x]);
    }
    dyna_env_p1 = dyna_env_p2;
}

void gbcsweep(void){
	int addr;
    
    //ƒZƒ‹—Ìˆæ‚ÌGC
    addr = 0;
    while(addr < CELLSIZE){
    	
        if(IS_USE(addr)){
        	SET_FLAG_FREE(addr);
        }
        else{
        	clrcell(addr);
            SET_CDR(addr,cell_heap_p);
            cell_heap_p = addr;
        }
        addr++;
    }          
}

void clrcell(int addr){
	int tag;
              
	if((tag=GET_TAG(addr)) == SYM || tag == STR || tag == CHR || tag == CLOS){
    	free(memory[addr].name);
    	memory[addr].name = NULL;
    }
	
    
    if(tag == CODE || tag == STACK || tag == VEC || tag == MEM){
        free(memory[addr].val.car.dyna_vec);
    }
    
    
    SET_TAG(addr,EMP);
    SET_CAR(addr,0);
    SET_AUX(addr,0);
}

//©—RƒZƒ‹‚ªˆê’è”‚ğ‰º‰ñ‚Á‚½ê‡‚É‚Ígbc‚ğ‹N“®‚·‚éB
void check_ctrl(void){
	//ctrl+c ‚ª‚©‚©‚Á‚Ä‚¢‚é‚Æ‚«‚É‚ÍƒgƒbƒvƒŒƒxƒ‹‚É–ß‚éB
	if(exitflag == 1){
    	exitflag = 0;
        longjmp(toplevel,1);
    }
    //ctrl+d ‚ª‚©‚©‚Á‚Ä‚¢‚é‚Æ‚«‚É‚Íˆ—Œn‚ğI—¹‚·‚éB
    if(exitflag == 2)
    	longjmp(toplevel,2);
	if(cell_free < FREESIZE)
    	gbc();
}


int ealloc(int n){
	int res;
    
    res = dyna_env_p1;
    dyna_env_p1 = dyna_env_p1 + n;
    if(dyna_env_p1 > ENVSIZE)
    	exception("ealloc", MALLOC_OVERF, NIL);
        
    return(res);
}

int dyna_env_cpy(int p, int n){
	int i,res;
    
    res = dyna_env_p2;
    for(i=0; i<n; i++){
    	emem2[dyna_env_p2] = emem1[p];
    	dyna_env_p2++;
        p++;
        if(dyna_env_p2 > ENVSIZE2)
        	exception("dyna_env_copy", MALLOC_OVERF, NIL);
    }
    return(res); 
}L     0®     .text           °Î  T  ¼     ¡    0`.data           @  Ğ              @ `À.bss            @                   € 0À/4              $   DÓ            0`.rdata          @  hÓ  $       @ `@/19             @  ¨ç  °¦     j     0`.drectve        h  èì              @ 0À/33             l  Pñ  Ôª     V   @ 0@‹D$…ÀuÇ$      ¸   Â fHt1ÀÂ Ç$      ¸   Â f¡    H£    ‹…    ÃVS‹\$‹5    …Û~‰Ø‰ò)ÚÁâv ‹Œ‚üÿÿÿ‰Œ‚   Huï‰ğ)Ø‹T$‰…    ‹T$‰…   ƒÆ‰5    [^ÃUWVSƒì,‹\$@‰$è    ‰$è    ‰Å1ö‰ÇÁç‰$è    …Àu?‰$è    ‰$è    ƒø(wÿ$…    ‹—    ‰²v F‰$è    ‰Ã‰$è    …ÀtÁ‰èƒÄ,[^_]Ãv ‹—    ‰²F‰$è    ‰Ãµ    —    ‰$‰T$è    ‰$è    ‹T$‰ëŸv ‹‡    Ç°%   ë‹‡    Ç°!   ézÿÿÿf‹‡    Ç°    éfÿÿÿf‹‡    Ç°   F‰$v è    ‰Ãµ    —    ‰$‰T$è    ‹T$‰é%ÿÿÿ‹—    ‰²F‰$ëÅ‹‡    Ç°   ‰$è    µ   Ÿ    ‰$‰D$è    ‰ƒÆ‹T$‰$éÿÿÿ‹—    ‰²F‰$érÿÿÿf‹‡    Ç°   F‰D$‰$è    ‰Ã‰$è    ‰$è    ‹T$‹    ‘‰$‰T$…À„Ö  è    ‹T$‰ƒÆ‰$é‘şÿÿ‹‡    Ç°   F‰$é{şÿÿf‹‡    Ç°   F‰$écşÿÿf‹‡    Ç°   éşÿÿf‹‡    Ç°   ‰$è    µ   Ÿ    ‰$‰D$è    ‰$è    ‰ƒÆ‹T$‰$è    ‰Ãµ    —    ‰$‰T$è    ‰$èZıÿÿ‹T$‰é§ıÿÿv ‹‡    Ç°&   ‰$è    µ   Ÿ    ‰$‰D$è    ‰ƒÆ‹T$‰$éşÿÿ‹‡    Ç°   éRıÿÿf‹‡    Ç°   F‰$éêıÿÿf‹‡    Ç°   ‰$è    µ   Ÿ    ‰$‰D$è    ‰$è    ‰ƒÆ‹T$‰$é"ıÿÿ‹‡    Ç°   F‰$éŠıÿÿf‹‡    Ç°   ë‹‡    Ç°   é›ıÿÿf‹‡    Ç°   é¢üÿÿfè    ‰$è    ‹T$‰éşÿÿVSƒì‹    K1ö…ÛëFKt‹    ‰$è    ƒøuè‰ğƒÄ[^Ã‹L$‹   …Ò~*1À9    uëf9Å    t@9Ğuò¸ÿÿÿÿÃ‹Å   Ã¸ÿÿÿÿÃfVSƒì‹t$ …ö~/1Û1Àv ‰D$‰Ø÷Ğ    ‹…    ‰$è    C9óuŞƒÄ[^Ã1Àëö‹L$‹T$¡   ƒø	Â   ¡   £    ¡   £   ¡   £   ¡   £   ¡   £   ¡   £   ¡    £   ¡$   £   ¡(   £    ¡,   £$   ¡0   £(   ¡4   £,   ¡8   £0   ¡<   £4   ¡@   £8   ¡D   £<   ¡H   £@   ¡L   £D   ‰H   ‰L   Ã‰Å    ‰Å   @£   Ãv ŠD$ƒè!<]w¶Àÿ$…¤   v 1ÀÃ¸   ÃfUWVSì  ‹¬$(  ‹¼$,  Šœ$0  ŠˆD$ŠGˆD$1À¹   ¾   €|$ t!:\$t:ŠT$ˆTFAŠ7ˆT$€|$ uâft$¹  ‰ïó¤ˆE ‰èÄ  [^_]Â ÆD ŠD7F1É„Àtˆ„  FAŠ7„ÀuğÆ„   ˆØë´S‹T$Š\$1À€: t@€< uùŠˆLHƒøÿuóˆMZP      ÿÿ  ¸       @ ï»¿norm : main.o cell.o list.o compute.o function.o r7rs.o
	gcc -O4 -Wall main.o cell.o list.o compute.o function.o r7rs.o  -o norm

main.o : main.c norm.h
	gcc -O4 -Wall -c main.c

cell.o : cell.c norm.h
	gcc -O4 -Wall -c cell.c

list.o : list.c norm.h
	gcc -O4 -Wall -c list.c

compute.o : compute.c norm.h
	gcc -O4 -Wall -c compute.c

function.o : function.c norm.h
	gcc -O4 -Wall -c function.c

r7rs.o : r7rs.c norm.h
	gcc -O4 -Wall -c r7rs.c


;;”ŠwŠÖ”‚ÌƒeƒXƒg
(import (normal test)
        (scheme inexact)
        (scheme complex))

(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

(define (fib-tail n)
  (define (iter x n1 n2)
    (if (= x n)
        (+ n1 n2)
        (iter (+ x 1) (+ n1 n2) n1)))
  (iter 2 1 0))

(define (sigma n)
  (if (= n 1)
      1
      (+ n (sigma (- n 1)))))

(define (tarai x y z)
  (if (<= x y)
      y
      (tarai (tarai (- x 1) y z)
             (tarai (- y 1) z x)
             (tarai (- z 1) x y))))



(define (fact n) 
  (if (= n 0)
      1
      (* n (fact (- n 1)))))

(define (fact-tail n)
  (fact-rec n n))

(define (fact-rec n p)
  (if (= n 1)
      p
      (let ((m (- n 1)))
        (fact-rec m (* p m)))))

(define (collatz n)
  (display n)(display '->)
  (cond ((= n 1) #t)
        ((even? n) (collatz (quotient n 2)))
        ((odd? n) (collatz (+ (* n 3) 1)))
        (else #f)))

(define ack
  (lambda (m n)
    (cond ((= m 0) (+ n 1))
          ((= n 0) (ack (- m 1) 1))
          (else (ack (- m 1) (ack m (- n 1)))))))


(test* "(sin 1+2i)" 3.165778513216168+1.959601041421606i (sin 1+2i))
(test* "(sin 3+2.5i)" 0.8653887407955783-5.989657039127781i (sin 3+2.5i))
(test* "(cos 1+2i)" 2.0327230070196656-3.0518977991518002i (cos 1+2i))
(test* "(acos 1+2i)" 1.1437177404024206-1.5285709194809978i (acos 1+2i))
(test* "(tan 1+2i)" 0.033812826079896691+1.0147936161466335i (tan 1+2i))
(test* "(atan 1+2i)" 1.3389725222944935+0.40235947810852513i (atan 1+2i))

(test* "(real-part 3+4i)" 3.0 (real-part 3+4i))
(test* "(real-part -2.3+0.7i)" -2.3 (real-part -2.3+0.7i))
(test* "(real-part 17.2)" 17.2 (real-part 17.2))
(test* "(real-part -17/100)" -17/100 (real-part -17/100))
(test* "(make-rectangular -2 7)" -2+7i (make-rectangular -2 7))
(test* "(make-polar 1 (asin -1))" 0+1.0i (make-polar 1 (asin -1)))

(test* "(exp 0)" 1 (exp 0))
(test* "(exp 1)" 2.718281828459045 (exp 1))
(test* "(exp -0.5)" 0.6065306597126334 (exp -0.5))
(test* "(exp -1/2)" 0.6065306597126334 (exp -1/2))

(test* "(log (exp 1))" 1.0 (log (exp 1)))
(test* "(/ (log 100) (log 10))" 2.0 (/ (log 100) (log 10)))

(test* "(min 4 -7 2 0 -6)" -7 (min 4 -7 2 0 -6))
(test* "(min 1/2 3/4 4/5 5/6 6/7)" 1/2 (min 1/2 3/4 4/5 5/6 6/7))
(test* "(min 1.5 1.3 -0.3 0.4 2.0 1.8)" -0.3 (min 1.5 1.3 -0.3 0.4 2.0 1.8))
(test* "(min -5 2.0)" -5 (min -5 2.0))
(test* "(min -5 -2.0)" -5 (min -5 -2.0))

(test* "(gcd)" 0 (gcd))
(test* "(gcd 34)" 34 (gcd 34))
(test* "(gcd 33.0 15.0)" 3.0 (gcd 33.0 15.0))

(test* "(modulo 9876543210 8765432)" 6666778 (modulo 9876543210 8765432))
(test* "(modulo 9876543210 -8765432)" -2098654 (modulo 9876543210 -8765432))
(test* "(modulo -9876543210 8765432)" 2098654 (modulo -9876543210 8765432))
(test* "(modulo -9876543210 -8765432)" -6666778 (modulo -9876543210 -8765432))

(test* "(floor 3)" 3 (floor 3))
(test* "(floor 3.14)" 3.0 (floor 3.14))
(test* "(floor -2.72)" -3.0 (floor -2.72))
(test* "(ceiling 3)" 3 (ceiling 3))
(test* "(ceiling 3.14)" 4.0 (ceiling 3.14))
(test* "(ceiling -2.72)" -2.0  (ceiling -2.72))


;;; 
(define (deterministic-prime? n)
  (define (iter x y n)
    (cond ((> x y) #t)
          ((divisible? n x) #f)
          (else (iter (+ x 2) y n))))
  (cond ((< n 2) #f)
        ((= n 2) #t)
        ((even? n) #f)
        (else (iter 3 (ceiling (sqrt n)) n))))

(define (divisible? m n)
  (= (modulo m n) 0))


(define (prime-factors n)
  (define (iter ls p n mult)
    (cond ((null? ls) (cons (list p n) mult))
          ((eq? (car ls) p) (iter (cdr ls) p (+ n 1) mult))
          (else (iter (cdr ls) (car ls) 1 (cons (list p n) mult)))))
  (let ((ls (prime-factors2 n)))
    (iter (cdr ls) (car ls) 1 '())))




(define (prime-factors2 n)
  (define (iter p x ls z)
    (cond ((= x 1) ls)
          ((> p z) (cons x ls))
          ((divisible? x p) 
           (iter1 p (quotient x p) (cons p ls)))
          ((= p 2) (iter 3 x ls z))
          (else (iter (+ p 2) x ls z))))
  (define (iter1 p x ls)
    (if (divisible? x p)
        (iter1 p (quotient x p) (cons p ls))
        (iter p x ls (sqrt x))))
  (iter 2 n '() (sqrt n)))


;;ƒ‚ƒWƒ…[ƒ‹‚ÌƒeƒXƒg
(define-library (scheme base)
  (export = + - * / <))

(define-library (normal user)
  (export let letrec let* cond and or do))

(define-library (test foo)
  (export fact woo my-or)
  (import (scheme base))
  (import (normal user))
  (begin
    (define (fact n)
      (if (= n 0)
          1
          (* n (fact (- n 1)))))
    (define (woo x)
      (cond ((= x 1) #t)
            ((= x 2) #f)
            (else 1)))
    (define (my-or x)
      (or x))))

(import (test foo))

(define-library (test macro)
  (export ttt nil! foo)
  (import (scheme base))
  (begin
    (define-macro ttt
      (lambda (expr)
        `(+ ,expr)))
    (define-syntax nil!
      (syntax-rules ()
        ((_ x)
         (set! x '()))))
    (define (foo x) (+ x x))))















;;‘½’l‚ÌƒeƒXƒg;; M.Hiroi ‚³‚ñ‚ÌHP‚É‚ ‚é—á‘è‚ğg‚í‚¹‚Ä‚¢‚½‚¾‚«‚Ü‚µ‚½B
(import (normal test))

(define (partition pred ls)
  (if (null? ls)    
      (values '() '())  
      (call-with-values    
        (lambda ()      
          (partition pred (cdr ls)))   
        (lambda (a b)    
          (if (pred (car ls))   
              (values (cons (car ls) a) b)   
              (values a (cons (car ls) b)))))))

;;Kent–{
(define split
  (lambda (ls)
    (if (or (null? ls) (null? (cdr ls)))
        (values ls '())
        (call-with-values
          (lambda () (split (cddr ls)))
          (lambda (odds evens)
            (values (cons (car ls) odds)
                    (cons (cadr ls) evens)))))))

(test* "(call-with-values * -)" -1 (call-with-values * -))
(test* "(call-with-values (lambda () (values 4 5)) (lamba (a b) b))"
       5
       (call-with-values (lambda () (values 4 5)) (lambda (a b) b)))
(15 1 (12 1 3 0 0 17 transfer 1 2 () 2 #t 2 #t 2 #f 2 #f 2 #t 2 #f 4 comp 13 8 2 halt 17 list 1 17 list 1 17 append 2 11) 18 compile 1)
(15 8 (12 8 3 0 0 17 null? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 boolean? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 symbol? 1 10 22 3 0 0 3 0 1 3 0 2 3 0 3 3 0 5 4 comp-var 13 5 11 3 0 0 17 identifier-free? 1 10 22 3 0 0 3 0 1 3 0 2 3 0 3 3 0 5 4 comp-var 13 5 11 3 0 0 17 atom? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 vector? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 34 17 macro-name? 1 10 34 3 0 0 17 macroexpand-1 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 17 hygienic-name? 1 10 34 3 0 0 17 macroexpand-1 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 2 quote 17 eqv? 2 10 34 3 0 0 2 1 2 1 4 args-count-check 13 3 7 3 0 0 17 cadr 1 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 34 2 begin 17 eqv? 2 10 32 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-begin 13 8 11 3 0 0 34 2 set! 17 eqv? 2 10 111 3 0 0 2 2 2 2 4 args-count-check 13 3 7 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 3 0 0 17 cadr 1 3 0 1 4 gen-set 13 2 3 0 2 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 0 3 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 13 4 11 3 0 0 34 2 if 17 eqv? 2 10 82 3 0 0 17 length 1 2 3 21 10 16 3 0 0 2 ((undefined)) 17 append 2 5 0 0 7 8 2 3 0 0 2 3 2 3 4 args-count-check 13 3 7 3 0 0 17 cadr 1 3 0 0 17 caddr 1 3 0 0 17 cadddr 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 2 #t 4 comp-if 13 10 11 3 0 0 34 2 lambda 17 eqv? 2 10 41 3 0 2 10 33 3 0 0 17 cadr 1 3 0 0 17 cddr 1 3 0 1 3 0 6 3 0 7 4 comp-lambda 13 5 15 1 (12 1 2 fn 3 1 0 17 cadr 1 4 args-count 13 1 3 0 0 4 gen 13 3 3 1 3 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2) 13 1 11 2 #f 11 3 0 0 34 2 define 17 eqv? 2 10 77 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 2 1 15 1 (12 1 3 0 0 17 primitive-name? 1 17 not 1 11) 2 "can't overwrite primitive name " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 2 def 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 define-macro 17 eqv? 2 10 61 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 2 #f 3 0 7 4 comp 13 8 2 defm 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 define-syntax 17 eqv? 2 10 64 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 2 #f 3 0 7 4 comp 13 8 2 defh 3 0 0 17 cadr 1 3 0 1 4 gen 13 3 4 seq 13 2 11 3 0 0 34 2 define-library 17 eqv? 2 10 63 3 0 0 2 2 2 infinity 4 args-count-check 13 3 7 3 0 0 2 1 4 list? 2 "require list for library name" 4 args-type-check 13 4 7 2 deflib 3 0 0 17 cadr 1 3 0 0 17 cddr 1 4 gen 13 3 2 const 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 export 17 eqv? 2 10 29 3 0 0 2 1 2 infinity 4 args-count-check 13 3 7 2 explib 3 0 0 35 4 gen 13 2 4 seq 13 1 11 3 0 0 34 2 import 17 eqv? 2 10 29 3 0 0 2 1 2 infinity 4 args-count-check 13 3 7 2 implib 3 0 0 35 4 gen 13 2 4 seq 13 1 11 3 0 0 34 2 math 17 eqv? 2 10 36 3 0 0 35 4 infix->prefix 13 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 2 syntax-rules 17 eqv? 2 10 77 2 lambda 2 expr 2 comp-env 2 vm-env 2 () 36 36 36 2 expand 2 quote 3 0 0 17 cddr 1 2 () 36 36 2 expr 3 0 0 17 cadr 1 2 comp-env 2 () 36 36 36 36 36 2 () 36 36 36 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-funcall 13 9 11) 18 comp 1)
(15 4 (12 4 3 0 1 10 42 2 const 3 0 0 4 gen 13 2 3 0 2 17 not 1 10 7 3 0 3 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2 2 () 11) 18 comp-const 1)
(15 5 (12 5 3 0 2 10 43 3 0 0 3 0 1 4 gen-var 13 2 3 0 3 17 not 1 10 7 3 0 4 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2 2 () 11) 18 comp-var 1)
(15 8 (12 8 3 0 0 17 null? 1 10 17 2 () 3 0 2 3 0 3 3 0 5 4 comp-const 14 4 3 0 0 4 length=1? 13 1 10 33 3 0 0 34 17 transfer 1 3 0 1 3 0 2 2 #f 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 14 8 3 0 0 34 17 transfer 1 3 0 1 2 #f 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-begin 13 8 4 seq 14 2) 18 comp-begin 1)
(15 6 (12 6 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 34 3 0 1 2 #t 2 #t 3 0 2 3 0 3 3 0 4 3 0 5 4 comp 13 8 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 4 comp-list 13 6 4 seq 14 2) 18 comp-list 1)
(15 10 (12 10 3 0 0 17 not 1 10 31 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 11 3 0 0 17 atom? 1 10 28 3 0 0 17 symbol? 1 17 not 1 10 13 3 0 0 17 not 1 17 not 1 8 4 2 #f 8 4 2 #f 10 31 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 11 3 0 0 17 list? 1 10 27 3 0 0 35 4 length=1? 13 1 10 13 3 0 0 34 2 not 17 eq? 2 8 4 2 #f 8 4 2 #f 10 40 3 0 0 17 cadr 1 3 0 2 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp-if 13 10 11 3 0 0 3 0 3 2 #t 2 #t 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 15 3 (12 3 3 0 1 3 0 2 17 equal? 2 10 36 3 1 0 3 1 3 2 #f 2 #t 3 1 6 3 1 7 3 1 8 3 1 9 4 comp 13 8 3 0 2 4 seq 13 2 11 3 0 1 17 not 1 10 12 4 gen-label 13 0 15 1 (12 1 3 1 0 2 tjump 3 0 0 4 gen 13 2 3 1 2 3 0 0 17 list 1 3 2 5 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5) 13 1 11 4 gen-label 13 0 3 1 5 10 8 4 gen-label 13 0 8 4 2 #f 15 2 (12 2 3 1 0 2 fjump 3 0 0 4 gen 13 2 3 1 1 3 2 5 10 13 2 jump 3 0 1 4 gen 13 2 8 4 2 () 3 0 0 17 list 1 3 1 2 3 2 5 10 10 3 0 1 17 list 1 8 4 2 () 4 seq 14 7) 13 2 11) 13 3 11) 18 comp-if 1)
(15 9 (12 9 3 0 0 17 symbol? 1 17 not 1 10 13 3 0 0 17 list? 1 17 not 1 8 4 2 #f 10 13 2 "illegal function call " 3 0 0 17 error 2 7 8 2 3 0 0 3 0 2 4 primitive? 13 2 15 1 (12 1 3 0 0 10 973 3 1 0 3 1 1 36 3 0 0 4 prim-min 13 1 3 0 0 4 prim-max 13 1 4 args-count-check 13 3 7 3 1 3 17 not 1 10 14 3 0 0 4 prim-side-effect? 13 1 17 not 1 8 4 2 #f 10 29 3 1 1 3 1 2 2 #f 3 1 4 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-begin 14 8 3 1 0 2 (= < <= > >=) 17 memv 2 10 13 3 1 1 17 length 1 2 2 21 8 4 2 #f 10 88 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 4 binomial-op 17 assv 2 17 cadr 1 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 zero? 17 eqv? 2 10 13 3 1 1 17 length 1 2 1 21 8 4 2 #f 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 zerop 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 - 17 eqv? 2 10 56 3 1 1 17 length 1 2 2 21 10 41 3 1 1 17 cadr 1 2 1 17 eq? 2 10 15 3 1 1 17 cadr 1 2 1 17 eq? 2 8 13 3 1 1 17 cadr 1 2 2 17 eq? 2 8 4 2 #f 8 4 2 #f 10 101 3 1 1 17 butlast 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 1 17 cadr 1 2 1 21 10 10 2 sub1 4 gen 13 1 8 8 2 sub2 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 + 17 eqv? 2 10 56 3 1 1 17 length 1 2 2 21 10 41 3 1 1 17 cadr 1 2 1 17 eq? 2 10 15 3 1 1 17 cadr 1 2 1 17 eq? 2 8 13 3 1 1 17 cadr 1 2 2 17 eq? 2 8 4 2 #f 8 4 2 #f 10 101 3 1 1 17 butlast 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 1 17 cadr 1 2 1 21 10 10 2 add1 4 gen 13 1 8 8 2 add2 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 car 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 car 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 cdr 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 cdr 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 cons 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 cons 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 prim 3 1 0 3 1 1 17 length 1 4 gen 13 3 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 17 list? 1 10 28 3 1 0 34 2 lambda 17 eqv? 2 10 13 3 1 0 17 cadr 1 17 null? 1 8 4 2 #f 8 4 2 #f 10 54 3 1 1 17 null? 1 17 not 1 10 13 2 "too many arguments: " 3 1 1 17 error 2 7 8 2 3 1 0 17 cddr 1 3 1 2 3 1 3 3 1 4 3 1 5 2 #f 3 1 7 3 1 8 4 comp-begin 14 8 3 1 4 17 not 1 10 28 3 1 5 17 not 1 10 16 3 1 7 10 7 3 1 8 8 4 2 #f 8 4 2 #f 8 4 2 #f 10 66 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 callj 3 1 1 17 length 1 4 gen 13 2 4 seq 14 3 3 1 0 2 call/cc 17 eqv? 2 10 101 3 1 1 3 1 2 3 1 5 3 1 6 2 #f 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 call 3 1 1 17 length 1 4 gen 13 2 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 call 3 1 1 17 length 1 4 gen 13 2 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5) 13 1 11) 18 comp-funcall 1)
(2 ((= neqp) (< smlp) (<= esmlp) (> grtp) (>= egrtp)) 18 binomial-op 1)
(15 1 (12 1 3 0 0 17 cadddr 1 11) 18 prim-always? 1)
(15 1 (12 1 3 0 0 17 cdddr 1 17 cadr 1 11) 18 prim-side-effect? 1)
(15 1 (12 1 3 0 0 17 cadr 1 11) 18 prim-min 1)
(15 1 (12 1 3 0 0 17 caddr 1 11) 18 prim-max 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 17 not 1 10 11 3 0 0 4 *primitive* 17 assoc 2 11 2 #f 11) 18 primitive? 1)
(15 5 (12 5 3 0 3 10 55 2 args 3 0 0 4 args-count 13 1 4 gen 13 2 3 0 1 3 0 0 3 0 2 36 2 #t 2 #t 3 0 1 17 macroexpand 1 4 inner-lambda? 13 1 2 #t 3 0 3 3 0 4 4 comp-begin 13 8 4 seq 14 2 2 args 3 0 0 4 args-count 13 1 4 gen 13 2 3 0 1 3 0 0 3 0 2 36 2 #t 2 #t 2 #f 2 #t 3 0 3 3 0 4 4 comp-begin 13 8 4 seq 14 2) 18 comp-lambda 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 5 2 -1 11 3 0 0 17 list? 1 10 9 3 0 0 17 length 1 11 3 0 0 17 pair-length 1 17 - 1 11) 18 args-count 1)
(15 1 (12 1 3 0 0 17 list? 1 10 12 3 0 0 17 length 1 2 1 21 11 2 #f 11) 18 length=1? 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 () 11 3 0 1 34 3 0 0 13 1 3 0 0 3 0 1 35 4 mappend 13 2 17 append 2 11) 18 mappend 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 #t 11 3 0 0 17 symbol? 1 10 5 2 #t 11 3 0 0 17 atom? 1 10 5 2 #f 11 3 0 0 34 17 symbol? 1 17 not 1 10 5 2 #f 11 3 0 0 35 4 lambda-args? 14 1) 18 lambda-args? 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 9 3 0 0 17 symbol? 1 11 3 0 0 17 list? 1 11) 18 symbol-or-list? 1)
(15 3 (12 3 3 0 0 35 17 length 1 15 1 (12 1 3 0 0 3 1 1 25 10 12 3 1 2 2 infinity 17 eq? 2 8 4 2 #f 10 5 2 #t 11 3 0 0 3 1 1 25 10 11 3 0 0 3 1 2 23 8 4 2 #f 10 5 2 #t 11 2 "incorrect argument count " 3 1 0 17 error 2 11) 13 1 11) 18 args-count-check 1)
(15 4 (12 4 3 0 0 3 0 1 17 list-ref 2 3 0 2 13 1 10 5 2 #t 11 3 0 3 3 0 0 17 error 2 11) 18 args-type-check 1)
(15 -2 (12 -2 3 0 0 3 0 1 36 17 list 1 11) 18 gen 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 15 1 (12 1 3 0 0 10 18 2 lvar 3 0 0 34 3 0 0 17 cadr 1 4 gen 14 3 3 1 0 17 identifier-free? 1 10 14 2 gvar 3 1 0 17 identifier->symbol 1 4 gen 14 2 2 gvar 3 1 0 4 gen 14 2) 13 1 11) 18 gen-var 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 15 1 (12 1 3 0 0 10 18 2 lset 3 0 0 34 3 0 0 17 cadr 1 4 gen 14 3 2 gset 3 1 0 4 gen 14 2) 13 1 11) 18 gen-set 1)
(15 -1 (12 -1 4 append 3 0 0 17 apply 2 11) 18 seq 1)
(15 0 (12 0 2 "L" 17 gensym 1 11) 18 gen-label 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 19 3 0 0 17 symbol->string 1 2 2 17 string-ref 2 2 #\L 17 char=? 2 11 2 #f 11) 18 label? 1)
(15 2 (12 2 3 0 0 3 0 1 2 0 4 in-env-iter 13 3 11) 18 in-env? 1)
(15 3 (12 3 3 0 1 17 null? 1 10 5 2 #f 11 3 0 0 3 0 1 34 4 in-args? 13 2 10 20 3 0 2 3 0 0 3 0 1 34 4 nth-args 13 2 17 list 2 11 3 0 0 3 0 1 35 3 0 2 27 4 in-env-iter 14 3) 18 in-env-iter 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 #f 11 3 0 1 17 symbol? 1 10 13 3 0 0 3 0 1 17 eq? 2 8 4 2 #f 10 5 2 #t 11 3 0 1 17 symbol? 1 10 5 2 #f 11 3 0 0 3 0 1 34 17 eq? 2 10 5 2 #t 11 3 0 0 3 0 1 35 4 in-args? 14 2) 18 in-args? 1)
(15 2 (12 2 3 0 1 17 symbol? 1 10 13 3 0 0 3 0 1 17 eq? 2 8 4 2 #f 10 5 2 0 11 3 0 0 3 0 1 34 17 eq? 2 10 5 2 0 11 2 1 3 0 0 3 0 1 35 4 nth-args 13 2 17 + 2 11) 18 nth-args 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 #f 11 3 0 0 17 atom? 1 10 5 2 #f 11 3 0 0 17 vector? 1 10 5 2 #f 11 3 0 0 34 2 lambda 17 eq? 2 10 5 2 #t 11 3 0 0 34 4 inner-lambda? 13 1 10 10 3 0 0 34 4 inner-lambda? 14 1 3 0 0 35 4 inner-lambda? 14 1) 18 inner-lambda? 1)
(15 1 (12 1 3 0 0 17 cadr 1 11) 18 arg1 1)
(15 1 (12 1 3 0 0 17 caddr 1 11) 18 arg2 1)
(15 1 (12 1 3 0 0 17 cadddr 1 11) 18 arg3 1)
(15 1 (12 1 3 0 0 34 11) 18 op 1)
(15 1 (12 1 3 0 0 2 (+) 17 memv 2 10 5 2 + 11 3 0 0 2 (-) 17 memv 2 10 5 2 - 11 3 0 0 2 (/) 17 memv 2 10 5 2 / 11 3 0 0 2 (*) 17 memv 2 10 5 2 * 11 3 0 0 2 (^) 17 memv 2 10 5 2 ^ 11 3 0 0 2 (sin) 17 memv 2 10 5 2 sin 11 3 0 0 2 (cos) 17 memv 2 10 5 2 cos 11 3 0 0 2 (exp) 17 memv 2 10 5 2 exp 11 3 0 0 2 (log) 17 memv 2 10 5 2 log 11 3 0 0 2 (sinh) 17 memv 2 10 5 2 sinh 11 3 0 0 2 (cosh) 17 memv 2 10 5 2 cosh 11 3 0 0 2 else 17 memv 2 10 11 2 "opecode else: " 3 0 0 17 error 2 11 17 undefined 0 11) 18 opcode 1)
(15 1 (12 1 3 0 0 2 (+) 17 memv 2 10 5 2 1 11 3 0 0 2 (-) 17 memv 2 10 5 2 1 11 3 0 0 2 (/) 17 memv 2 10 5 2 2 11 3 0 0 2 (*) 17 memv 2 10 5 2 3 11 3 0 0 2 (^) 17 memv 2 10 5 2 4 11 3 0 0 2 (sin) 17 memv 2 10 5 2 6 11 3 0 0 2 (cos) 17 memv 2 10 5 2 6 11 3 0 0 2 (exp) 17 memv 2 10 5 2 6 11 3 0 0 2 (log) 17 memv 2 10 5 2 6 11 3 0 0 2 (cosh) 17 memv 2 10 5 2 6 11 3 0 0 2 (sinh) 17 memv 2 10 5 2 6 11 3 0 0 2 else 17 memv 2 10 5 2 9 11 17 undefined 0 11) 18 weight 1)
(15 1 (12 1 3 0 0 4 infip 13 1 11) 18 infix->prefix 1)
(15 1 (12 1 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 2 () 2 () 4 inf1 14 3) 18 infip 1)
(15 3 (12 3 3 0 0 4 op 13 1 4 weight 13 1 2 5 22 10 18 3 0 0 4 op 13 1 4 weight 13 1 2 5 22 8 16 3 0 0 4 op 13 1 4 weight 13 1 2 7 24 10 25 3 0 0 35 3 0 1 3 0 0 34 4 infip 13 1 3 0 2 36 4 inf2 14 3 3 0 0 17 cddr 1 3 0 1 3 0 0 4 op 13 1 3 0 0 4 arg1 13 1 4 infip 13 1 17 list 2 3 0 2 36 4 inf3 14 3) 18 inf1 1)
(15 3 (12 3 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 7 3 0 2 34 11 3 0 0 17 null? 1 17 not 1 10 37 3 0 1 17 null? 1 10 10 3 0 1 17 null? 1 8 19 3 0 0 34 4 weight 13 1 3 0 1 34 4 weight 13 1 24 8 4 2 #f 10 21 3 0 0 35 3 0 0 34 3 0 1 36 3 0 2 4 inf1 14 3 3 0 0 3 0 1 35 3 0 1 34 4 opcode 13 1 3 0 2 17 cadr 1 3 0 2 34 17 list 3 3 0 2 17 cddr 1 36 4 inf2 14 3) 18 inf2 1)
(15 3 (12 3 3 0 0 17 null? 1 10 10 3 0 2 17 null? 1 8 4 2 #f 10 7 3 0 2 34 11 3 0 0 17 null? 1 17 not 1 10 39 3 0 1 17 null? 1 10 10 3 0 1 17 null? 1 8 21 3 0 0 34 4 weight 13 1 3 0 0 17 cadr 1 4 weight 13 1 24 8 4 2 #f 10 21 3 0 0 35 3 0 0 34 3 0 1 36 3 0 2 4 inf1 14 3 3 0 0 3 0 1 3 0 2 4 inf2 14 3) 18 inf3 1)
(15 1 (12 1 3 0 0 3 0 0 4 pass1 13 1 4 pass2 13 2 11) 18 assemble 1)
(15 1 (12 1 3 0 0 2 1 2 () 4 pass1-iter 13 3 11) 18 pass1 1)
(15 3 (12 3 3 0 0 17 null? 1 10 6 3 0 2 11 3 0 0 34 4 label? 13 1 10 25 3 0 0 35 3 0 1 3 0 0 34 3 0 1 36 3 0 2 36 4 pass1-iter 14 3 3 0 0 35 3 0 1 3 0 0 34 4 op-count 13 1 17 + 2 3 0 2 4 pass1-iter 14 3) 18 pass1-iter 1)
(15 2 (12 2 3 0 0 2 1 2 () 3 0 1 4 pass2-iter 13 4 11) 18 pass2 1)
(15 4 (12 4 3 0 0 17 null? 1 10 9 3 0 2 17 reverse 1 11 3 0 0 34 4 label? 13 1 10 19 3 0 0 35 3 0 1 3 0 2 3 0 3 4 pass2-iter 14 4 3 0 0 35 3 0 1 3 0 0 34 4 op-count 13 1 17 + 2 3 0 0 34 3 0 3 3 0 1 4 mnemonic->code 13 3 17 reverse 1 3 0 2 17 append 2 3 0 3 4 pass2-iter 14 4) 18 pass2-iter 1)
(15 3 (12 3 3 0 0 34 2 halt 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 const 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 lvar 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 gvar 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 lset 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 gset 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 pop 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 jump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 tjump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 fjump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 return 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 args 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 call 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 callj 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 fn 17 eqv? 2 10 30 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 4 assemble 13 1 17 list 3 11 3 0 0 34 2 save 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 prim 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 def 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 defm 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 defh 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 neqp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 smlp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 esmlp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 grtp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 egrtp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 zerop 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 add1 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 sub1 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 add2 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 sub2 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 gref 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 catch 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 pause 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 car 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 cdr 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 cons 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 adapt 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 deflib 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 explib 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 implib 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 17 undefined 0 11) 18 mnemonic->code 1)
(15 1 (12 1 3 0 0 17 length 1 11) 18 op-count 1)
(15 1 (12 1 3 0 0 4 mnemonic 17 member 2 11) 18 op-code? 1)
(15 1 (12 1 4 mnemonic 17 length 1 3 0 0 4 mnemonic 17 member 2 17 length 1 17 - 2 11) 18 op-code 1)
(2 nop 2 halt 2 const 2 lvar 2 gvar 2 lset 2 gset 2 pop 2 jump 2 tjump 2 fjump 2 return 2 args 2 call 2 callj 2 fn 2 save 2 prim 2 def 2 defm 2 defh 2 neqp 2 smlp 2 esmlp 2 grtp 2 egrtp 2 zerop 2 add1 2 sub1 2 add2 2 sub2 2 gref 2 catch 2 pause 2 car 2 cdr 2 cons 2 adapt 2 deflib 2 explib 2 implib 17 list 41 18 mnemonic 1)
(2 ((car 1 1 #t #f) (cdr 1 1 #t #f) (cons 2 2 #t #f) (caar 1 1 #t #f) (cdar 1 1 #t #f) (cddr 1 1 #t #f) (cadr 1 1 #t #f) (caaar 1 1 #t #f) (cdaar 1 1 #t #f) (cadar 1 1 #t #f) (caadr 1 1 #t #f) (cddar 1 1 #t #f) (caddr 1 1 #t #f) (cdadr 1 1 #t #f) (cdddr 1 1 #t #f) (caaaar 1 1 #t #f) (cdaaar 1 1 #t #f) (cadaar 1 1 #t #f) (caadar 1 1 #t #f) (caaadr 1 1 #t #f) (cddaar 1 1 #t #f) (caddar 1 1 #t #f) (caaddr 1 1 #t #f) (cdaadr 1 1 #t #f) (cdadar 1 1 #t #f) (cadddr 1 1 #t #f) (cdaddr 1 1 #t #f) (cddadr 1 1 #t #f) (cdddar 1 1 #t #f) (cddddr 1 1 #t #f) (assq 2 2 #t #f) (assv 2 2 #t #f) (assoc 2 2 #t #f) (memq 2 2 #t #f) (memv 2 2 #t #f) (member 2 2 #t #f) (reverse 1 1 #t #f) (reverse! 1 1 #t #t) (list-tail 1 1 #t #f) (list-ref 2 2 #t #f) (append 2 2 #t #f) (append! 2 infinity #t #ft) (set-car! 2 2 #t #f) (set-cdr! 2 2 #t #f) (list 0 infinity #t #f) (length 1 1 #t #f) (pair-length 1 1 #t #f) (last 1 1 #t #f) (butlast 1 1 #t #f) (newline 0 1 #t #t) (display 1 2 #t #t) (write 1 2 #t #t) (write-char 1 1 #t #t) (null? 1 1 #t #f) (list? 1 1 #t #f) (pair? 1 1 #t #f) (atom? 1 1 #t #f) (eq? 1 infinity #t #f) (eqv? 1 infinity #t #f) (equal? 1 infinity #t #f) (boolean? 1 1 #t #f) (procedure? 1 1 #t #f) (number? 1 1 #t #f) (integer? 1 1 #t #f) (real? 1 1 #t #f) (rational? 1 1 #t #f) (complex? 1 1 #t #f) (exact? 1 1 #t #f) (inexact? 1 1 #t #f) (symbol? 1 1 #t #f) (string? 1 1 #t #f) (char? 1 1 #t #f) (bignum? 1 1 #t #f) (vector? 1 1 #t #f) (macro? 1 1 #t #f) (macro-name? 1 1 #t #f) (hygienic-name? 1 1 #t #f) (zero? 1 1 #t #f) (+ 0 infinity #t #f) (- 1 infinity #t #f) (* 0 infinity #t #f) (/ 1 infinity #t #f) (< 2 infinity #t #f) (<= 2 infinity #t #f) (> 2 infinity #t #f) (>= 2 infinity #t #f) (= 2 infinity #t #f) (sin 1 1 #t #f) (cos 1 1 #t #f) (tan 1 1 #t #f) (asin 1 1 #t #f) (acos 1 1 #t #f) (atan 1 2 #t #f) (log 1 1 #t #f) (exp 1 1 #t #f) (sqrt 1 1 #t #f) (expt 2 2 #t #f) (not 1 1 #t #f) (odd? 1 1 #t #f) (even? 1 1 #t #f) (floor 1 1 #t #f) (ceiling 1 1 #t #f) (truncate 1 1 #t #f) (round 1 1 #t #f) (numerator 1 1 #t #f) (denominator 1 1 #t #f) (positive? 1 1 #t #f) (negative? 1 1 #t #f) (abs 1 1 #t #f) (max 1 infinity #t #f) (min 1 infinity #t #f) (real-part 1 1 #t #f) (imag-part 1 1 #t #f) (magnitude 1 1 #t #f) (angle 1 1 #t #f) (make-rectangular 2 2 #t #f) (make-polar 2 2 #t #f) (exact->inexact 1 1 #t #f) (inexact->exact 1 1 #t #f) (remainder 2 2 #t #f) (modulo 2 2 #t #f) (quotient 2 2 #t #f) (gcd 0 2 #t #f) (lcm 0 2 #t #f) (char=? 2 2 #t #f) (char>? 2 2 #t #f) (char>=? 2 2 #t #f) (char<? 2 2 #t #f) (char<=? 2 2 #t #f) (char-ci=? 2 2 #t #f) (char-ci>? 2 2 #t #f) (char-ci>=? 2 2 #t #f) (char-ci<? 2 2 #t #f) (char-ci<=? 2 2 #t #f) (char-alphabetic? 1 1 #t #f) (char-numeric? 1 1 #t #f) (char-whitespace? 1 1 #t #f) (char-upper-case? 1 1 #t #f) (char-lower-case? 1 1 #t #f) (char->integer 1 1 #t #f) (integer->char 1 1 #t #f) (char-upcase 1 1 #t #f) (char-downcase 1 1 #t #f) (string-append 1 infinity #t #f) (number->string 1 2 #t #f) (string->number 1 2 #t #f) (string=? 1 1 #t #f) (string>? 1 1 #t #f) (string>=? 1 1 #t #f) (string<? 1 1 #t #f) (string<=? 1 1 #t #f) (string-ci=? 1 1 #t #f) (string-ci>? 1 1 #t #f) (string-ci>=? 1 1 #t #f) (string-ci<? 1 1 #t #f) (string-ci<=? 1 1 #t #f) (string->symbol 1 1 #t #f) (symbol->string 1 1 #t #f) (string-length 1 1 #t #f) (make-string 1 1 #t #f) (string 1 1 #t #f) (string-ref 2 2 #t #f) (string-set! 2 2 #t #t) (substring 1 1 #t #f) (string->list 1 1 #t #f) (list->string 1 1 #t #f) (string-copy 1 1 #t #f) (string-fill! 1 1 #t #t) (make-vector 2 2 #t #f) (vector-set! 3 3 #t #f) (vector 1 infinity #t #f) (vector-ref 2 2 #t #f) (vector-length 1 1 #t #f) (vector-fill! 2 2 #t #f) (vector->list 1 1 #t #f) (list->vector 1 1 #t #f) (read 0 1 #t #f) (load 1 1 #t #f) (open-input-file 1 1 #t #t) (open-output-file 1 1 #t #t) (close-input-port 1 1 #t #t) (close-output-port 1 1 #t #t) (eof-object? 1 1 #t #f) (input-port? 1 1 #t #f) (output-port? 1 1 #t #f) (current-input-port 1 1 #t #f) (current-output-port 1 1 #t #f) (read-char 1 1 #t #f) (peek-char 1 1 #t #f) (char-ready? 1 1 #t #f) (exit 0 0 #t #t) (gensym 0 1 #t #f) (apply 2 infinity #t #t) (primitive-name? 1 1 #t #f) (macroexpand-1 1 1 #t #f) (macroexpand 1 1 #t #f) (addr 1 1 #t #f) (entity-addr 1 1 #t #f) (undefined 0 0 #t #f) (step 1 1 #t #t) (vm2-step 1 1 #t #t) (vm1 1 1 #t #t) (vm2 1 1 #t #t) (dump 1 2 #t #t) (addr-prt 1 1 #t #t) (gbc 0 1 #t #t) (room 0 0 #t #f) (vmcode 1 1 #t #f) (env 1 1 #t #f) (timer-set 0 0 #t #t) (timer-get 0 0 #t #t) (timer-gbc 0 0 #t #t) (eval 1 1 #t #f) (load 1 1 #t #t) (error 2 infinity #t #t) (flush 0 1 #t #t) (set-trace 0 infinity #t #t) (set-untrace 0 infinity #t #t) (current-module 0 0 #t #f) (transfer 1 1 #t #f) (debug 1 1 #t #t) (profiler 1 1 #t #t) (lambda/asm 2 2 #t #f) (values 0 infinity #t #t) (sys-cont-room 1 1 #t #t) (make-syntactic-clousre 3 3 #t #t) (symbol->identifier 1 1 #t #f) (identifier->symbol 1 1 #t #f) (syntactic-closure? 1 1 #t #f) (identifier? 1 1 #t #f) (identifier-bind! 2 2 #t #t) (identifier-free? 1 1 #t #f) (identifier-bound? 1 1 #t #f) (identifier-bound 1 1 #t #f) (global-bound? 1 1 #t #f) (inspect 0 0 #t #t) (exact-integer? 1 1 #t #f) (file-exists? 1 1 #t #f) (system 1 1 #t #t)) 18 *primitive* 1)
(15 1 (12 1 3 0 0 2 ".scm" 17 string-append 2 15 1 (12 1 3 1 0 2 ".o" 17 string-append 2 15 1 (12 1 3 1 0 17 open-input-file 1 15 1 (12 1 3 1 0 17 open-output-file 1 15 1 (12 1 3 1 0 17 read 1 3 1 0 3 0 0 4 compile-file1 13 3 7 3 1 0 17 close-input-port 1 7 3 0 0 17 close-output-port 1 7 2 "compiled!" 17 display 1 7 17 flush 0 11) 13 1 11) 13 1 11) 13 1 11) 13 1 11) 18 compile-file 1)
(15 3 (12 3 3 0 0 17 eof-object? 1 10 5 2 #t 11 3 0 0 4 compile 13 1 4 assemble 13 1 3 0 2 17 write 2 7 3 0 2 17 newline 1 7 3 0 1 17 read 1 3 0 1 3 0 2 4 compile-file1 14 3) 18 compile-file1 1)
(2 1 2 ((args 1) (catch) (lvar 0 0) (call 1) (return)) 17 lambda/asm 2 18 ncall/cc 1)
(2 2 2 ((args 2) (lvar 0 0) (call 0) (adapt) (lvar 0 1) (call 0) (return)) 17 lambda/asm 2 18 call-with-values 1)
(2 () 18 winders 1)
(15 3 (12 3 3 0 0 13 0 7 3 0 0 3 0 2 36 4 winders 36 6 winders 7 3 0 1 13 0 15 1 (12 1 4 winders 35 6 winders 7 3 1 2 13 0 7 3 0 0 11) 13 1 11) 18 dynamic-wind 1)
(15 2 (12 2 3 0 0 17 reverse 1 3 0 1 17 reverse 1 4 common-tail1 13 2 17 reverse 1 11) 18 common-tail 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 1 17 null? 1 10 5 2 () 11 3 0 0 34 3 0 1 34 17 eq? 2 17 not 1 10 5 2 () 11 3 0 0 34 3 0 0 35 3 0 1 35 4 common-tail1 13 2 36 11) 18 common-tail1 1)
(15 1 (12 1 3 0 0 4 winders 4 common-tail 13 2 15 1 (12 1 4 winders 3 0 0 4 do-wind-after 13 2 7 3 1 0 17 reverse 1 3 0 0 17 reverse 1 4 do-wind-before 13 2 7 3 1 0 6 winders 11) 13 1 11) 18 do-wind 1)
(15 2 (12 2 3 0 0 3 0 1 17 equal? 2 10 5 2 #t 11 3 0 0 17 cdar 1 13 0 7 3 0 0 35 3 0 1 4 do-wind-after 14 2) 18 do-wind-after 1)
(15 2 (12 2 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 5 2 #t 11 3 0 1 17 null? 1 10 22 3 0 0 17 caar 1 13 0 7 3 0 0 35 3 0 1 4 do-wind-before 14 2 3 0 0 35 3 0 1 35 4 do-wind-before 14 2) 18 do-wind-before 1)
(15 1 (12 1 15 1 (12 1 4 winders 15 1 (12 1 15 -1 (12 -1 3 1 0 4 winders 17 eq? 2 17 not 1 10 12 3 1 0 4 do-wind 13 1 7 8 2 3 2 0 3 0 0 17 apply 2 11) 11) 13 1 3 1 0 13 1 11) 4 ncall/cc 13 1 11) 18 call/cc 1)
(4 call/cc 18 call-with-current-continuation 1)
(15 3 (12 3 3 0 0 3 0 1 3 0 2 2 () 4 match1 13 4 11) 18 match 1)
(15 4 (12 4 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 6 3 0 3 11 3 0 0 4 ellipsis? 13 1 10 66 3 0 0 17 cddr 1 3 0 1 3 0 0 17 cddr 1 17 length 1 4 list-take-right 13 2 3 0 2 3 0 0 34 3 0 1 3 0 1 17 length 1 3 0 0 17 cddr 1 17 length 1 17 - 2 4 list-take 13 2 36 3 0 3 36 4 match1 13 4 11 3 0 0 17 null? 1 10 13 3 0 1 17 null? 1 17 not 1 8 4 2 #f 10 5 2 #f 11 3 0 0 17 identifier? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 13 3 0 0 3 0 1 36 17 list 1 11 3 0 0 17 null? 1 17 not 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 5 2 #f 11 3 0 0 34 17 atom? 1 10 34 3 0 0 34 3 0 2 17 memq 2 10 18 3 0 0 34 3 0 1 34 17 eq? 2 17 not 1 8 4 2 #f 8 4 2 #f 10 5 2 #f 11 3 0 0 34 17 atom? 1 10 31 3 0 0 35 3 0 1 35 3 0 2 3 0 0 34 3 0 1 34 36 3 0 3 36 4 match1 13 4 11 3 0 0 34 4 vec-ellipsis? 13 1 10 11 3 0 1 34 17 vector? 1 8 4 2 #f 10 39 3 0 0 35 3 0 1 35 3 0 2 3 0 0 34 2 0 17 vector-ref 2 3 0 1 34 17 vector->list 1 36 3 0 3 36 4 match1 13 4 11 3 0 0 4 ellipsises? 13 1 10 22 3 0 0 34 17 length 1 3 0 1 4 transpose 13 1 17 length 1 21 8 4 2 #f 10 15 3 0 1 4 transpose 13 1 15 1 (12 1 3 1 0 17 caar 1 3 0 0 34 36 3 1 0 17 cadar 1 3 0 0 17 cadr 1 36 17 list 2 3 1 3 17 append 2 11) 13 1 11 3 0 0 34 3 0 1 34 3 0 2 3 0 3 4 match1 13 4 3 0 0 35 3 0 1 35 3 0 2 3 0 3 4 match1 13 4 15 2 (12 2 3 0 0 10 7 3 0 1 8 4 2 #f 10 12 3 0 0 3 0 1 17 append 2 11 2 #f 11) 13 2 11) 18 match1 1)
(15 1 (12 1 2 *undef* 15 1 (12 1 15 2 (12 2 3 0 0 3 0 1 21 10 5 2 () 11 15 1 (12 1 3 0 0 3 1 0 17 list-ref 2 11) 3 2 0 4 map 13 2 3 0 0 27 3 0 1 3 1 0 13 2 36 11) 5 0 0 7 2 0 3 1 0 34 17 length 1 3 0 0 13 2 11) 13 1 11) 18 transpose 1)
(15 1 (12 1 3 0 0 17 list? 1 10 58 3 0 0 17 length 1 2 2 25 10 44 3 0 0 34 17 identifier? 1 10 11 3 0 0 34 17 identifier? 1 8 9 3 0 0 34 17 symbol? 1 10 14 3 0 0 17 cadr 1 2 ... 17 eqv? 2 11 2 #f 11 2 #f 11 2 #f 11) 18 ellipsis? 1)
(15 1 (12 1 3 0 0 17 list 1 10 40 3 0 0 17 length 1 2 2 25 10 26 3 0 0 34 17 list? 1 10 14 3 0 0 17 cadr 1 2 ... 17 eqv? 2 11 2 #f 11 2 #f 11 2 #f 11) 18 ellipsises? 1)
(15 1 (12 1 3 0 0 17 vector? 1 10 32 3 0 0 2 0 17 vector-ref 2 17 symbol? 1 10 16 3 0 0 2 1 17 vector-ref 2 2 ... 17 eq? 2 11 2 #f 11 2 #f 11) 18 vec-ellipsis? 1)
(15 2 (12 2 3 0 1 2 0 21 10 5 2 () 11 3 0 0 34 3 0 0 35 3 0 1 28 4 list-take 13 2 36 11) 18 list-take 1)
(15 2 (12 2 3 0 0 3 0 0 17 length 1 3 0 1 17 - 2 4 list-drop 13 2 11) 18 list-take-right 1)
(15 2 (12 2 3 0 1 2 0 21 10 6 3 0 0 11 3 0 0 35 3 0 1 28 4 list-drop 14 2) 18 list-drop 1)
(15 1 (12 1 3 0 0 2 fail 17 eq? 2 11) 18 fail? 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 symbol? 1 10 52 3 0 0 3 0 1 4 local-bound? 13 2 10 14 3 0 0 3 0 1 4 local-bound? 13 2 8 26 3 0 0 17 global-bound? 1 10 10 3 0 0 17 global-bound? 1 8 10 3 0 0 2 else 17 eq? 2 8 4 2 #f 10 15 3 0 0 17 symbol->identifier 1 3 0 0 17 identifier-bind! 2 11 3 0 0 17 symbol? 1 10 9 3 0 0 17 symbol->identifier 1 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 34 3 0 1 4 subst-to-identifier 13 2 3 0 0 35 3 0 1 4 subst-to-identifier 13 2 36 11) 18 subst-to-identifier 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 #f 11 3 0 0 3 0 1 34 17 member 2 10 5 2 #t 11 3 0 0 3 0 1 35 4 local-bound? 14 2) 18 local-bound? 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier? 1 10 13 3 0 0 3 0 1 17 assv 2 8 4 2 #f 10 19 3 0 0 3 0 0 3 0 1 17 assv 2 35 17 identifier-bind! 2 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 34 3 0 1 4 subst-pattern-vars 13 2 3 0 0 35 3 0 1 4 subst-pattern-vars 13 2 36 11) 18 subst-pattern-vars 1)
(15 1 (12 1 3 0 0 3 0 0 2 () 4 scan-let-vars 13 2 4 subst-let-vars1 13 2 11) 18 subst-let-vars 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier? 1 10 25 3 0 0 17 identifier-free? 1 10 13 3 0 0 3 0 1 17 assv 2 8 4 2 #f 8 4 2 #f 10 19 3 0 0 3 0 0 3 0 1 17 assv 2 35 17 identifier-bind! 2 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 34 3 0 1 4 subst-let-vars1 13 2 3 0 0 35 3 0 1 4 subst-let-vars1 13 2 36 11) 18 subst-let-vars1 1)
(15 2 (12 2 3 0 0 17 null? 1 10 12 15 1 (12 1 3 0 0 17 gensym 0 36 11) 3 0 1 4 map 14 2 3 0 0 17 atom? 1 10 5 2 () 11 3 0 0 4 lambda? 13 1 10 13 3 0 0 17 cadr 1 17 atom? 1 8 4 2 #f 10 22 3 0 0 17 cddr 1 3 0 0 17 cadr 1 3 0 1 36 4 scan-let-vars 14 2 3 0 0 4 lambda? 13 1 10 31 3 0 0 17 cadr 1 17 list? 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 8 4 2 #f 10 24 3 0 0 17 cddr 1 3 0 0 17 cadr 1 3 0 1 17 append 2 4 scan-let-vars 14 2 3 0 0 4 lambda? 13 1 10 31 3 0 0 17 cadr 1 17 pair? 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 8 4 2 #f 10 22 3 0 0 17 caddr 1 3 0 0 17 cadr 1 4 pair->list 13 1 4 scan-let-vars 14 2 3 0 0 4 let? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 let*? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 letrec? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 named-let? 13 1 10 16 3 0 0 17 caddr 1 17 null? 1 17 not 1 8 4 2 #f 10 36 3 0 0 17 cdddr 1 3 0 0 17 caddr 1 4 transpose 13 1 34 3 0 0 17 cadr 1 3 0 1 36 17 append 2 4 scan-let-vars 14 2 3 0 0 35 3 0 1 4 scan-let-vars 14 2) 18 scan-let-vars 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 lambda 17 eqv? 2 11 2 #f 11 2 #f 11) 18 lambda? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 43 3 0 0 17 length 1 2 3 25 10 29 3 0 0 34 2 let 17 eqv? 2 10 15 3 0 0 17 cadr 1 17 identifier? 1 17 not 1 11 2 #f 11 2 #f 11 2 #f 11) 18 let? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 40 3 0 0 17 length 1 2 4 25 10 26 3 0 0 34 2 let 17 eqv? 2 10 12 3 0 0 17 cadr 1 17 identifier? 1 11 2 #f 11 2 #f 11 2 #f 11) 18 named-let? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 letrec 17 eqv? 2 11 2 #f 11 2 #f 11) 18 letrec? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 let* 17 eqv? 2 11 2 #f 11 2 #f 11) 18 let*? 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier-free? 1 10 6 3 0 0 11 3 0 0 17 identifier? 1 10 9 3 0 0 17 identifier-bound 1 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 17 length 1 2 2 21 10 11 3 0 0 4 ellipsis? 13 1 8 4 2 #f 10 10 3 0 0 34 17 identifier-bound 1 11 3 0 0 17 length 1 2 2 24 10 17 3 0 0 2 2 4 list-take 13 2 4 ellipsis? 13 1 8 4 2 #f 10 23 3 0 0 34 17 identifier-bound 1 3 0 0 17 cddr 1 4 subst-from-identifier 13 1 17 append 2 11 3 0 0 34 4 subst-from-identifier 13 1 3 0 0 35 4 subst-from-identifier 13 1 36 11) 18 subst-from-identifier 1)
(15 3 (12 3 3 0 0 3 0 2 4 subst-to-identifier 13 2 3 0 1 4 subst-pattern-vars 13 2 4 subst-let-vars 13 1 4 subst-from-identifier 13 1 11) 18 expand-template 1)
(15 4 (12 4 3 0 0 17 caar 1 15 1 (12 1 3 1 0 17 cadar 1 15 1 (12 1 3 1 0 3 2 1 3 2 2 4 match 13 3 15 1 (12 1 3 0 0 10 15 3 1 0 3 0 0 3 3 3 4 expand-template 14 3 3 3 0 35 17 null? 1 10 11 2 "syntax-rules fail " 3 3 1 17 error 2 11 3 3 0 35 3 3 1 3 3 2 3 3 3 4 expand 14 4) 13 1 11) 13 1 11) 13 1 11) 18 expand 1)
(15 -3 (12 -3 17 undefined 0 17 undefined 0 15 2 (12 2 15 1 (12 1 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 34 3 2 0 13 1 3 0 0 35 3 1 0 13 1 36 11) 5 0 0 7 15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 2 0 3 0 0 34 4 car 3 0 1 4 map 13 2 17 apply 3 3 0 0 35 4 cdr 3 0 1 4 map 13 2 3 1 1 13 2 36 11) 5 0 1 7 3 1 2 17 null? 1 10 10 3 1 1 3 0 0 14 1 3 1 1 3 1 2 3 0 1 14 2) 13 2 11) 18 map 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 5 2 #t 11 3 0 0 35 17 null? 1 10 7 3 0 0 34 11 2 if 3 0 0 34 2 and 3 0 0 35 2 () 17 append 2 36 2 #f 2 () 36 36 36 36 11) 19 and 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 5 2 #f 11 3 0 0 35 17 null? 1 10 7 3 0 0 34 11 2 if 3 0 0 34 3 0 0 34 2 or 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 11) 19 or 1)
(15 -2 (12 -2 3 0 0 17 null? 1 10 20 2 lambda 2 () 3 0 1 2 () 17 append 2 36 36 2 () 36 11 3 0 0 17 pair? 1 10 39 2 lambda 4 car 3 0 0 4 map 13 2 3 0 1 2 () 17 append 2 36 36 4 cadr 3 0 0 4 map 13 2 2 () 17 append 2 36 11 2 letrec 3 0 0 2 lambda 4 car 3 0 1 34 4 map 13 2 3 0 1 35 2 () 17 append 2 36 36 2 () 36 36 2 () 36 3 0 0 4 cadr 3 0 1 34 4 map 13 2 2 () 17 append 2 36 2 () 36 36 36 11) 19 let 1)
(15 -2 (12 -2 3 0 0 17 null? 1 10 20 2 lambda 2 () 3 0 1 2 () 17 append 2 36 36 2 () 36 11 3 0 0 35 17 null? 1 10 22 2 let 3 0 0 34 2 () 36 3 0 1 2 () 17 append 2 36 36 11 2 let 3 0 0 34 2 () 36 2 let* 3 0 0 35 3 0 1 2 () 17 append 2 36 36 2 () 36 36 36 11) 19 let* 1)
(15 -2 (12 -2 4 car 3 0 0 4 map 13 2 4 cadr 3 0 0 4 map 13 2 15 2 (12 2 2 let 15 1 (12 1 3 0 0 2 quote 2 *undef* 2 () 36 36 2 () 36 36 11) 3 0 0 4 map 13 2 15 2 (12 2 2 set! 3 0 0 3 0 1 2 () 36 36 36 11) 3 0 0 3 0 1 4 map 13 3 3 1 1 2 () 17 append 2 17 append 2 36 36 11) 13 2 11) 19 letrec 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 8 2 undefined 2 () 36 11 3 0 0 17 cdar 1 17 null? 1 10 49 2 let 2 *val* 3 0 0 17 caar 1 2 () 36 36 2 () 36 2 if 2 *val* 2 *val* 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 2 () 36 36 36 11 3 0 0 17 cadar 1 2 => 17 eq? 2 10 46 2 let 2 *val* 3 0 0 17 caar 1 2 () 36 36 2 () 36 2 if 2 *val* 3 0 0 17 caddar 1 2 *val* 2 () 36 36 2 () 36 36 36 2 () 36 36 36 11 3 0 0 17 caar 1 2 else 17 eqv? 2 10 36 3 0 0 17 cdar 1 4 length=1? 13 1 10 9 3 0 0 17 cadar 1 11 2 begin 3 0 0 17 cdar 1 2 () 17 append 2 36 11 3 0 0 17 cdar 1 4 length=1? 13 1 10 37 2 if 3 0 0 17 caar 1 3 0 0 17 cdar 1 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 17 append 2 36 36 11 2 if 3 0 0 17 caar 1 2 begin 3 0 0 17 cdar 1 2 () 17 append 2 36 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 11) 19 cond 1)
(15 -2 (12 -2 3 0 1 17 null? 1 10 8 2 undefined 2 () 36 11 3 0 1 17 caar 1 2 else 17 eq? 2 10 17 2 begin 3 0 1 17 cdar 1 2 () 17 append 2 36 11 2 if 2 memv 3 0 0 2 quote 3 0 1 17 caar 1 2 () 36 36 2 () 36 36 36 2 begin 3 0 1 17 cdar 1 2 () 17 append 2 36 2 case 3 0 0 3 0 1 35 2 () 17 append 2 36 36 2 () 36 36 36 36 11) 19 case 1)
(15 -3 (12 -3 4 car 3 0 0 4 map 13 2 4 cadr 3 0 0 4 map 13 2 4 cddr 3 0 0 4 map 13 2 15 3 (12 3 2 letrec 2 loop 2 lambda 3 0 0 2 if 3 1 1 34 2 begin 3 1 1 35 2 () 17 append 2 36 2 begin 3 1 2 2 loop 15 2 (12 2 3 0 0 17 null? 1 10 6 3 0 1 11 3 0 0 34 11) 3 0 2 3 0 0 4 map 13 3 2 () 17 append 2 36 2 () 36 17 append 2 36 2 () 36 36 36 36 2 () 36 36 36 2 () 36 36 2 () 36 2 loop 3 0 1 2 () 17 append 2 36 2 () 36 36 36 11) 13 3 11) 19 do 1)
(15 -3 (12 -3 2 *undef* 15 1 (12 1 15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 2 0 3 0 0 34 4 car 3 0 1 4 map 13 2 17 apply 3 7 3 0 0 35 4 cdr 3 0 1 4 map 13 2 3 1 0 14 2) 5 0 0 7 3 1 1 3 1 2 3 0 0 13 2 11) 13 1 7 17 undefined 0 11) 18 for-each 1)
;;––”öÄ‹AÅ“K‰»ƒRƒ“ƒpƒCƒ‰
;;has-lambda? “ü‚êq‚Ìlambda®‚ğ‚à‚Â‚©‚Ç‚¤‚©B
;;in-lambda?@lambda®‚Ì’†‚Ì®‚©‚Ç‚¤‚©H
;;tail?@––”öÄ‹AÅ“K‰»‚ğ‚·‚é‚×‚«‚©‚Ç‚¤‚©H
;;define-macro‚Ì‚Æ‚«‚É‚Í#f‚É‚·‚éB
;;--------------------------------- 


(define (compile x)
  (append (comp (transfer x) '() #t #t #f #f #t #f) (list (list 'halt))))


(define (comp x env val? more? has-lambda? in-lambda? tail? if?)
  (cond ((null? x) (comp-const x val? more? in-lambda?))
        ((boolean? x) (comp-const x val? more? in-lambda?))
        ((symbol? x) (comp-var x env val? more? in-lambda?))
        ((identifier-free? x) (comp-var x env val? more? in-lambda?))
        ((atom? x ) (comp-const x val? more? in-lambda?))
        ((vector? x) (comp-const x val? more? in-lambda?))
        ((macro-name? (car x))
         (comp (macroexpand-1 x) env val? more? has-lambda? in-lambda? tail? if?))
        ((hygienic-name? (car x))
         (comp (macroexpand-1 x) env val? more? has-lambda? in-lambda? tail? if?))
        ((eqv? (car x) 'quote)
         (args-count-check x 1 1)
         (comp-const (cadr x) val? more? in-lambda?))
        ((eqv? (car x) 'begin)
         (comp-begin (cdr x) env val? more? has-lambda? in-lambda? tail? if?))
        ((eqv? (car x) 'set!)
         (args-count-check x 2 2)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? tail? if?)
              (gen-set (cadr x) env)
              (if (not val?) (gen 'pop) '())
              (if (not more?) (gen 'return) '())))
        ((eqv? (car x) 'if)
         (if (= (length x) 3) (set! x (append x '((undefined)))) (undefined))
         (args-count-check x 3 3)
         (comp-if (cadr x) (caddr x) (cadddr x)
                  env val? more? has-lambda? in-lambda? tail? #t))
        ((eqv? (car x) 'lambda)
         (if val?
             (let ((f (comp-lambda (cadr x) (cddr x) env tail? if?)))
               (seq (gen 'fn (args-count (cadr x))f)
                    (if (not more?) (gen 'return) '())))
             #f))
        ((eqv? (car x) 'define)
         (args-type-check x 1 symbol? "require symbol ")
         (args-type-check x 1 (lambda (y) (not (primitive-name? y)))
                          "can't overwrite primitive name ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? tail? if?) 
              (gen 'def (cadr x))))
        ((eqv? (car x) 'define-macro)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? #f if?)
              (gen 'defm (cadr x))))
        ((eqv? (car x) 'define-syntax)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? #f if?)
              (gen 'defh (cadr x) env)))
        ((eqv? (car x) 'define-library)
         (args-count-check x 2 'infinity)
         (args-type-check x 1 list? "require list for library name")
         (seq (gen 'deflib (cadr x) (cddr x))
              (gen 'const (cadr x))))
        ((eqv? (car x) 'export)
         (args-count-check x 1 'infinity)
         (seq (gen 'explib (cdr x))))
        ((eqv? (car x) 'import)
         (args-count-check x 1 'infinity)
         (seq (gen 'implib (cdr x))))
        ((eqv? (car x) 'math)
         (comp (infix->prefix (cdr x)) env val? more? has-lambda? in-lambda? tail? if?))
        ((eqv? (car x) 'syntax-rules)
         (comp `(lambda (expr comp-env vm-env) (expand ',(cddr x) expr ,(cadr x) comp-env))
               env val? more? has-lambda? in-lambda? tail? if?))
        (else
          (comp-funcall (car x) (cdr x) env val? more? has-lambda? in-lambda? tail? if?))))


(define (comp-const x val? more? in-lambda?)
  (if val? 
      (seq (gen 'const x)
           (if (and (not more?) in-lambda?)
               (gen 'return)
               '()))
      '()))

(define (comp-var x env val? more? in-lambda?)
  (if val?
      (seq (gen-var x env)
           (if (and (not more?) in-lambda?)
               (gen 'return)
               '()))
      '()))

(define (comp-begin exps env val? more? has-lambda? in-lambda? tail? if?)
  (cond ((null? exps) (comp-const '() val? more? in-lambda?))
        ((length=1? exps) (comp (transfer (car exps)) env val? #f has-lambda? in-lambda? tail? if?))
        (else (seq (comp (transfer (car exps)) env #f #t has-lambda? in-lambda? tail? if?)
                   (comp-begin  (cdr exps) env val? more? has-lambda? in-lambda? tail? if?)))))


(define (comp-list exps env has-lambda? in-lambda? tail? if?)
  (if (null? exps)
      '()
      (seq (comp (car exps) env #t #t has-lambda? in-lambda? tail? if?)
           (comp-list (cdr exps) env has-lambda? in-lambda? tail? if?))))

(define (comp-if pred then else env val? more? has-lambda? in-lambda? tail? if?)
  (cond ((not pred)
         (comp else env val? more? has-lambda? in-lambda? tail? if?))
        ((and (atom? pred) (not (symbol? pred)) (not (not pred)))
         (comp then env val? more? has-lambda? in-lambda? tail? if?))
        ((and (list? pred)
              (length=1? (cdr pred))
              (eq? (car pred) 'not))
         (comp-if (cadr pred) else then env val? more? has-lambda? in-lambda? tail? if?))
        (else 
          (let ((pcode (comp pred env #t #t has-lambda? in-lambda? tail? if?))
                (tcode (comp then env val? more? has-lambda? in-lambda? tail? if?))
                (ecode (comp else env val? more? has-lambda? in-lambda? tail? if?)))
            (cond ((equal? tcode ecode)
                   (seq (comp pred env #f #t has-lambda? in-lambda? tail? if?) ecode))
                  ((not tcode)
                   (let ((L2 (gen-label)))
                     (seq pcode (gen 'tjump L2) ecode (list L2)
                          (if (not more?) (gen 'return) '()))))
                  (else
                    (let ((L1 (gen-label))
                          (L2 (if more? (gen-label) #f)))
                      (seq pcode (gen 'fjump L1) tcode
                           (if more? (gen 'jump L2) '())
                           (list L1) ecode (if more? (list L2) '())))))))))

(define (comp-funcall f args env val? more? has-lambda? in-lambda? tail? if?)
  (if (and (not (symbol? f)) (not (list? f))) (error "illegal function call " f))
  (let ((prim (primitive? f env)))
    (cond (prim
            (args-count-check (cons f args) (prim-min prim) (prim-max prim))
            (cond ((and (not val?) (not (prim-side-effect? prim)))
                   (comp-begin args env #f more? has-lambda? in-lambda? tail? if?))
                  ((and (memv f '(= < <= > >=))(= (length args) 2));;2€”äŠr‰‰Zq
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen (cadr (assv f binomial-op)))
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eqv? f 'zero?)(= (length args) 1));;(zero? n)->(zerop)
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen 'zerop)
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eqv? f '-)(= (length args) 2)
                        (or (eq? (cadr args) 1) (eq? (cadr args) 2))) ;;(- x 1or2)->(sub1or2)
                   (seq (comp-list (butlast args) env has-lambda? in-lambda? tail? if?)
                        (if (= (cadr args) 1) (gen 'sub1) (gen 'sub2))
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eqv? f '+)(= (length args) 2)
                        (or (eq? (cadr args) 1) (eq? (cadr args) 2))) ;;(+ x 1or2)->(add1or2)
                   (seq (comp-list (butlast args) env has-lambda? in-lambda? tail? if?)
                        (if (= (cadr args) 1) (gen 'add1) (gen 'add2))
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((eqv? f 'car)
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen 'car)
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((eqv? f 'cdr)
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen 'cdr)
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((eqv? f 'cons)
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen 'cons)
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  (else (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                             (gen 'prim f (length args))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))))
          ((and (list? f) (eqv? (car f) 'lambda) (null? (cadr f)))
           (if (not (null? args)) (error "too many arguments: " args) '())
           (comp-begin (cddr f) env val? more? has-lambda? #f tail? if?))
          ((and (not more?)(not has-lambda?) tail? if?)
           (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                (comp f env #t #t has-lambda? in-lambda? tail? if?)
                (gen 'callj (length args))))
          ((eqv? f 'call/cc)
           (seq (comp-list args env has-lambda? in-lambda? #f if?)
                (comp f env #t #t has-lambda? in-lambda? tail? if?)
                (gen 'call (length args))
                (if (not val?) (gen 'pop) '())
                (if (not more?) (gen 'return) '())))
          (else
            (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                 (comp f env #t #t has-lambda? in-lambda? tail? if?)
                 (gen 'call (length args))
                 (if (not val?) (gen 'pop) '())
                 (if (not more?) (gen 'return) '()))))))


(define binomial-op
  '((= neqp) (< smlp) (<= esmlp)
    (> grtp) (>= egrtp)))


(define (prim-always? x)
  (cadddr x))

(define (prim-side-effect? x)
  (cadr (cdddr x)))

(define (prim-min x)
  (cadr x))

(define (prim-max x)
  (caddr x))


(define (primitive? x env)
  (and (not (in-env? x env))
       (assoc x *primitive*)))

;;macro‚Å‚Ítail?=#f‚É‚µ‚Ä––”öÄ‹AÅ“K‰»‚Í‚µ‚È‚¢B
(define (comp-lambda args body env tail? if?)
  (if tail?
      (seq (gen 'args (args-count args))
           (comp-begin body
                       (cons args env) #t #t 
                       (inner-lambda? (macroexpand body)) #t tail? if?))
      (seq (gen 'args (args-count args))
           (comp-begin body
                       (cons args env) #t #t #f #t tail? if?))))


(define (args-count x)
  (cond ((symbol? x) -1)
        ((list? x)(length x))
        (else (- (pair-length x)))))

(define (length=1? x)
  (and (list? x)
       (= (length x) 1)))

(define (mappend proc x)
  (if (null? x)
      '()
      (append (proc (car x)) (mappend proc (cdr x)))))

(define (lambda-args? x)
  (cond ((null? x) #t)
        ((symbol? x) #t)
        ((atom? x) #f)
        ((not (symbol? (car x))) #f)
        (else (lambda-args? (cdr x)))))

(define (symbol-or-list? x)
  (or (symbol? x)
      (list? x)))

(define (args-count-check x min max)
  (let ((n (length (cdr x))))
    (cond ((and (>= n min) (eq? max 'infinity)) #t)
          ((and (>= n min) (<= n max)) #t)
          (else (error "incorrect argument count " x)))))

(define (args-type-check x n pred msg)
  (if (pred (list-ref x n))
      #t
      (error msg x)))

(define (gen opcode . args)
  (list (cons opcode args)))

(define (gen-var var env)
  (let ((p (in-env? var env)))
    (cond (p (gen 'lvar (car p) (cadr p)))
          ((identifier-free? var) (gen 'gvar (identifier->symbol var)))
          (else (gen 'gvar var)))))

(define (gen-set var env)
  (let ((p (in-env? var env)))
    (if p
        (gen 'lset (car p) (cadr p))
        (gen 'gset var))))

(define (seq . code)
  (apply append code))

(define (gen-label)
  (gensym "L"))

(define (label? x)
  (and (symbol? x)
       (char=? (string-ref (symbol->string x) 2) #\L)))


(define (in-env? symbol env)
  (in-env-iter symbol env 0))

(define (in-env-iter symbol env i)
  (cond ((null? env) #f)
        ((in-args? symbol (car env)) (list i (nth-args symbol (car env))))
        (else (in-env-iter symbol (cdr env) (+ i 1)))))

(define (in-args? symbol args)
  (cond ((null? args) #f)
        ((and (symbol? args) (eq? symbol args)) #t)
        ((symbol? args) #f)
        ((eq? symbol (car args)) #t)
        (else (in-args? symbol (cdr args)))))


(define (nth-args symbol args)
  (cond ((and (symbol? args) (eq? symbol args)) 0)
        ((eq? symbol (car args)) 0)
        (else (+ 1 (nth-args symbol (cdr args))))))


(define (inner-lambda? x)
  (cond ((null? x) #f)
        ((atom? x) #f)
        ((vector? x) #f)
        ((eq? (car x) 'lambda) #t)
        (else (or (inner-lambda? (car x))
                  (inner-lambda? (cdr x))))))


;;“à‘}•\Œ»‚©‚ç‘O’u•\Œ»‚Ö•ÏŠ·‚·‚éB

(define (arg1 f)
  (cadr f))

(define (arg2 f)
  (caddr f))

(define (arg3 f)
  (cadddr f))

(define (op f)
  (car f))


(define (opcode op)
  (case op
        ((+) '+)((-) '-)((/) '/)((*) '*)((^) '^)
        ((sin) 'sin)((cos) 'cos)((exp) 'exp)((log) 'log)
        ((sinh) 'sinh)((cosh) 'cosh)
        (else (error "opecode else: " op))))

(define (weight op)
  (case op
        ((+) 1)((-) 1)((/) 2)((*) 3)((^) 4)
        ((sin) 6)((cos) 6)((exp) 6)((log) 6)
        ((cosh) 6)((sinh) 6)
        (else 9)))

(define (infix->prefix fmla)
  (infip fmla))

(define (infip fmla)
  (if (atom? fmla) fmla (inf1 fmla '() '())))

(define (inf1 fmla optr opln)
  (if (or (< (weight (op fmla)) 5)
          (> (weight (op fmla)) 7))
      (inf2 (cdr fmla) optr (cons (infip (car fmla)) opln))
      (inf3 (cddr fmla)
            optr
            (cons (list (op fmla) (infip (arg1 fmla))) opln))))

(define (inf2 fmla optr opln)
  (cond ((and (null? fmla) (null? optr))
         (car opln))
        ((and (not (null? fmla))
              (or (null? optr)
                  (> (weight (car fmla))
                     (weight (car optr)))))
         (inf1 (cdr fmla) (cons (car fmla) optr) opln))
        (else (inf2 fmla
                    (cdr optr)
                    (cons (list (opcode (car optr))
                                (cadr opln)
                                (car opln))
                          (cddr opln))))))

(define (inf3 fmla optr opln)
  (cond ((and (null? fmla) (null? opln))
         (car opln))
        ((and (not (null? fmla))
              (or (null? optr)
                  (> (weight (car fmla))
                     (weight (cadr fmla)))))
         (inf1 (cdr fmla) (cons (car fmla) optr) opln))
        (else (inf2 fmla optr opln)))) ;Œ´’˜C³




;;ƒAƒZƒ“ƒuƒ‰

(define (assemble ls)
  (pass2 ls (pass1 ls))) 


(define (pass1 x)
  (pass1-iter x 1 '()))

(define (pass1-iter ls pc labels)
  (cond ((null? ls) labels)
        ((label? (car ls))
         (pass1-iter (cdr ls) pc (cons (cons (car ls) pc) labels)))
        (else
          (pass1-iter (cdr ls) (+ pc (op-count (car ls))) labels))))

(define (pass2 x labels)
  (pass2-iter x 1 '() labels))

(define (pass2-iter ls pc obj labels)
  (cond ((null? ls) (reverse obj))
        ((label? (car ls)) (pass2-iter (cdr ls) pc obj labels))
        (else
          (pass2-iter (cdr ls)
                      (+ pc (op-count (car ls)))
                      (append (reverse (mnemonic->code (car ls) labels pc))
                              obj)
                      labels))))

(define (mnemonic->code x labels pc)
  (cond ((eqv? (car x) 'halt) (list (op-code (car x))))
        ((eqv? (car x) 'const) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'lvar) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'gvar) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'lset) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'gset) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'pop) (list (op-code (car x))))
        ((eqv? (car x) 'jump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
        ((eqv? (car x) 'tjump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
        ((eqv? (car x) 'fjump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
        ((eqv? (car x) 'return) (list (op-code (car x))))
        ((eqv? (car x) 'args) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'call) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'callj) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'fn) (list (op-code (car x)) (cadr x) (assemble (caddr x))))
        ((eqv? (car x) 'save) (list (op-code (car x))))
        ((eqv? (car x) 'prim) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'def) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'defm) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'defh) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'neqp) (list (op-code (car x))))
        ((eqv? (car x) 'smlp) (list (op-code (car x))))
        ((eqv? (car x) 'esmlp) (list (op-code (car x))))
        ((eqv? (car x) 'grtp) (list (op-code (car x))))
        ((eqv? (car x) 'egrtp) (list (op-code (car x))))
        ((eqv? (car x) 'zerop) (list (op-code (car x))))
        ((eqv? (car x) 'add1) (list (op-code (car x))))
        ((eqv? (car x) 'sub1) (list (op-code (car x))))
        ((eqv? (car x) 'add2) (list (op-code (car x))))
        ((eqv? (car x) 'sub2) (list (op-code (car x))))
        ((eqv? (car x) 'gref) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'catch) (list (op-code (car x))))
        ((eqv? (car x) 'pause) (list (op-code (car x))))
        ((eqv? (car x) 'car) (list (op-code (car x))))
        ((eqv? (car x) 'cdr) (list (op-code (car x))))
        ((eqv? (car x) 'cons) (list (op-code (car x))))
        ((eqv? (car x) 'adapt) (list (op-code (car x))))
        ((eqv? (car x) 'deflib) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'explib) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'implib) (list (op-code (car x)) (cadr x)))))

(define (op-count x) 
  (length x))


(define (op-code? x)
  (member x mnemonic))

(define (op-code x)
  (- (length mnemonic) (length (member x mnemonic))))


(define mnemonic 
  (list 'nop 'halt 'const 'lvar 'gvar 'lset 'gset 'pop 'jump 'tjump 'fjump
        'return 'args 'call 'callj 'fn 'save 'prim 'def 'defm 'defh
        'neqp 'smlp 'esmlp 'grtp 'egrtp 'zerop 
        'add1 'sub1 'add2 'sub2 'gref 'catch 'pause 'car 'cdr 'cons 'adapt
        'deflib 'explib 'implib))

;;(symbol-name args-min args-max always side-effect)
(define *primitive*
  '((car 1 1 #t #f)
    (cdr 1 1 #t #f)
    (cons 2 2 #t #f)
    (caar 1 1 #t #f)
    (cdar 1 1 #t #f)
    (cddr 1 1 #t #f)
    (cadr 1 1 #t #f)
    (caaar 1 1 #t #f)
    (cdaar 1 1 #t #f)
    (cadar 1 1 #t #f)
    (caadr 1 1 #t #f)
    (cddar 1 1 #t #f)
    (caddr 1 1 #t #f)
    (cdadr 1 1 #t #f)
    (cdddr 1 1 #t #f)
    (caaaar 1 1 #t #f)
    (cdaaar 1 1 #t #f)
    (cadaar 1 1 #t #f)
    (caadar 1 1 #t #f)
    (caaadr 1 1 #t #f)
    (cddaar 1 1 #t #f)
    (caddar 1 1 #t #f)
    (caaddr 1 1 #t #f)
    (cdaadr 1 1 #t #f)
    (cdadar 1 1 #t #f)
    (cadddr 1 1 #t #f)
    (cdaddr 1 1 #t #f)
    (cddadr 1 1 #t #f)
    (cdddar 1 1 #t #f)
    (cddddr 1 1 #t #f)
    (assq 2 2 #t #f)
    (assv 2 2 #t #f)
    (assoc 2 2 #t #f)
    (memq 2 2 #t #f)
    (memv 2 2 #t #f)
    (member 2 2 #t #f)
    (reverse 1 1 #t #f)
    (reverse! 1 1 #t #t)
    (list-tail 1 1 #t #f)
    (list-ref 2 2 #t #f)
    (append 2 2 #t #f)
    (append! 2 infinity #t #ft)
    (set-car! 2 2 #t #f)
    (set-cdr! 2 2 #t #f)
    (list 0 infinity #t #f)
    (length 1 1 #t #f)
    (pair-length 1 1 #t #f)
    (last 1 1 #t #f)
    (butlast 1 1 #t #f)
    (newline 0 1 #t #t)
    (display 1 2 #t #t)
    (write 1 2 #t #t)
    (write-char 1 1 #t #t)
    (null? 1 1 #t #f)
    (list? 1 1 #t #f)
    (pair? 1 1 #t #f)
    (atom? 1 1 #t #f)
    (eq? 1 infinity #t #f)
    (eqv? 1 infinity #t #f)
    (equal? 1 infinity #t #f)
    (boolean? 1 1 #t #f)
    (procedure? 1 1 #t #f)
    (number? 1 1 #t #f)
    (integer? 1 1 #t #f)
    (real? 1 1 #t #f)
    (rational? 1 1 #t #f)
    (complex? 1 1 #t #f)
    (exact? 1 1 #t #f)
    (inexact? 1 1 #t #f)
    (symbol? 1 1 #t #f)
    (string? 1 1 #t #f)
    (char? 1 1 #t #f)
    (bignum? 1 1 #t #f)
    (vector? 1 1 #t #f)
    (macro? 1 1 #t #f)
    (macro-name? 1 1 #t #f)
    (hygienic-name? 1 1 #t #f)
    (zero? 1 1 #t #f)
    (+ 0 infinity #t #f)
    (- 1 infinity #t #f)
    (* 0 infinity #t #f)
    (/ 1 infinity #t #f)
    (< 2 infinity #t #f)
    (<= 2 infinity #t #f)
    (> 2 infinity #t #f)
    (>= 2 infinity #t #f)
    (= 2 infinity #t #f)
    (sin 1 1 #t #f)
    (cos 1 1 #t #f)
    (tan 1 1 #t #f)
    (asin 1 1 #t #f)
    (acos 1 1 #t #f)
    (atan 1 2 #t #f)
    (log 1 1 #t #f)
    (exp 1 1 #t #f)
    (sqrt 1 1 #t #f)
    (expt 2 2 #t #f)
    (not 1 1 #t #f)
    (odd? 1 1 #t #f)
    (even? 1 1 #t #f)
    (floor 1 1 #t #f)
    (ceiling 1 1 #t #f)
    (truncate 1 1 #t #f)
    (round 1 1 #t #f)
    (numerator 1 1 #t #f)
    (denominator 1 1 #t #f)
    (positive? 1 1 #t #f)
    (negative? 1 1 #t #f)
    (abs 1 1 #t #f)
    (max 1 infinity #t #f)
    (min 1 infinity #t #f)
    (real-part 1 1 #t #f)
    (imag-part 1 1 #t #f)
    (magnitude 1 1 #t #f)
    (angle 1 1 #t #f)
    (make-rectangular 2 2 #t #f)
    (make-polar 2 2 #t #f)
    (exact->inexact 1 1 #t #f)
    (inexact->exact 1 1 #t #f)
    (remainder 2 2 #t #f)
    (modulo 2 2 #t #f)
    (quotient 2 2 #t #f)
    (gcd 0 2 #t #f)
    (lcm 0 2 #t #f)
    (char=? 2 2 #t #f)
    (char>? 2 2 #t #f)
    (char>=? 2 2 #t #f)
    (char<? 2 2 #t #f)
    (char<=? 2 2 #t #f)
    (char-ci=? 2 2 #t #f)
    (char-ci>? 2 2 #t #f)
    (char-ci>=? 2 2 #t #f)
    (char-ci<? 2 2 #t #f)
    (char-ci<=? 2 2 #t #f)
    (char-alphabetic? 1 1 #t #f)
    (char-numeric? 1 1 #t #f)
    (char-whitespace? 1 1 #t #f)
    (char-upper-case? 1 1 #t #f)
    (char-lower-case? 1 1 #t #f)
    (char->integer 1 1 #t #f)
    (integer->char 1 1 #t #f)
    (char-upcase 1 1 #t #f)
    (char-downcase 1 1 #t #f)
    (string-append 1 infinity #t #f)
    (number->string 1 2 #t #f)
    (string->number 1 2 #t #f)
    (string=? 1 1 #t #f)
    (string>? 1 1 #t #f)
    (string>=? 1 1 #t #f)
    (string<? 1 1 #t #f)
    (string<=? 1 1 #t #f)
    (string-ci=? 1 1 #t #f)
    (string-ci>? 1 1 #t #f)
    (string-ci>=? 1 1 #t #f)
    (string-ci<? 1 1 #t #f)
    (string-ci<=? 1 1 #t #f)
    (string->symbol 1 1 #t #f)
    (symbol->string 1 1 #t #f)
    (string-length 1 1 #t #f)
    (make-string 1 1 #t #f)
    (string 1 1 #t #f)
    (string-ref 2 2 #t #f)
    (string-set! 2 2 #t #t)
    (substring 1 1 #t #f)
    (string->list 1 1 #t #f)
    (list->string 1 1 #t #f)
    (string-copy 1 1 #t #f)
    (string-fill! 1 1 #t #t)
    (make-vector 2 2 #t #f)
    (vector-set! 3 3 #t #f)
    (vector 1 infinity #t #f)
    (vector-ref 2 2 #t #f)
    (vector-length 1 1 #t #f)
    (vector-fill! 2 2 #t #f)
    (vector->list 1 1 #t #f)
    (list->vector 1 1 #t #f)
    (read 0 1 #t #f)
    (load 1 1 #t #f)
    (open-input-file 1 1 #t #t)
    (open-output-file 1 1 #t #t)
    (close-input-port 1 1 #t #t)
    (close-output-port 1 1 #t #t)
    (eof-object? 1 1 #t #f)
    (input-port? 1 1 #t #f)
    (output-port? 1 1 #t #f)
    (current-input-port 1 1 #t #f)
    (current-output-port 1 1 #t #f)
    (read-char 1 1 #t #f)
    (peek-char 1 1 #t #f)
    (char-ready? 1 1 #t #f)
    (exit 0 0 #t #t)
    (gensym 0 1 #t #f)
    (apply 2 infinity #t #t)
    (primitive-name? 1 1 #t #f)
    (macroexpand-1 1 1 #t #f)
    (macroexpand 1 1 #t #f)
    (addr 1 1 #t #f)
    (entity-addr 1 1 #t #f)
    (undefined 0 0 #t #f)
    (step 1 1 #t #t)
    (vm2-step 1 1 #t #t)
    (vm1 1 1 #t #t)
    (vm2 1 1 #t #t)
    (dump 1 2 #t #t)
    (addr-prt 1 1 #t #t)
    (gbc 0 1 #t #t)
    (room 0 0 #t #f)
    (vmcode 1 1 #t #f)
    (env 1 1 #t #f)
    (timer-set 0 0 #t #t)
    (timer-get 0 0 #t #t)
    (timer-gbc 0 0 #t #t)
    (eval 1 1 #t #f)
    (load 1 1 #t #t)
    (error 2 infinity #t #t)
    (flush 0 1 #t #t)
    (set-trace 0 infinity #t #t)
    (set-untrace 0 infinity #t #t)
    (current-module 0 0 #t #f)
    (transfer 1 1 #t #f)
    (debug 1 1 #t #t)
    (profiler 1 1 #t #t)
    (lambda/asm 2 2 #t #f)
    (values 0 infinity #t #t)
    (sys-cont-room 1 1 #t #t)
    (make-syntactic-clousre 3 3 #t #t)
    (symbol->identifier 1 1 #t #f)
    (identifier->symbol 1 1 #t #f)
    (syntactic-closure? 1 1 #t #f)
    (identifier? 1 1 #t #f)
    (identifier-bind! 2 2 #t #t)
    (identifier-free? 1 1 #t #f)
    (identifier-bound? 1 1 #t #f)
    (identifier-bound 1 1 #t #f)
    (global-bound? 1 1 #t #f)
    (inspect 0 0 #t #t)
    (exact-integer? 1 1 #t #f)
    (file-exists? 1 1 #t #f)
    (system 1 1 #t #t)
    ))

;;ƒRƒ“ƒpƒCƒ‹
(define (compile-file x)
  (let* ((inf (string-append x ".scm"))
         (outf (string-append x ".o"))
         (inp (open-input-file inf))
         (outp (open-output-file outf)))
    (compile-file1 (read inp) inp outp)
    (close-input-port inp)
    (close-output-port outp)
    (display "compiled!")(flush)))

(define (compile-file1 sexp inp outp)
  (cond ((eof-object? sexp) #t)
        (else (write (assemble (compile sexp)) outp)
              (newline outp)
              (compile-file1 (read inp) inp outp))))



;;Œp‘±
(define ncall/cc 
  (lambda/asm 1 '((args 1) (catch) (lvar 0 0) (call 1) (return))))

;;‘½’l
(define call-with-values
  (lambda/asm 2 '((args 2) (lvar 0 0) (call 0) (adapt) (lvar 0 1) (call 0) (return))))

;;dynamic-wind 
;;Kent dybvig p93 QÆ
(define winders '())

(define (dynamic-wind before body after)
  (before)
  (set! winders (cons (cons before after) winders))
  (let ((ans (body)))
    (set! winders (cdr winders))
    (after)
    ans))


(define (common-tail x y)
  (reverse (common-tail1 (reverse x) (reverse y))))

(define (common-tail1 x y)
  (cond ((null? x) '())
        ((null? y) '())
        ((not (eq? (car x)(car y))) '())
        (else (cons (car x) (common-tail1 (cdr x) (cdr y))))))

(define (do-wind new)
  (let ((tail (common-tail new winders)))
    (do-wind-after winders tail)
    (do-wind-before (reverse new) (reverse tail))
    (set! winders new)))

(define (do-wind-after old tail)
  (if (equal? old tail)
      #t
      (begin
        ((cdar old))
        (do-wind-after (cdr old) tail))))

(define (do-wind-before new tail)
  (cond ((and (null? new) (null? tail)) #t)
        ((null? tail) ((caar new))(do-wind-before (cdr new) tail))
        (else (do-wind-before (cdr new) (cdr tail)))))

(define (call/cc f)
  (ncall/cc
    (lambda (k)
      (f (let ((save winders))
           (lambda x
             (if (not (eq? save winders))
                 (do-wind save)
                 (undefined))
             (apply k x)))))))


(define call-with-current-continuation call/cc)

;;Hygienic macro


(define (match x y lits)
  (match1 x y lits '()))

(define (match1 x y lits vars)
  (cond ((and (null? x) (null? y)) vars)
        ((ellipsis? x) (match1 (cddr x)
                               (list-take-right y (length (cddr x)))
                               lits
                               (cons (cons (car x) (list-take y (- (length y) (length (cddr x))))) vars)))
        ((and (null? x) (not (null? y))) #f)
        ((and (identifier? x) (null? y)) (list (cons x y)))
        ((and (not (null? x)) (null? y)) #f)
        ((and (atom? (car x)) (memq (car x) lits) (not (eq? (car x) (car y)))) #f)
        ((atom? (car x)) (match1 (cdr x) (cdr y) lits (cons (cons (car x)(car y)) vars)))
        ((and (vec-ellipsis? (car x))(vector? (car y))) 
         (match1 (cdr x) (cdr y) lits (cons (cons (vector-ref (car x) 0) (vector->list (car y))) vars)))
        ((and (ellipsises? x) (= (length (car x)) (length (transpose y))))
         (let ((r (transpose y))) (append (list (cons (caar x) (car r))
                                                (cons (cadar x) (cadr r))) vars)))
        (else (let ((r1 (match1 (car x) (car y) lits vars))
                    (r2 (match1 (cdr x) (cdr y) lits vars)))
                (if (and r1 r2)
                    (append r1 r2)
                    #f)))))



;;—á((1 2)(3 4)(5 6)) -> ((1 3 5)(2 4 6)) 
(define (transpose ls) 
  (define (iter m n) 
    (if (= m n) 
        '() 
        (cons (map (lambda (x) (list-ref x m)) ls) 
              (iter (+ m 1) n)))) 
  (iter 0 (length (car ls)))) 

;;È—ªq
(define (ellipsis? x)
  (and (list? x)
       (>= (length x) 2)
       (or (identifier? (car x)) (symbol? (car x)))
       (eqv? (cadr x) '...)))

;;•¡‡È—ªq
(define (ellipsises? x)
  (and (list x)
       (>= (length x) 2)
       (list? (car x))
       (eqv? (cadr x) '...)))

;;ƒxƒNƒ^È—ªq
(define (vec-ellipsis? x)
  (and (vector? x)
       (symbol? (vector-ref x 0))
       (eq? (vector-ref x 1) '...)))


(define (list-take ls n)
  (if (= n 0)
      '()
      (cons (car ls) (list-take (cdr ls) (- n 1)))))

(define (list-take-right ls n)
  (list-drop ls (- (length ls) n)))

(define (list-drop ls n)
  (if (= n 0)
      ls
      (list-drop (cdr ls) (- n 1))))


(define (fail? x)
  (eq? x 'fail))

(define (subst-to-identifier x env)
  (cond ((null? x) '())
        ((and (symbol? x)
              (or (local-bound? x env) (global-bound? x) (eq? x 'else)))
         (identifier-bind! (symbol->identifier x) x))
        ((symbol? x)
         (symbol->identifier x))
        ((atom? x) x)
        ((vector? x) x)
        (else (cons (subst-to-identifier (car x) env)
                    (subst-to-identifier (cdr x) env)))))

(define (local-bound? x env)
  (cond ((null? env) #f)
        ((member x (car env)) #t)
        (else (local-bound? x (cdr env)))))

(define (subst-pattern-vars x pat)
  (cond ((null? x) '())
        ((and (identifier? x)(assv x pat))
         (identifier-bind! x (cdr (assv x pat))))
        ((atom? x) x)
        ((vector? x) x)
        (else (cons (subst-pattern-vars (car x) pat)
                    (subst-pattern-vars (cdr x) pat)))))



(define (subst-let-vars x)
  (subst-let-vars1 x (scan-let-vars x '())))

(define (subst-let-vars1 x a-list)
  (cond ((null? x) '())
        ((and (identifier? x)(identifier-free? x)(assv x a-list))
         (identifier-bind! x (cdr (assv x a-list))))
        ((atom? x) x)
        ((vector? x) x)
        (else (cons (subst-let-vars1 (car x) a-list)
                    (subst-let-vars1 (cdr x) a-list)))))


(define (scan-let-vars x v-list)
  (cond ((null? x) (map (lambda (x) (cons x (gensym))) v-list))
        ((atom? x) '())
        ((and (lambda? x)(atom? (cadr x)))
         (scan-let-vars (cddr x) (cons (cadr x) v-list)))
        ((and (lambda? x)(list? (cadr x))(not (null? (cadr x))))
         (scan-let-vars (cddr x) (append (cadr x) v-list)))
        ((and (lambda? x)(pair? (cadr x))(not (null? (cadr x))))
         (scan-let-vars (caddr x) (pair->list (cadr x))))
        ((and (let? x)(not (null? (cadr x)))) (scan-let-vars (cddr x) (car (transpose (cadr x)))))
        ((and (let*? x)(not (null? (cadr x)))) (scan-let-vars (cddr x) (car (transpose (cadr x)))))
        ((and (letrec? x)(not (null? (cadr x)))) (scan-let-vars (cddr x) (car (transpose (cadr x)))))
        ((and (named-let? x)(not (null? (caddr x))))
         (scan-let-vars (cdddr x) 
                        (append (car (transpose (caddr x))) 
                                (cons (cadr x) v-list))))
        (else (scan-let-vars (cdr x) v-list))))

(define (lambda? x)
  (and (list? x) (>= (length x) 3) (eqv? (car x) 'lambda)))

(define (let? x)
  (and (list? x) (>= (length x) 3) (eqv? (car x) 'let) (not (identifier? (cadr x)))))

(define (named-let? x)
  (and (list? x) (>= (length x) 4) (eqv? (car x) 'let) (identifier? (cadr x))))

(define (letrec? x)
  (and (list? x) (>= (length x) 3) (eqv? (car x) 'letrec)))

(define (let*? x)
  (and (list? x) (>= (length x) 3) (eqv? (car x) 'let*)))


(define (subst-from-identifier x)
  (cond ((null? x) '())
        ((identifier-free? x) x)
        ((identifier? x) (identifier-bound x))
        ((atom? x) x)
        ((vector? x) x)
        ((and (= (length x) 2)(ellipsis? x))
         (identifier-bound (car x)))
        ;;(x ...)
        ((and (> (length x) 2)(ellipsis? (list-take x 2)))
         (append (identifier-bound (car x))
                 (subst-from-identifier (cddr x))))
        ;;ex(x ... n)
        (else (cons (subst-from-identifier (car x))
                    (subst-from-identifier (cdr x))))))




(define (expand-template x vars comp-env)
  (subst-from-identifier
    (subst-let-vars
      (subst-pattern-vars
        (subst-to-identifier x comp-env)
        vars))))


(define (expand x y lits comp-env)
  (let* ((pat (caar x))
         (temp (cadar x))
         (vars (match pat y lits)))
    (cond (vars (expand-template temp vars comp-env))
          ((null? (cdr x)) (error "syntax-rules fail " y))
          (else (expand (cdr x) y lits comp-env)))))


;;Normal macros
;;Scheme macros written by M.hiroi modified for Normal by k.sasagawa
;;cond‚È‚Ç‚Ì§Œä\‘¢‚Íƒ}ƒNƒ‚Å—^‚¦‚ç‚ê‚éB
;;M.Hiroi‚³‚ñ‚Ìmicro Scheme‚Ì‚à‚Ì‚ğg‚í‚¹‚Ä‚¢‚½‚¾‚¢‚Ä‚¢‚Ü‚·B
;;Normal‚Ì‹N“®‚É“Ç‚İ‚Ü‚êƒRƒ“ƒpƒCƒ‹‚³‚ê‚éB

(define map 
  (lambda (f ls . more)
    ((lambda (map1 map-more)
       (set! map1 (lambda (ls)
                    (if (null? ls) 
                        (quote ()) 
                        (cons (f (car ls))
                              (map1 (cdr ls))))))
       (set! map-more (lambda (ls more)
                        (if (null? ls)
                            (quote ()) 
                            (cons (apply f (car ls) (map car more))
                                  (map-more (cdr ls) (map cdr more))))))
       (if (null? more)
           (map1 ls)
           (map-more ls more)))
      (undefined) (undefined))))

(define-macro and
  (lambda args
    (if (null? args)
        #t
        (if (null? (cdr args))
            (car args)
            `(if ,(car args) (and ,@(cdr args)) #f)))))

(define-macro or
  (lambda args
    (if (null? args)
        #f
        (if (null? (cdr args))
            (car args)
            `(if ,(car args) ,(car args) (or ,@(cdr args)))))))


(define-macro let
  (lambda (args . body)
    (if (null? args)
        `((lambda () ,@body))
        (if (pair? args)
            `((lambda ,(map car args) ,@body) ,@(map cadr args))
            ; named-let
            `(letrec ((,args (lambda ,(map car (car body)) ,@(cdr body))))
               (,args ,@(map cadr (car body))))))))


(define-macro let*
  (lambda (args . body)
    (if (null? args)
        `((lambda () ,@body))
        (if (null? (cdr args))
            `(let (,(car args)) ,@body)
            `(let (,(car args)) (let* ,(cdr args) ,@body))))))

(define-macro letrec
  (lambda (args . body)
    (let ((vars (map car args))
          (vals (map cadr args)))
      `(let ,(map (lambda (x) `(,x '*undef*)) vars)
            ,@(map (lambda (x y) `(set! ,x ,y)) vars vals)
            ,@body))))

(define-macro cond
  (lambda args
    (if (null? args)
        `(undefined)
        (if (null? (cdar args))
            `(let ((*val* ,(caar args)))
               (if *val* *val* (cond ,@(cdr args))))
            (if (eq? (cadar args) '=>)
            `(let ((*val* ,(caar args)))
               (if *val* (,(caddar args) *val*)))
                (if (eqv? (caar args) 'else)
                    (if (length=1? (cdar args))
                        (cadar args)
                        `(begin ,@(cdar args)))
                    (if (length=1? (cdar args))
                        `(if ,(caar args)
                           ,@(cdar args)
                           (cond ,@(cdr args)))
                        `(if ,(caar args)
                           (begin ,@(cdar args))
                           (cond ,@(cdr args))))))))))

(define-macro case
  (lambda (key . args)
    (if (null? args)
        `(undefined)
        (if (eq? (caar args) 'else)
            `(begin ,@(cdar args))
            `(if (memv ,key ',(caar args))
                 (begin ,@(cdar args))
                 (case ,key ,@(cdr args)))))))


(define-macro do
  (lambda (var-form test-form . args)
    (let ((vars (map car var-form))
          (vals (map cadr var-form))
          (step (map cddr var-form)))
      `(letrec ((loop (lambda ,vars
                        (if ,(car test-form)
                            (begin ,@(cdr test-form))
                          (begin
                            ,@args
                            (loop ,@(map (lambda (x y)
                                             (if (null? x) y (car x)))
                                           step
                                           vars)))))))
        (loop ,@vals)))))


;;kent dyvig p89
(define for-each
  (lambda (f ls . more)
    (do ((ls ls (cdr ls)) (more more (map cdr more)))
        ((null? ls))
        (apply f (car ls) (map car more)))
    (undefined)));;Normal test
;;R5RS
(import (normal test))
(import (scheme inexact))

;;“™‰¿
(test* "(eqv? 'a 'a)" #t (eqv? 'a 'a))
(test* "(eqv? 'a 'b)" #f (eqv? 'a 'b))
(test* "(eqv? 2 2)" #t (eqv? 2 2))
(test* "(eqv? '() '())" #t (eqv? '() '()))
(test* "(eqv? 100000000 100000000)" #t (eqv? 100000000 100000000))
(test* "(eqv? (cons 1 2) (cons 1 2))" #f (eqv? (cons 1 2) (cons 1 2)))
(test* "(eqv? (lambda () 1) (lambda () 2))" #f (eqv? (lambda () 1) (lambda () 2)))
(test* "(eqv? #f 'nil)" #f (eqv? #f 'nil))
(test* "(eqv? #\c #\c)" #t (eqv? #\c #\c))
(test* "(equal? 'a 'b)" #f (equal? 'a 'b))
(test* "(equal? 'a 'a)" #t (equal? 'a 'a))
(test* "(equal? '(1 2) '(1 2))" #t (equal? '(1 2) '(1 2)))
(test* "(equal? '(1) '(1 2))" #f (equal? '(1) '(1 2)))

;;”’l
(test* "(complex? 3+4i)" #t (complex? 3+4i))
(test* "(complex? 3)" #t (complex? 3))
(test* "(real? 3)" #t (real? 3))
(test* "(real? -2.5+0.0i)" #t (real? -2.5+0.0i))
(test* "(rational? 6/10)" #t (rational? 6/10))
(test* "(rational? 6/3)" #t (rational? 6/3))
(test* "(integer? 3+0i)" #t (integer? 3+0i))
(test* "(integer? 3.0)" #t (integer? 3.0))
(test* "(integer? 8/4)" #t (integer? 8/4))

(test* "(< 1 2 3)" #t (< 1 2 3))

(test* "(exact? 1)" #t (exact? 1))
(test* "(exact? 1234567890)" #t (exact? 1234567890))

(test* "(zero? 0)" #t (zero? 0))
(test* "(zero? 0.0)" #t (zero? 0))
(test* "(zero? 0+0i)" #t (zero? 0+0i))
(test* "(zero? 0+3i)" #f (zero? 0+3i))
(test* "(positive? 0)" #f (positive? 0))
(test* "(positive? 0.1)" #t (positive? 0.1))
(test* "(positive? 2/3)" #t (positive? 2/3))
(test* "(negative? 0)" #f (negative? 0))
(test* "(negative? -1)" #t (negative? -1))
(test* "(odd? -1)" #t (odd? -1))
(test* "(odd? -2)" #f (odd? -2))
(test* "(odd? 12345678901)" #t (odd? 12345678901))
(test* "(max 3 4)" 4 (max 3 4))
(test* "(max 3.9 4)" 4.0 (max 3.9 4))
(test* "(+ 3 4)" 7 (+ 3 4))
(test* "(+ 3)" 3 (+ 3))
(test* "(+)" 0 (+))
(test* "(* 4)" 4 (* 4))
(test* "(*)" 1 (*))
(test* "(modulo 13 4)" 1 (modulo 13 4))
(test* "(remainder 13 4)" 1 (remainder 13 4))
(test* "(modulo -13 4)" 3 (modulo -13 4))
(test* "(remainder -13 4)" -1 (remainder -13 4))
(test* "(modulo 13 -4)" -3 (modulo 13 -4))
(test* "(remainder 13 -4)" 1 (remainder 13 -4))
(test* "(modulo -13 -4)" -1 (modulo -13 -4))





;;^‹U’l
(test* "(not #t)" #f (not #t))
(test* "(not 3)" #f (not 3))


;;§Œä‹@”\
(test* "(procedure? car)" #t (procedure? car))
(test* "(procedure? 'car)" #f (procedure? 'car))
(test* "(procedure? (lambda (x) (* x x)))" #t (procedure? (lambda (x) (* x x))))
(test* "(call/cc procedure?)" #t (call/cc procedure?))
(test* "(apply + (list 3 4))" 7 (apply + (list 3 4)))

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

(test* "((compose sqrt *) 12 75)" 30 ((compose sqrt *) 12 75))
(test* "(map cadr '((a b) (d e) (g h)))" '(b e h) (map cadr '((a b) (d e) (g h))))
(test* "(map (lambda (n) (expt n n)) '(1 2 3 4 5))" '(1 4 27 256 3125) (map (lambda (n) (expt n n)) '(1 2 3 4 5)))
(test* "(map + '(1 2 3) '(4 5 6))" '(5 7 9) (map + '(1 2 3) '(4 5 6)))
;;; 

;;ƒŠƒXƒg
;;(test* "list" '(a b c . d) '(a . (b . (c . d))))

(define x (list 'a 'b 'c))
(define y x)

(test* "y" '(a b c) y)
(test* "(list? y)" #t (list? y))
(set-cdr! x 4)
(test* "x" '(a . 4) x)
(test* "eqv? x y" #t (eqv? x y))


(test* "(pair? '(a . b))" #t (pair? '(a . b)))
(test* "(pair? '(a b c))" #t (pair? '(a b c)))
(test* "(pair? '())" #f (pair? '()))

(test* "(memq 'a '(a b c))" '(a b c) (memq 'a '(a b c)))
(test* "(memq 'b '(a b c))" '(b c) (memq 'b '(a b c)))
(test* "(memq 'a '(b c d))" #f (memq 'a '(b c d)))
(test* "(memq (list 'a) '(b (a) c))" #f (memq (list 'a) '(b (a) c)))
(test* "(member (list 'a) '(b (a) c))" '((a) c) (member (list 'a) '(b (a) c)))
(test* "(memq 101 '(100 101 102))" '(101 102) (memq 101 '(100 101 102)))
(test* "(memv 101 '(100 101 102))" '(101 102) (memv 101 '(100 101 102)))

(define e '((a 1)(b 2)(c 3)))
(test* "(assq 'a e)" '(a 1) (assq 'a e))

MZ       ÿÿ  ¸       @                                   €   º ´	Í!¸LÍ!This program cannot be run in DOS mode.
$       PE  L ®ŠQ ˆ ï  à  ^     Îèjl      p   @                      íj   __                                 ğëj                                                           ìj                   ¤ñëjT                          .text   °\     ^                ` 0`.data   P   p     d             @ `À.rdata  0,   €  .   h             @ `@/4      H`   °  b   –             @ 0@.bss    pÌèj                       € `À.idata     ğëj 
   ø             @ 0À.CRT         ìj                 @ 0À.tls         ìj                 @ 0À/14     `    ìj                 @ B/29     Ù   0ìj    
             @ B/45     A   @ìj                 @ B/61     Ñ2   Pìj 4                @ B/73     ¬   ìj    J             @ B/87         ìj    X             @ B/99        °ìj    f             @ 0B/112       Àìj    n             @ B/123    J   Ğìj    p             @ B/134    °    ğìj    †             @ B                                                                                                                                                                                                                                                                                                                                                                                                                                                        U‰åSƒì4¡4«B …ÀtÇD$    ÇD$   Ç$    ÿĞƒìÇ$@ èS Pèê> èÅ? ÇEğ    Eğ‰D$¡@sB ‰D$Eô‰D$ÇD$ C Ç$  C èóP ¡p C …ÀuJèíP ‹DsB ‰è°@ ƒäğèğB èÛP ‹ ‰D$¡ C ‰D$¡  C ‰$è‡V ‰ÃèÀP ‰$èˆR £DsB ‰D$‹ò+k‹C‰$è¦P ¡p C ‰D$‹C0‰$è’P ¡p C ‰D$‹CP‰$è~P éoÿÿÿU‰åSƒì‹E‹ ‹ =‘  Àw;=  ÀrL»   ÇD$    Ç$   èKP ƒø„í   …À…š   1ÀƒÄ[ÉÂ =”  ÀtM=–  Àt=“  Àuáëµ=  Àt==  ÀuĞÇD$    Ç$   èöO ƒøtd…Àt³Ç$   ÿĞ¸ÿÿÿÿë¥1ÛévÿÿÿÇD$    Ç$   èÀO ƒøtJ…À„yÿÿÿÇ$   ÿĞ¸ÿÿÿÿéhÿÿÿÇ$   ÿĞ¸ÿÿÿÿéUÿÿÿÇD$   Ç$   èyO ƒÈÿé9ÿÿÿÇD$   Ç$   è]O ƒÈÿéÿÿÿÇD$   Ç$   èAO …Ûu
¸ÿÿÿÿéûşÿÿè¦= ƒÈÿéîşÿÿfU‰åƒìÇ$   ÿüñ+kè|ıÿÿU‰åƒìÇ$   ÿüñ+kèdıÿÿU‰åƒì¡Dò+kÉÿàfU‰åƒì¡ò+kÉÿàU‰åƒìÇ$ €B èŠP R…ÀteÇD$€B ‰$è}P ƒì…ÀtÇD$ C Ç$ °B ÿĞ‹LsB …Ét1Ç$)€B èGP R…Àt*ÇD$7€B ‰$è:P ƒì…Àt	Ç$LsB ÿĞÉÃ¸    ë§¸    ëâU‰åƒìÇ$ €B èşO Q…Àt%ÇD$K€B ‰$èñO ƒì…Àt	Ç$ °B ÿĞÉÃv ¸    ëç‹D$…ÀuÇD C    ¸   Â fHt1ÀÂ ÇD C    ¸   Â f¡ -)@H£ -)@‹… úDÃVS‹\$‹5 -)@…Û~‰Ø‰ò)ÚÁâv ‹Œ‚üúD‰Œ‚úDHuï‰ğ)Ø‹T$‰… úD‹T$‰…úDƒÆ‰5 -)@[^ÃUWVSƒì,‹\$@‰$èò  ‰$èÕç  ‰Å1ö‰ÇÁç‰$è” …Àu?‰$è”í  ‰$èøê  ƒø(wÿ$…€€B ‹—`ğ// normal header

#include <stdio.h>
#include <windows.h>
#include <time.h>

#define CELLSIZE 	20000000
#define FREESIZE	50000
#define SYMSIZE		64
#define CHARSIZE	1
#define BUFSIZE 	256
#define CODESIZE	80000000
#define	STACKSIZE	200000
#define ENVSIZE		80000000
#define ENVSIZE2	ENVSIZE / 10
#define CLOSIZE		10000000
#define NIL			0
#define BOOLT		1
#define BOOLF		2
#define BIGNUM_BASE	1000000000
#define HASHTBSIZE	100
#define MODULESIZE	100
#define TRACE_DEPTH	10
#define INT_FLAG	1073741824 //#b1000000000000000000000000000000
#define INT_MASK	1073741823 //#b0111111111111111111111111111111
#define SMALL_INT_MAX		1000000000
#define SMALL_INT_MIN		-1000000000
		

//ƒ|ƒCƒ“ƒ^
int cell_heap_p;
int cell_free;
int cell_hash_table[HASHTBSIZE][MODULESIZE];
int dyna_env_p1;
int dyna_env_p2;

typedef enum tag 	{EMP,BIGBANG,INTN,FLTN,COMP,BIG,RAT,SYM,LIS,VEC,ELT,BOL,STR,CHR,SUBR,SYNT,
					CLOS,HCONT,SCONT,MAC,MUL,PRT,EOFO,IDNT,SYNCLO,HYG,CODE,STACK,ENV,MEM,REF,EMPSET} tag;
typedef enum flag 	{FRE,USE} flag;

/*
BIGBANG	‹•–³ ‹óƒŠƒXƒg‚ğ•\‚·Bí‚É0”Ô’n‚É—Bˆê‘¶İ‚·‚éB
EMP		‹óƒZƒ‹
INTN	®”
FLTN	•‚“®¬”“_”
COMP	•¡‘f”
BIG		‘½”{’·®”
RAT		•ª”
SYM		ƒVƒ“ƒ{ƒ‹
LIS		ƒŠƒXƒg
VEC		ƒxƒNƒ^[
ELT		ƒxƒNƒ^[‚Ì—v‘f
BOL		^‹U’l
STR		•¶š—ñ
CHR		•¶š
SUBR	‘gŠÖ”
SYNT	“ÁêŒ`®
CLOS	ƒNƒ[ƒWƒƒ[
SCONT	ƒXƒ^ƒbƒNã‚ÌŒp‘±
HCONT   ƒq[ƒvã‚ÌŒp‘±
MAC		ƒ}ƒNƒ
HYG		hygienic-macro
MUL		‘½’l
PRT		ƒ|[ƒg
EOFO	end_of_file obj
VEC		ƒxƒNƒ^
IDNT	¯•Êqidentifier
SYNCLO	syntactic-closure
ENV		”z—ñŒ^‚Ì‹ÇŠŠÂ‹«
CODE    ”z—ñŒ^‚Ì–½—ß—ñ
STACK   ”z—ñŒ^‚ÌƒXƒ^ƒbƒN
MEM		Œp‘±—p‚Ìƒƒ‚ƒŠ•Û‘¶ƒf[ƒ^
REF		Prolog•Ï”
EMPSET  ‹óW‡
*/


struct cell {
	union{
    	double fltnum;
        struct {
        	union{
            	int intnum;
                int 	( *subr) ();
                FILE	*port;
                int		*dyna_vec;
            } car;
            union{
            	int intnum;
            } cdr;
        };
    } val;
    int		aux;
	tag		tag;
    flag	flag;
	char 	*name;
    char 	args_cnt;
};
typedef struct cell cell;

//ƒvƒƒtƒ@ƒCƒ‹‚Ìƒf[ƒ^’~Ï—p
struct prof{
	char 	*name;
    int 	count;
    clock_t time;
};
typedef struct prof prof;


typedef enum toktype 	{LPAREN,RPAREN,LBRAKET,RBRAKET,QUOTE,QUASIQUOTE,UNQUOTE,SPLICING,VECTOR,
						DOT,INTEGER,FLOAT_N,RATIONAL,BIGNUM,BINARY,OCTAL,DECNUM,HEXNUM,EXPTNUM,
                        COMPLEX,SYMBOL,SBOOL,STRING,
                        CHARACTER,FILEEND,OTHER} toktype;
typedef enum backtrack 	{GO,BACK} backtrack;
typedef enum exactness	{YES,NO} exactness;
typedef enum comptype	{RECTANGLER,POLAR} comptype;

struct token {
	char ch;
    backtrack flag;
	toktype type;
    exactness exact;
    comptype ctype;
    char buf[BUFSIZE];
    char before[BUFSIZE];
    char after[BUFSIZE];
};

struct septoken {
	char sepch;
    char before[BUFSIZE];
    char after[BUFSIZE];
};

typedef struct token token;
typedef struct septoken septoken;

//ƒGƒ‰[ƒR[ƒh
#define UNBOUND_VARIABLE	1
#define CANT_READ			2
#define ILLEGAL_ARGUMENT	3
#define CANT_OPEN			4
#define LACK_CELL			6
#define LACK_VEC			7
#define VM_ILLEGAL_CODE		8
#define INVALID_SYNTAX		9
#define INVALID_APP			10
#define NOT_PAIR			11
#define NOT_SYMBOL			12
#define NOT_NUMBER			13
#define NOT_REAL			14
#define NOT_INTEGER			15
#define NOT_FLOAT			16
#define NOT_RATIONAL		17
#define NOT_COMPLEX			18
#define NOT_CHAR			19
#define NOT_STRING			20
#define NOT_VECTOR			21
#define NOT_MULTIVAL		22
#define NOT_MACRO			23
#define NOT_PORT			24
#define NOT_PROCEDURE		25
#define NOT_CLOSURE			26
#define NOT_LIST			27
#define NOT_BOOL			28
#define NOT_IDENTIFIER		29
#define INCORRECT_ARG_CNT	30
#define DIVIDE_ZERO			31
#define TOO_BIG				32
#define NOT_HYGIENIC		33
#define NOT_SYNTACTIC		34
#define EXTRA_PAREN			35
#define STACK_OVERF			36
#define CODE_OVERF			37
#define NOT_MODULE			38
#define MODULE_OVERF		39
#define CLOSURE_OVERF		40
#define NOT_EXACT			41
#define ILLEGAL_VMCODE		42
#define MALLOC_OVERF		43
#define NOT_EXIST_LIB		44

#define EOL		'\n'
#define RET		'\r'
#define TAB		'\t'
#define SPACE	' '
#define ESCAPE	033
#define NUL		'\0'

int quote,quasiquote,unquote,unquote_splicing,undef,end_of_file,empty_set;


#define GET_TAG(addr)		get_tag(addr)
#define GET_INT(addr)		addr_to_int(addr)
#define IS_INTEGER(addr)	(INT_FLAG & addr)
#define GET_INT_ADDR(n)		(INT_FALG | n)
#define GET_AUX(addr)		memory[addr].aux
#define SET_AUX(addr,x)		memory[addr].aux = x

#define GET_FLAG(addr)		memory[addr].flag
#define GET_NAME(addr)		memory[addr].name
#define GET_CHAR(addr)		memory[addr].name[0] 
#define GET_FLT(addr)		memory[addr].val.fltnum
#define GET_CAR(addr)		memory[addr].val.car.intnum
#define	GET_CDR(addr)		memory[addr].val.cdr.intnum
#define GET_SUBR(addr)		memory[addr].val.car.subr
#define GET_REAL_FLT(addr)	GET_FLT(memory[addr].val.car.intnum)
#define GET_IMAG_FLT(addr)	GET_FLT(memory[addr].val.cdr.intnum)
#define GET_PORT(addr)		memory[addr].val.car.port
#define GET_ARGS_CNT(addr)	memory[addr].args_cnt
#define STRING_REF(addr,k)	memory[addr].name[k]
#define STRING_SET(addr,k,c)	memory[addr].name[k] = c
#define SET_TAG(addr,x)		memory[addr].tag = x
#define SET_FLAG_FREE(addr)	memory[addr].flag = FRE
#define SET_FLAG_USE(addr)	memory[addr].flag = USE
#define SET_NAME(addr,x)	memory[addr].name = (char *)malloc(SYMSIZE); strcpy(memory[addr].name,x);
#define SET_CHAR(addr,x)	memory[addr].name = (char *)malloc(CHARSIZE); memory[addr].name[0] = x; memory[addr].name[1] = NUL;
#define SET_FLT(addr,x) 	memory[addr].val.fltnum = x
#define SET_REAL_FLT(addr,x) 	memory[addr].val.car.intnum = make_flt(x)
#define SET_IMAG_FLT(addr,x) 	memory[addr].val.cdr.intnum = make_flt(x)
#define SET_CAR(addr,x)		memory[addr].val.car.intnum = x
#define SET_CDR(addr,x)		memory[addr].val.cdr.intnum = x
#define SET_SUBR(addr,x)	memory[addr].val.car.subr = (int (*)())x
#define SET_PORT(addr,x)	memory[addr].val.car.port = x
#define SET_ARGS_CNT(addr,x)	memory[addr].args_cnt = x
#define IS_EMPTY(addr)		memory[addr].tag	== EMP
#define IS_FREE(addr)		memory[addr].flag == FRE
#define IS_USE(addr)		memory[addr].flag == USE	
#define IS_SYMBOL(addr)		memory[addr].tag == SYM
#define IS_STRING(addr)		memory[addr].tag == STR
#define IS_FLOAT(addr)		memory[addr].tag == FLTN
#define IS_RATIONAL(addr)	memory[addr].tag == RAT
#define IS_BIGNUM(addr)		memory[addr].tag == BIG
#define IS_COMPLEX(addr)	memory[addr].tag == COMP
#define IS_LIST(addr)		memory[addr].tag == LIS
#define IS_VECTOR(addr)		memory[addr].tag == VEC
#define IS_NIL(addr)		memory[addr].tag == BIGBANG
#define IS_SUBR(addr)		memory[addr].tag == SUBR
#define IS_CHARACTER(addr)	memory[addr].tag == CHR
#define IS_CLOSURE(addr)	memory[addr].tag == CLOS
#define IS_CONT(addr)		memory[addr].tag == HCONT
#define IS_MACRO(addr)		memory[addr].tag == MAC
#define IS_HYGIENIC(addr)	memory[addr].tag == HYG
#define IS_BOOL(addr)		memory[addr].tag == BOL
#define IS_T(addr)			memory[addr].tag == BOL && HAS_NAME(addr,"#t")
#define IS_F(addr)			memory[addr].tag == BOL && HAS_NAME(addr,"#f")
#define IS_MULTVAL(addr)	memory[addr].tag == MUL
#define IS_SAME_TYPE(x,y)	memory[x].tag == memory[y].tag
#define IS_IDENTIFIER(addr)	memory[addr].tag == IDNT
#define IS_SYNCLO(addr)		memory[addr].tag == SYNCLO
#define IS_ENV(addr)		memory[addr].tag == ENV
#define IS_CODE(addr)		memory[addr].tag == CODE
#define HAS_NAME(addr,x)	strcmp(memory[addr].name,x) == 0
#define SAME_NAME(addr1,addr2) strcmp(memory[addr1].name, memory[addr2].name) == 0
#define GREATER_NAME(addr1,addr2) strcmp(memory[addr1].name, memory[addr2].name) > 0
#define SMALLER_NAME(addr1,addr2) strcmp(memory[addr1].name, memory[addr2].name) < 0
#define EQUAL_STR(x,y)		strcmp(x,y) == 0
#define DEBUG				printf("debug\n"); longjmp(toplevel,1);
#define POPC(x)				x = GET_CAR(C); C = GET_CDR(C)
#define PUSHS(x)			S = cons(x,S)
#define GET_INT_CAR(x)		memory[memory[x].car.car].car.intnum
#define GET_INT_CDR(x)		memory[memory[x].cdr.cdr].car.intnum


#define GET_VEC_ELT(addr,i)			memory[addr].val.car.dyna_vec[i]
#define SET_VEC_ELT(addr,i,x)		memory[addr].val.car.dyna_vec[i] = x
#define SET_VEC(addr,x)				memory[addr].val.car.dyna_vec = x

#define GET_ENV_MAT_ELT(addr,i,j)	emem1[memory[addr].val.car.intnum + 1 + (i)*(memory[addr].aux) + (j)]
#define SET_ENV_MAT_ELT(addr,i,j,x)	emem1[memory[addr].val.car.intnum + 1 + (i)*(memory[addr].aux) + (j)] = (x)
#define GET_ENV_ORG(addr)			emem1[memory[addr].val.car.intnum]
#define SET_ENV_ORG(addr,x)			emem1[memory[addr].val.car.intnum] = x
#define GET_ENV_VEC_ELT(addr,i)		emem1[memory[addr].val.car.intnum + 1 + (i)]
#define SET_ENV_VEC_ELT(addr,i,x)	emem1[memory[addr].val.car.intnum + 1 + (i)] = (x)

#define ARG1					code[pc+1]
#define ARG2					code[pc+2]
#define ARG3					code[pc+3]
#define PUSH_S(x)				stack[sp++] = x
#define POP_S					stack[--sp]
#define TOP_STACK				stack[sp-1]
#define SECOND_STACK			stack[sp-2]
#define THIRD_STACK				stack[sp-3]

#define OPCODE 41
#define VM_ERR_CHK				if(code[pc] < 1 || code[pc] >= OPCODE) exception("vm2", ILLEGAL_VMCODE, NIL)

//main.c
int eval(int x);
void exception(char *fn, int code, int arg);
BOOL WINAPI CtrlHandler(DWORD CtrlEvent);
int vm1(void);
int vm2(void);
void print(int x);
int read(void);
int readlist(void);
void push_s(int x);
int pop_s(void);
void insert_stack(int env, int pc, int n);
int find_code_pointer(int addr);
void step(void);
int disasm(int addr);
int stack_to_list(int n);
void push_back_trace(int proc, int args);
void list_to_code(int x);
int list_to_code_obj(int lis);
int count_stack(void);
void check_ctrl(void);
int issymch(char c);
void gettoken(void);
septoken separater(char buf[], char sep);
void insertstr(char ch, char buf[]);
int laststr(char buf[]);
void dropchar(char buf[]);
int inttoken(char buf[]);
int exact_inttoken(char buf[]);
int inexact_inttoken(char buf[]);
int inttoken_nsgn(char buf[]);
int bignumtoken(char buf[]);
int exact_bignumtoken(char buf[]);
int inexact_bignumtoken(char buf[]);
int rattoken(char buf[]);
int exact_rattoken(char buf[]);
int inexact_rattoken(char buf[]);
int bintoken(char buf[]);
int flttoken(char buf[]);
int exact_flttoken(char buf[]);
int inexact_flttoken(char buf[]);
int comptoken(char buf[]);
int polar_comptoken(char buf[]);
int octtoken(char buf[]);
int dectoken(char buf[]);
int hextoken(char buf[]);
int expttoken(char buf[]);
int symtoken(char buf[]);
int booltoken(char buf[]);
int charcmp(char buf[], char cmp[]);
int define_to_letrec(int lis);
int definep(int x);
int replace(int lis);
int replace1(int lis);
int replace2(int lis);
int replace3(int lis, int def);
int formal_define(int lis);
int quasi_to_procedure(int lis);
int transfer(int lis, int n);
int uq_transfer(int lis, int n);
int uq_transfer1(int lis, int n);
int uqs_transfer(int lis, int n);
int uqs_transfer1(int lis, int n);
void printflt(double x);
void printbig(int x);
void printlist1(int x);
void printlist(int x);
void printvec(int x);
void memorydump(int start, int end);
void gbc(void);
void markcell(int addr);
void gbcmark(void);
void gbcsweep(void);
void clrcell(int addr);
int ealloc(int n);
int dyna_env_cpy(int p, int n);

//list.c
int car(int lis);
int cdr(int lis);
int scm_car(int lis);
int scm_cdr(int lis);
int caar(int lis);
int cdar(int lis);
int cadar(int lis);
int cddr(int lis);
int cdddr(int lis);
int cdadr(int lis);
int cadr(int lis);
int caddr(int lis);
int caadr(int lis);
int cadddr(int lis);
int cons(int car, int cdr);
int assq(int obj, int lis);
int assv(int obj, int lis);
int assoc(int obj, int lis);
int memq(int obj, int lis);
int memv(int obj, int lis);
int member(int obj, int lis);
int listtail(int lis, int n);
int listref(int lis, int n);
int drop(int lis, int n);
int length(int lis);
int list(int arglist);
int list1(int x);
int list2(int x, int y);
int list3(int x, int y, int z);
int list4(int x1, int x2, int x3, int x4);
int list5(int x1, int x2, int x3, int x4, int x5);
int list6(int x1, int x2, int x3, int x4, int x5, int x6);
int list7(int x1, int x2, int x3, int x4, int x5, int x6, int x7);
int list8(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8);
int listcopy(int lis);
int reverse(int lis);
int reverse2(int lis);
int	last(int lis);
int butlast(int lis);
int atomp(int x);
int integerp(int x);
int mathematical_integerp(int x);
int positivep(int x);
int negativep(int x);
int exactp(int x);
int inexactp(int x);
int bignump(int x);
int floatp(int x);
int numberp(int x);
int realp(int x);
int rationalp(int x);
int complexp(int x);
int symbolp(int x);
int listp(int x);
int stringp(int x);
int charp(int x);
int improperp(int x);
int pairp(int x);
int nullp(int x);
int booleanp(int x);
int procedurep(int x);
int multvalp(int x);
int vectorp(int x);
int identifierp(int x);
int syntactic_closurep(int x);
int equalp(int x1, int x2);
int subrp(int x);
int closurep(int x);
int continuationp(int x);
int macro_namep(int sym);
int hygienic_namep(int sym);
int macrop(int x);
int setcar(int x, int y);
int setcdr(int x, int y);
int append(int x, int y);
int append2(int x, int y);

//compute.c
int zerop(int x);
int numeqp(int x, int y);
int eqp(int x1, int x2);
int eqvp(int x1, int x2);
int smallerp(int x1, int x2);
int eqsmallerp(int x1, int x2);
int greaterp(int x1, int x2);
int eqgreaterp(int x1, int x2);
double bignumtofloat(int x);
int exact_to_inexact(int x);
int flttorat(int x);
int flttobig(int x);
int inexact_to_exact(int x);
int realtocomp(int x);
int plus(int arg1, int arg2);
int minus(int arg1, int arg2);
int mult(int arg1, int arg2);
int divide(int arg1, int arg2);
int s_remainder(int x, int y);
int quotient(int x, int y);
int int_gcd(int x, int y);
int gcd(int x, int y);
int int_lcm(int m, int n);
int lcm(int x, int y);
int s_abs(int x);
int big_plus(int arg1, int arg2);
int big_plus1(int arg1, int arg2);
int big_rev(int arg);
int big_minus(int arg1, int arg2);
int big_minus1(int arg1, int arg2);
int big_mult(int arg1, int arg2);
int	big_mult1(int arg1, int arg2);
int big_int_mult(int arg1, int arg2);
int	big_quotient(int arg1, int arg2);
int	big_quotient1(int arg1, int arg2);
int big_int_quotient(int arg1, int arg2);
int norm_bignum(int arg);
int inttobignum(int x);
int bignumtoint(int x);
int big_eqp(int arg1, int arg2);
int big_greaterp(int arg1, int arg2);
int big_smallerp(int arg1, int arg2);
int big_integerizep(int x);
int big_positivep(int x);
int big_negativep(int x);
int	big_abs(int x);
int	big_sift(int x, int n);
int	big_int_remainder(int x, int y);

//cell.c
void initcell(void);
void initmodule(void);
int freshcell(void);
int get_tag(int addr);
int make_NIL(void);
int make_bool(char *name);
int returnbool(char *name);
int make_int(int intn);
int addr_to_int(int addr);
int make_big(char *bignum);
int make_flt(double floatn);
int norm_rat(int x);
int make_rat(int n, int d);
void norm_comp(int x);
int make_comp(double real, double imag);
int hash(char *name);
int findsym(char *name, int index);
int addsym(char *name, int index);
int addsym1(int x, int index);
int make_sym(char *name);
int make_sym1(char *name);
int make_clo(void);
int make_macro(void);
int make_hygienic(void);
int make_synclo(char *name);
int make_cont(void);
int make_str(char *name);
int make_char(char *name);
int make_port(FILE *port, int type);
int make_vector(int n, int obj);
void vector_set(int v, int n, int obj);
int vector_ref(int v, int n);
int vector_length(int v);
int vector(int lis);
int make_ident(char *name);
int make_env(int i, int j);
int make_code(int i);
int make_stack(void);
int make_memory(void);
int make_multiple_values(int lis);
int make_empty_set(void);
int get_int(int x);
int get_lvar(int i, int j);
void set_lvar(int i, int j, int val);
int remake(int x);

//function.c
int f_car(int n);
int f_cdr(int n);
int f_cons(int n);
int f_caar(int n);
int f_cdar(int n);
int f_cddr(int n);
int f_cadr(int n);
int f_caaar(int n);
int f_cdaar(int n);
int f_cadar(int n);
int f_caadr(int n);
int f_cddar(int n);
int f_caddr(int n);
int f_cdadr(int n);
int f_cdddr(int n);
int f_caaaar(int n);
int f_cdaaar(int n);
int f_cadaar(int n);
int f_caadar(int n);
int f_caaadr(int n);
int f_cddaar(int n);
int f_caddar(int n);
int f_caaddr(int n);
int f_cdaadr(int n);
int f_cdadar(int n);
int f_cadadr(int n);
int f_cadddr(int n);
int f_cdaddr(int n);
int f_cddadr(int n);
int f_cdddar(int n);
int f_cddddr(int n);
int f_assq(int n);
int f_assv(int n);
int f_assoc(int n);
int f_memq(int n);
int f_memv(int n);
int f_member(int n);
int f_reverse(int n);
int f_reverse2(int n);
int f_setcar(int n);
int f_setcdr(int n);
int f_append(int n);
int f_append2(int n);
int f_list(int n);
int f_makelist(int n);
int f_length(int n);
int f_pair_length(int n);
int f_listtail(int n);
int f_listref(int n);
int f_last(int n);
int	f_butlast(int n);
int f_nullp(int n);
int f_listp(int n);
int f_pairp(int n);
int f_boolp(int n);
int f_symbolp(int n);
int f_procedurep(int n);
int f_atomp(int n);
int f_eqp(int n);
int f_eqvp(int n);
int f_equalp(int n);
int f_numberp(int n);
int f_integerp(int n);
int f_realp(int n);
int f_rationalp(int n);
int f_complexp(int n);
int	f_exactp(int n);
int	f_inexactp(int n);
int f_stringp(int n);
int	f_characterp(int n);
int f_bignump(int n);
int	f_vectorp(int n);
int f_macrop(int n);
int f_macro_namep(int n);
int identifier_to_symbol(int x);
int f_hygienic_namep(int n);
int f_make_vector(int n);
int f_vector_set(int n);
int f_vector_ref(int n);
int f_vector(int n);
int f_vector_length(int n);
int f_vector_fill(int n);
int f_vector_to_list(int n);
int	f_list_to_vector(int n);
int f_char_eqp(int n);
int f_char_ci_eqp(int n);
int f_char_greaterp(int n);
int f_char_ci_greaterp(int n);
int f_char_eqgreaterp(int n);
int f_char_ci_eqgreaterp(int n);
int f_char_smallerp(int n);
int f_char_ci_smallerp(int n);
int f_char_eqsmallerp(int n);
int f_char_ci_eqsmallerp(int n);
int f_char_alphabeticp(int n);
int f_char_numericp(int n);
int f_char_whitespacep(int n);
int f_char_upper_casep(int n);
int f_char_lower_casep(int n);
int f_char_to_integer(int n);
int f_integer_to_char(int n);
int f_char_upcase(int n);
int f_char_downcase(int n);
int f_string_eqp(int n);
int f_string_ci_eqp(int n);
int f_string_greaterp(int n);
int f_string_ci_greaterp(int n);
int f_string_eqgreaterp(int n);
int f_string_ci_eqgreaterp(int n);
int f_string_smallerp(int n);
int f_string_ci_smallerp(int n);
int f_string_eqsmallerp(int n);
int f_string_ci_eqsmallerp(int n);
int	f_string_append(int n);
int f_number_to_string(int n);
int f_string_to_number(int n);
int f_string_to_symbol(int n);
int f_symbol_to_string(int n);
int f_string_length(int n);
int f_make_string(int n);
int f_string(int n);
int	f_string_ref(int n);
int f_string_set(int n);
int f_substring(int n);
int f_string_to_list(int n);
int f_list_to_string(int n);
int f_string_copy(int n);
int f_string_fill(int n);
int f_plus(int n);
int f_minus(int n);
int f_mult(int n);
int f_div(int n);
int f_smallerp(int n);
int f_eqsmallerp(int n);
int f_greaterp(int n);
int f_eqgreaterp(int n);
int f_numeqp(int n);
int f_oddp(int n);
int f_evenp(int n);
int f_positivep(int n);
int f_negativep(int n);
int f_abs(int n);
int f_max(int n);
int f_min(int n);
int	f_remainder(int n);
int f_modulo(int n);
int	f_quotient(int n);
int f_gcd(int n);
int f_lcm(int n);
int f_floor(int n);
int f_ceiling(int n);
int f_truncate(int n);
int f_round(int lvar);
int f_numerator(int n);
int f_denominator(int n);
int f_sin(int n);
int f_asin(int n);
int f_cos(int n);
int f_acos(int n);
int	f_tan(int n);
double argz(double x, double y);
int f_atan(int n);
int f_log(int n);
int f_exp(int n);
int f_sqrt(int n);
int f_expt(int n);
int square(int x);
int expt(int x, int y);
int f_zerop(int n);
int f_realpart(int n);
int f_imagpart(int n);
int f_magnitude(int n);
int f_angle(int n);
int f_make_rectangular(int n);
int f_make_polar(int n);
int	f_exact_inexact(int n);
int	f_inexact_exact(int n);
int f_not(int n);
int f_read(int n);
int f_read_char(int n);
int f_peek_char(int n);
int	f_char_readyp(int n);
int f_load(int n);
int	f_open_input_file(int n);
int f_input_portp(int n);
int f_close_input_port(int n);
int f_eof_objectp(int n);
int f_current_input_port(int n);
int	f_open_output_file(int n);
int f_close_output_port(int n);
int f_output_portp(int n);
int f_current_output_port(int n);
int f_newline(int n);
void display_str(int x);
int output_portp(int x);
int f_display(int n);
int f_write(int n);
int f_write_char(int n);
int f_exit(int n);
int f_call_cc(int n);
int	f_gensym(int n);
int f_apply(int n);
int f_primitive_name_p(int n);
int f_macroexpand1(int n);
int macroexpand1(int x);
int f_macroexpand(int n);
int macroexpand(int x);
int	f_addr(int n);
int f_undefined(int n);
int f_vm1_step(int n);
int f_vm2_step(int n);
int f_vm1(int n);
int f_dump(int n);
int f_addr_prt(int n);
int f_entity_addr(int n);
int f_gbc(int n);
int f_room(int n);
int f_vmcode(int n);
int f_timer_set(int n);
int f_timer_get(int n);
int f_timer_gbc(int n);
int f_eval(int n);
int f_inspect(int n);
int f_env(int n);
int f_step(int n);
int f_vm2(int n);
int f_lambda_asm(int n);
int f_error(int n);
int f_flush(int n);
int f_set_trace(int n);
int f_set_untrace(int n);
int f_transfer(int n);
int f_debug(int n);
int f_prof(int n);
int f_current_module(int n);
int f_values(int n);
int f_sys_cont_room(int n);
int f_make_sc(int n);
int f_symbol_to_identifier(int n);
int f_identifier_to_symbol(int n);
int f_syntactic_closurep(int n);
int f_identifierp(int n);
int f_identifier_bind(int n);
int f_identifier_freep(int n);
int f_identifier_boundp(int n);
int f_identifier_bound(int n);
int f_global_boundp(int n);
int f_exact_integerp(int n);
int f_file_existsp(int n);
int f_system(int n);

void defsubr(char *name, int func);
void defsyntax(char *name);
void initsubr(void);
void initsyntax(void);

//r7rs.c
void init_r7rs(void);

7z¼¯' ·«OØEX     $       oK"¢ â9‘•íi?ÕgpG¬öNb|N5KÍ¨W1<z2_–ì‘°ÎŸí' ÓqpùMAßÒ@Ãñ•Ôôd_QúZZpæÓ€¢¿œn:7Iû‹ÁGIüˆ3’$£ØIfb§Mzûêõdm†‡…ëŸô„t5éˆî”$'º0*#ã¥¦Ğç Ä{-¼Äc-•ÜçH%>aß/Yæ¯b¡© RÅú%›šø#vljé®ŞE{2Ñoa\ÿLÔ¨¼uœ“B"´Bù1¡B›é‡Ç¹äkõP7Àœ£tÇæZj'
ëGğëVuò:9´õÕZfZĞU”i!™ñxB¾ğÀG¤HI¯e•òë=·vöXŠK-õöù_ğ»æJ;%oš]>R„ù@ãw‚†Â‘VíE¼e#\X>Ğ—%&A‹Ÿ7èÚS­nQúÜ4'l’\
‰P­ôi„J
{óC•™)Î~7Xq„sÕ%5oš_×Óë»{HInâUşá­šÖô¸ høféYß,Z¢ãgé]JvGt4V!ÄtCÄŸËÀ€ÛLñ¹Ş„õ	¦+µuj¸@®ÈGõs±€©'Ü	ÿ(á=IJÌÁ_´´×‘VÁ;;‚Ì‚¼‚«ŒŠÅ“K‰»
;;optimizer


(define (instr1 x)
  (car x))

(define (instr2 x)
  (cadr x))

(define (instr3 x)
  (caddr x))

(define (instr4 x)
  (cadddr x))

(define (opcode x)
  (if (list? x)
      (car x)
      #f))

(define (operand1 x)
  (if (list? x)
      (cadr x)
      #f))

(define (operand2 x)
  (if (list? x)
      (caddr x)
      #f))

(define (optimize code)
  (optimize1 code code))

(define (optimize1 code all-code)
  (cond ((null? code) '())
        ((eq? (opcode (instr1 code)) 'fn)
         (seq (gen 'fn
                   (operand1 (instr1 code))
                   (optimize1 (operand2 (instr1 code))
                              (operand2 (instr1 code))))
              (optimize1 (cdr code) all-code)))
        ((and (eq? (opcode (instr1 code)) 'gvar)
              (eq? (opcode (instr2 code)) 'call))
         ;;((gvar g)(call 1)) -> (gvcl g 1)
         (seq (gen 'gvcl 
                   (operand1 (instr1 code))
                   (operand1 (instr2 code)))
              (optimize1 (cddr code) all-code)))
        ((and (eq? (opcode (instr1 code)) 'gvar)
              (eq? (opcode (instr2 code)) 'callj))
         ;;((gvar g)(callj 1)) -> (gvcj g 1)
         (seq (gen 'gvcj 
                   (operand1 (instr1 code))
                   (operand1 (instr2 code)))
              (optimize1 (cddr code) all-code)))
        ((and (label? (instr1 code))
              (not (find-label (instr1 code) all-code)))
         ;;g—p‚³‚ê‚Ä‚¢‚È‚¢ƒ‰ƒxƒ‹‚ª‚ ‚éê‡
         (optimize1 (cdr code) all-code))
        (else
          (cons (car code) (optimize1 (cdr code) all-code)))))

(define (find-label l code)
  (cond ((null? code) #f)
        ((eq? (operand1 (instr1 code)) l) #t)
        (else (find-label l (next-instr code)))))

(define (next-instr code)
  (cond ((null? code) '())
        ((label? (instr1 (cdr code))) (next-instr (cddr code)))
        (else (cdr code))))

;;‘Oˆ— Œø—¦‚Ì‚æ‚¢ŠÖ”‚Ö‚Ì’uŠ·A’è”ô‚İ‚İ‚ğs‚¤B
(define (preprocess x)
  (cond ((null? x) '())
        ((atom? x) x)
        ((vector? x) x)
        ((and (list? x)
              (memq (car x) '(+ - * / sin cos tan asin acos atan))
              (for-all number? (cdr x)))
         (eval x))
        ((and (list? x)
              (eq? (car x) '+)
              (= (length x) 3)
              (eq? (cadr x) 1))
         (list '+ (caddr x) 1))
        ((and (list? x)
              (eq? (car x) '+)
              (= (length x) 3)
              (eq? (cadr x) 2))
         (list '+ (caddr x) 2))
        (else (cons (preprocess (car x))
                    (preprocess (cdr x))))))

(define (for-all pred x)
  (cond ((null? x) #t)
        ((pred (car x)) (for-all pred (cdr x)))
        (else #f)))


       

                   
;;u‘f”–é‹Èv‚æ‚èƒeƒXƒgƒR[ƒh—p‚É”qØ


;;p470
(define ** (lambda (a b) (expt a b)))
(define // (lambda (a b) (quotient a b)))
(define /@ (lambda (a b) (remainder a b)))
(define /: (lambda (a b) (modulo a b)))
(define ++ (lambda (i) (+ i 1)))
(define -- (lambda (i) (- i 1)))

(define make-even (lambda (n) (* 2 n)))
(define make-odd (lambda (n) (+ (* 2 n) 1)))

(define parity-of
  (lambda (p)
    (if (odd? p) -1 1)))

(define pi 3.141592653589793)

(define f_2x+3
  (lambda (x)
    (let ((a 2)(b 3))
      (+ (* a x) b))))

(define generator
  (lambda (initial)
    (let ((n initial))
      (lambda () (set! n (+ n 1))))))

(define count-1 (generator -1))

(define fact
  (lambda (n)
    (if (zero? n)
        1
        (* n (fact (- n 1))))))

(letrec ((fact
           (lambda (n)
             (if (zero? n)
                 1
                 (* n (fact (- n 1)))))))
  (fact 10))

;;p482
(define succ (lambda (list) (cons 1 list)))
(define pred (lambda (list) (cdr list))) 

(define plus
  (lambda (x y)
    (if (null? y)
        x
        (succ (plus x (pred y))))))

(define mult
  (lambda (x y)
    (if (null? y)
        '()
        (plus x (mult x (pred y))))))

(define pows
  (lambda (x y)
    (if (null? y)
        '(1)
        (mult x (pows x (pred y))))))

;;p494
(define fact-tailrec
  (lambda (n)
    (define fact-iter
      (lambda (y p)
        (if (zero? y)
            p
            (fact-iter (- y 1) (* y p)))))
    (fact-iter n 1)))


(define card-1
  (lambda (x)
    (if (= x 1234)
        'ok
        'oops!)))

(define my-abs
  (lambda (x)
    (cond ((positive? x) x)
          ((zero? x) 0)
          ((negative? x) (- x)))))

(define dom1-9
  (lambda (x) (and (< 1 x) (< x 9))))

(define or-less5
  (lambda (x) (or (< x 5) (= x 5))))

(define nonzero?
  (lambda (x) (not (zero? x))))

(letrec 
  ((even? (lambda (x) (or (zero? x)(odd? (- x 1)))))
   (odd? (lambda (x) (and (nonzero? x) (even? (- x 1))))))
   (even? 3))

;;p449
(define type-check
  (lambda (x)
    (define form
      (lambda (str)
        (display "This is ") (display str)))
    (cond ((procedure? x) (form "a procedure: ") x)
          ((number? x)    (form "a number: ") x))))


;;p462
(* 7 (call/cc (lambda (x) (x (+ 3 5)))))

(define opp/cc '())

(* 7 (call/cc (lambda (x) (set! opp/cc x) (x (+ 3 5)))))

;;p462
(define branch
  (lambda (s)
    (cond ((= s 1) (call/cc (lambda (x) (* (x 7) (+ 3 5)))))
          ((= s 2) (call/cc (lambda (x) (* 7 (x (+ 3 5))))))
          ((= s 3) (call/cc (lambda (x) (* 7 (+ (x 3) 5)))))
          (else 'again))))

;;p472
(define swap-test
  (lambda (a b)
    (let* ((dummy a) (a b)(b dummy))
      (** a b))))


;;p473
(define adjust-of
  (lambda (x)
    (let ((digit 1000)
          (slide (if (positive? x) 1/2 -1/2)))
      (/ (truncate (+ slide (* digit x))) digit))))

;;p478
(define iota
  (lambda (max . opt)
    (let* ((min (if (null? opt) 1 (car opt)))
           (step (if (or (null? opt) (null? (cdr opt)))
                     1 (cadr opt)))
           (dummy max)
           (max (if (null? opt) max min))
           (min (if (null? opt) min dummy)))
      (let loop ((i (- min step)) (tmp '()))
        (if (< (- max step) i)
            (reverse tmp)
            (loop (+ i step)
                  (cons (adjust-of (+ i step)) tmp)))))))


;;p502
(define flatten
  (lambda (lst)
    (cond ((null? lst) '())
          ((pair? lst)
           (append (flatten (car lst))
                   (flatten (cdr lst))))
          (else (list lst)))))


;;p518
(define del-obj
  (lambda (lst obj)
    (call/cc
      (lambda (k)
        (cond ((null? lst) '())
              ((equal? (car lst) obj) (k (cdr lst)))
              (else (cons (car lst)
                          (del-obj (cdr lst) obj))))))))

(define del-obj1
  (lambda (lst obj)
    (cond ((null? lst) '())
          ((equal? (car lst) obj)(cdr lst))
          (else (cons (car lst)
                      (del-obj1 (cdr lst) obj))))))




;;p518
(define (permutation lst)
  (if (null? lst)
      (list '())
      (apply append
             (map (lambda (i)
                    (map (lambda (j) (cons i j))
                         (permutation (del-obj lst i))))
                  lst))))

;;p491
(define sq
  (lambda (x) (* x x)))

;;p615
(define (/@zero? x y)
  (zero? (/@ x y)))


;;p616
(define (minid-of n)
  (define (next k)
    (if (= k 2) 3 (+ k 2)))
  (let ((i 2))
    (let loop ((i i))
      (cond ((< n (sq i)) n)
            ((/@zero? n i) i)
            (else (loop (next i)))))))

(define (prime? n)
  (if (= n 1)
      #f
      (= n (minid-of n))))

(define (factp-of n)
  (let loop ((i n) (tmp '()))
    (let ((div (minid-of i)))
      (if (= i div)
          (reverse (cons i tmp))
          (loop (/ i div) (cons div tmp))))))

(define (wall lst)
  (define pivot?
    (lambda (x) (lambda (y) (= x y))))
  (let loop ((lst1 '()) (lst2 lst))
    (if (null? lst2)
        (reverse lst1)
        (loop
          (cons (filter (pivot? (car lst2)) lst2) lst1)
          (remove (pivot? (car lst2)) lst2) ))))


(define (factorize-of n)
  (fact-exp (wall (factp-of n))))

;;p619
(define (tau-of n)
  (define (fact-list lst)
    (if (null? lst)
        '()
        (cons (+ (cadar lst) 1)
              (fact-list (cdr lst)))))
  (if (= n 1)
      1
      (apply * (fact-list (factorize-of n)))))

;;p594

(define (memoize proc)
  (let ((table '()))
    (lambda x (let ((stock (assoc x table)))
                (if stock
                    (cdr stock)
                    (let ((data (apply proc x)))
                      (set! table
                            (cons (cons x data) table)) data))))))


(define fib-memo
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (fib-memo (- n 1))
                            (fib-memo (- n 2))))))))

;;p581
(define quine
  (lambda (x) (list x (list (quote quote) x))))

;;p515
(define flatmap
  (lambda (proc lst)
    (apply append (map proc lst))))

;;; (flatmap (lambda (i) (map (lambda (j) (list i j)) '(1 2))) '(a b))
;;; ((a 1) (a 2) (b 1) (b 2))

;;p516
(define (double n)
  (apply append
         (map (lambda (i)
                (map (lambda (j) (list i j))
                     (iota (- i 1)) ))
              (iota n))))

(define (triple n)
  (apply append
         (map (lambda (i)
                (map (lambda (j)
                       (list (sq+ i j) i j))
                     (iota (- i 1)) ))
              (iota n))))

(define dismap
  (lambda (proc dlst)
    (map (lambda (x) (map proc x)) dlst)))


;;p511
(define map-unit
  (lambda (proc lst)
    (if (null? lst)
        '()
        (cons (proc (car lst))
              (map-unit proc (cdr lst))))))

(define map-mult
  (lambda (proc rest)
    (if (null? (car rest))
        '()
        (cons (apply proc (map-unit car rest))
              (apply my-map proc (map-unit cdr rest))))))

(define my-map
  (lambda (proc . rest)
    (if (null? (cdr rest))
        (map-unit proc (car rest))
        (map-mult proc rest))))


;;p466
(define product
  (lambda (lst)
    (call/cc (lambda (k)
               (cond ((null? lst) 1)
                     ((= (car lst) 0) (k 0))
                     (else (* (car lst) (product (cdr lst)))))))))




(define sum
  (lambda (initial final body)
    (if (> initial final)
        0
        (+ (body initial)
           (sum (++ initial) final body)))))

(define product
  (lambda (initial final body)
    (if (> initial final)
        1
        (* (body initial)
           (product (++ initial) final body)))))


;;p785
(define-syntax s-cons
  (syntax-rules ()
    ((_ x y)(cons x (delay y)))))

(define (int-from n)
  (s-cons n (int-from (+ n 1))))

(define numbers* (int-from 1))

(define (s-car stm) (car stm))
(define (s-cdr stm) (force (cdr stm)))


;;;p555ƒ`ƒƒ[ƒ`”

(define zero (lambda (s) (lambda (z) z)))
(define one (lambda (s) (lambda (z) (s z))))
(define two (lambda (s) (lambda (z) (s(s z)))))
(define three (lambda (s) (lambda (z) (s(s(s z))))))

(define add1 (lambda (n) (+ n 1)))
(define sub1 (lambda (n) (- n 1)))

(define compose
  (lambda (f g)
    (lambda (x) (f (g x)))))


(define repeated
  (lambda (f n)
    (if (zero? n)
        (lambda (x) x)
        (compose f (repeated f (-- n))))))

(define succ
  (lambda (v)
    (lambda (s)
      (lambda (z)
        (s ((v s) z))))))

(define succ#
  (lambda (v s z)
    (s ((v s) z))))


                            (define (solve? num ls)
  (let loop ((ls ls)(n 1))
    (cond
      ((null? ls)#t)
      ((= (abs (- num (car ls))) n)
       #f)
      (else (loop (cdr ls)(+ n 1))))))

(define (check? lst)
  (let loop ((lst lst))
    (cond
      ((null? (cdr lst))#t)
      ((solve? (car lst) (cdr lst))
       (loop (cdr lst)))
      (else #f))))

(define (queen lst)
  (let loop ((lst lst)(result '()))
    (if (null? lst)
      (print (reverse result))
      (for-each (lambda(x)
        (if (check? (reverse (cons x result)))
                  (loop (delete x lst) (cons x result)))) lst))))

(define (delete x lst)
  (cond ((null? lst) '())
        ((eq? x (car lst)) (delete x (cdr lst)))
        (else (cons (car lst) (delete x (cdr lst))))))

(define (print x)
  (display x)
  (newline))

#include "norm.h"

extern int current_module;


void init_r7rs(void){
	
    current_module = 1; //(normal system)
	defsubr("pair-length",(int)f_pair_length);
    defsubr("last",(int)f_last);
    defsubr("butlast",(int)f_butlast);
    defsubr("sys-code",(int)f_vmcode);
    defsubr("sys-env",(int)f_env);
    defsubr("sys-timer-set",(int)f_timer_set);
    defsubr("sys-timer-get",(int)f_timer_get);
    defsubr("sys-timer-gbc",(int)f_timer_gbc);
    defsubr("primitive-name?",(int)f_primitive_name_p);
    defsubr("macroexpand-1",(int)f_macroexpand1);
    defsubr("macroexpand",(int)f_macroexpand);
    defsubr("addr",(int)f_addr);
    defsubr("entity-addr",(int)f_entity_addr);
    defsubr("undefined",(int)f_undefined);
    defsubr("step",(int)f_step);
    defsubr("vm2-step",(int)f_vm2_step);
    defsubr("vm1",(int)f_vm1);
    defsubr("vm2",(int)f_vm2);
    defsubr("dump",(int)f_dump);
    defsubr("addr-prt",(int)f_addr_prt);
    defsubr("room",(int)f_room);
    defsubr("macro-name?",(int)f_macro_namep);
    defsubr("hygienic-name?",(int)f_hygienic_namep);
    defsubr("gensym",(int)f_gensym);
    defsubr("flush",(int)f_flush);
    defsubr("sys-set-trace",(int)f_set_trace);
    defsubr("sys-set-untrace",(int)f_set_untrace);
    defsubr("transfer",(int)f_transfer);
    defsubr("debug",(int)f_debug);
    defsubr("profiler",(int)f_prof);
    defsubr("current-module",(int)f_current_module);
    defsubr("sys-cont-room",(int)f_sys_cont_room);
    defsubr("make-syntactic-closure",(int)f_make_sc);
    defsubr("symbol->identifier",(int)f_symbol_to_identifier);
    defsubr("identifier->symbol",(int)f_identifier_to_symbol);
    defsubr("syntactic-closure?",(int)f_syntactic_closurep);
    defsubr("identifier?",(int)f_identifierp);
    defsubr("identifier-bind!",(int)f_identifier_bind);
    defsubr("identifier-free?",(int)f_identifier_freep);
    defsubr("identifier-bound?",(int)f_identifier_boundp);
    defsubr("identifier-bound",(int)f_identifier_bound);
    defsubr("global-bound?",(int)f_global_boundp);
    defsubr("inspect",(int)f_inspect);
    defsubr("lambda/asm",(int)f_lambda_asm);
    defsubr("system",(int)f_system);
    

	current_module = 3; //(scheme base)
    defsubr("car",(int)f_car);
    defsubr("cdr",(int)f_cdr);
    defsubr("cons",(int)f_cons);
    defsubr("caar",(int)f_caar);
    defsubr("cdar",(int)f_cdar);
    defsubr("cddr",(int)f_cddr);
    defsubr("cadr",(int)f_cadr);
    defsubr("caaar",(int)f_caaar);
    defsubr("cdaar",(int)f_cdaar);
    defsubr("cadar",(int)f_cadar);
    defsubr("caadr",(int)f_caadr);
    defsubr("cddar",(int)f_cddar);
    defsubr("caddr",(int)f_caddr);
    defsubr("cdadr",(int)f_cdadr);
    defsubr("cdddr",(int)f_cdddr);
    defsubr("caaaar",(int)f_caaaar);
    defsubr("cdaaar",(int)f_cdaaar);
    defsubr("cadaar",(int)f_cadaar);
    defsubr("caadar",(int)f_caadar);
    defsubr("caaadr",(int)f_caaadr);
    defsubr("cddaar",(int)f_cddaar);
    defsubr("caddar",(int)f_caddar);
    defsubr("caaddr",(int)f_caaddr);
    defsubr("cdaadr",(int)f_cdaadr);
    defsubr("cdadar",(int)f_cdadar);
    defsubr("cadddr",(int)f_cadddr);
    defsubr("cdaddr",(int)f_cdaddr);
    defsubr("cddadr",(int)f_cddadr);
    defsubr("cdddar",(int)f_cdddar);
    defsubr("cddddr",(int)f_cddddr);
    defsubr("assq",(int)f_assq);
    defsubr("assv",(int)f_assv);
    defsubr("assoc",(int)f_assoc);
    defsubr("memq",(int)f_memq);
    defsubr("memv",(int)f_memv);
    defsubr("member",(int)f_member);
    defsubr("reverse",(int)f_reverse);
    defsubr("reverse!",(int)f_reverse2);
    defsubr("list-tail",(int)f_listtail);
    defsubr("list-ref",(int)f_listref);
    defsubr("append",(int)f_append);
    defsubr("append!",(int)f_append2);
    defsubr("set-car!",(int)f_setcar);
    defsubr("set-cdr!",(int)f_setcdr);
    defsubr("list",(int)f_list);
    defsubr("make-list",(int)f_makelist);
    defsubr("length",(int)f_length);
    defsubr("newline",(int)f_newline);
    defsubr("write-char",(int)f_write_char);
	defsubr("null?",(int)f_nullp);
    defsubr("list?",(int)f_listp);
    defsubr("pair?",(int)f_pairp);
    defsubr("atom?",(int)f_atomp);
    defsubr("eq?",(int)f_eqp);
    defsubr("eqv?",(int)f_eqvp);
    defsubr("equal?",(int)f_equalp);
    defsubr("boolean?",(int)f_boolp);
    defsubr("procedure?",(int)f_procedurep);
    defsubr("number?",(int)f_numberp);
    defsubr("integer?",(int)f_integerp);
    defsubr("real?",(int)f_realp);
    defsubr("rational?",(int)f_rationalp);
    defsubr("complex?",(int)f_complexp);
    defsubr("exact?",(int)f_exactp);
    defsubr("inexact?",(int)f_inexactp);
    defsubr("symbol?",(int)f_symbolp);
    defsubr("string?",(int)f_stringp);
    defsubr("char?",(int)f_characterp);
    defsubr("bignum?",(int)f_bignump);
    defsubr("vector?",(int)f_vectorp);
    defsubr("macro?",(int)f_macrop);
    defsubr("zero?",(int)f_zerop);
    defsubr("+",(int)f_plus);
    defsubr("-",(int)f_minus);
    defsubr("*",(int)f_mult);
    defsubr("/",(int)f_div);
    defsubr("<",(int)f_smallerp);
    defsubr("<=",(int)f_eqsmallerp);
    defsubr(">",(int)f_greaterp);
    defsubr(">=",(int)f_eqgreaterp);
    defsubr("=",(int)f_numeqp);
    defsubr("expt",(int)f_expt);
    defsubr("not",(int)f_not);
    defsubr("odd?",(int)f_oddp);
    defsubr("even?",(int)f_evenp);
    defsubr("floor",(int)f_floor);
    defsubr("ceiling",(int)f_ceiling);
    defsubr("truncate",(int)f_truncate);
    defsubr("round",(int)f_round);
    defsubr("numerator",(int)f_numerator);
    defsubr("denominator",(int)f_denominator);
    defsubr("positive?",(int)f_positivep);
    defsubr("negative?",(int)f_negativep);
    defsubr("abs",(int)f_abs);
    defsubr("max",(int)f_max);
    defsubr("min",(int)f_min);
    defsubr("exact->inexact",(int)f_exact_inexact);
	defsubr("inexact->exact",(int)f_inexact_exact);
    defsubr("remainder",(int)f_remainder);
	defsubr("modulo",(int)f_modulo);
    defsubr("quotient",(int)f_quotient);
    defsubr("gcd",(int)f_gcd);
    defsubr("lcm",(int)f_lcm);
    defsubr("string-append",(int)f_string_append);
    defsubr("number->string",(int)f_number_to_string);
    defsubr("string->number",(int)f_string_to_number);
    defsubr("string=?",(int)f_string_eqp);
    defsubr("string>?",(int)f_string_greaterp);
    defsubr("string>=?",(int)f_string_eqgreaterp);
    defsubr("string<?",(int)f_string_smallerp);
    defsubr("string<=?",(int)f_string_eqsmallerp);
    defsubr("string-ci=?",(int)f_string_ci_eqp);
    defsubr("string-ci>?",(int)f_string_ci_greaterp);
    defsubr("string-ci>=?",(int)f_string_ci_eqgreaterp);
    defsubr("string-ci<?",(int)f_string_ci_smallerp);
    defsubr("string-ci<=?",(int)f_string_ci_eqsmallerp);
    defsubr("string->symbol",(int)f_string_to_symbol);
    defsubr("symbol->string",(int)f_symbol_to_string);
    defsubr("string-length",(int)f_string_length);
    defsubr("make-string",(int)f_make_string);
    defsubr("string",(int)f_string);
    defsubr("string-ref",(int)f_string_ref);
    defsubr("string-set!",(int)f_string_set);
    defsubr("substring",(int)f_substring);
    defsubr("string->list",(int)f_string_to_list);
    defsubr("list->string",(int)f_list_to_string);
    defsubr("string-copy",(int)f_string_copy);
    defsubr("string-fill!",(int)f_string_fill);
    defsubr("make-vector",(int)f_make_vector);
    defsubr("vector-set!",(int)f_vector_set);
    defsubr("vector",(int)f_vector);
    defsubr("vector-ref",(int)f_vector_ref);
    defsubr("vector-length",(int)f_vector_length);
    defsubr("vector-fill!",(int)f_vector_fill);
    defsubr("vector->list",(int)f_vector_to_list);
    defsubr("list->vector",(int)f_list_to_vector);
    defsubr("open-input-file",(int)f_open_input_file);
    defsubr("open-output-file",(int)f_open_output_file);
    defsubr("close-input-port",(int)f_close_input_port);
    defsubr("close-output-port",(int)f_close_output_port);
    defsubr("eof-object?",(int)f_eof_objectp);
    defsubr("input-port?",(int)f_input_portp);
    defsubr("output-port?",(int)f_output_portp);
    defsubr("current-input-port",(int)f_current_input_port);
    defsubr("current-output-port",(int)f_current_output_port);
    defsubr("read-char",(int)f_read_char);
    defsubr("peek-char",(int)f_peek_char);
    defsubr("char-ready?",(int)f_char_readyp);
    defsubr("exit",(int)f_exit);
	defsubr("apply",(int)f_apply);
    defsubr("gbc",(int)f_gbc);
    defsubr("values",(int)f_values);
    defsubr("exact-integer?",(int)f_exact_integerp);
	defsubr("error",(int)f_error);
	
	
    current_module = 4; //(scheme inexact)
    defsubr("sin",(int)f_sin);
    defsubr("cos",(int)f_cos);
    defsubr("tan",(int)f_tan);
    defsubr("asin",(int)f_asin);
    defsubr("acos",(int)f_acos);
    defsubr("atan",(int)f_atan);
    defsubr("log",(int)f_log);
    defsubr("exp",(int)f_exp);
    defsubr("sqrt",(int)f_sqrt);
    
    current_module = 5; //(scheme complex)
    defsubr("real-part",(int)f_realpart);
    defsubr("imag-part",(int)f_imagpart);
    defsubr("magnitude",(int)f_magnitude);
    defsubr("angle",(int)f_angle);
    defsubr("make-rectangular",(int)f_make_rectangular);
    defsubr("make-polar",(int)f_make_polar);
    
    current_module = 9;
    defsubr("eval",(int)f_eval);
    
    current_module = 12; //(scheme load)
    defsubr("load",(int)f_load);
    
    current_module = 13; //(scheme file)
    defsubr("file-exists?",(int)f_file_existsp);
    
    current_module = 14; //(scheme read)
    defsubr("read",(int)f_read);
    
    current_module = 15; //(scheme write)
    defsubr("display",(int)f_display);
    defsubr("write",(int)f_write);
    
    current_module = 16; //(scheme char)
    defsubr("char=?",(int)f_char_eqp);
    defsubr("char>?",(int)f_char_greaterp);
    defsubr("char>=?",(int)f_char_eqgreaterp);
    defsubr("char<?",(int)f_char_smallerp);
    defsubr("char<=?",(int)f_char_eqsmallerp);
    defsubr("char-ci=?",(int)f_char_ci_eqp);
    defsubr("char-ci>?",(int)f_char_ci_greaterp);
    defsubr("char-ci>=?",(int)f_char_ci_eqgreaterp);
    defsubr("char-ci<?",(int)f_char_ci_smallerp);
    defsubr("char-ci<=?",(int)f_char_ci_eqsmallerp);
    defsubr("char-alphabetic?",(int)f_char_alphabeticp);
	defsubr("char-numeric?",(int)f_char_numericp);
    defsubr("char-whitespace?",(int)f_char_whitespacep);
    defsubr("char-upper-case?",(int)f_char_upper_casep);
    defsubr("char-lower-case?",(int)f_char_lower_casep);
    defsubr("char->integer",(int)f_char_to_integer);
    defsubr("integer->char",(int)f_integer_to_char);
    defsubr("char-upcase",(int)f_char_upcase);
    defsubr("char-downcase",(int)f_char_downcase);
	
    current_module = 2;
}L     ¦:      .text           $    ,      Ø    0`.data                               @ 0À.bss                                € 0À.rdata          Œ  (              @ 0@.drectve        D  ´              @ 0À/4              4   ø  œ:         @ 0@ƒìÇ       ÇD$    Ç$    è    ÇD$    Ç$   è    ÇD$    Ç$   è    ÇD$    Ç$   è    ÇD$    Ç$"   è    ÇD$    Ç$*   è    ÇD$    Ç$8   è    ÇD$    Ç$F   è    ÇD$    Ç$T   è    ÇD$    Ç$d   è    ÇD$    Ç$r   è    ÇD$    Ç$~   è    ÇD$    Ç$ƒ   è    ÇD$    Ç$   è    ÇD$    Ç$™   è    ÇD$    Ç$   è    ÇD$    Ç$§   è    ÇD$    Ç$«   è    ÇD$    Ç$¯   è    ÇD$    Ç$´   è    ÇD$    Ç$½   è    ÇD$    Ç$Â   è    ÇD$    Ç$Î   è    ÇD$    Ç$İ   è    ÇD$    Ç$ä   è    ÇD$    Ç$ê   è    ÇD$    Ç$ø   è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$   è    ÇD$    Ç$/  è    ÇD$    Ç$=  è    ÇD$    Ç$T  è    ÇD$    Ç$g  è    ÇD$    Ç$z  è    ÇD$    Ç$  è    ÇD$    Ç$™  è    ÇD$    Ç$ª  è    ÇD$    Ç$»  è    ÇD$    Ç$Í  è    ÇD$    Ç$Ş  è    ÇD$    Ç$ì  è    ÇD$    Ç$ô  è    ÇD$    Ç$ÿ  è    Ç       ÇD$    Ç$  è    ÇD$    Ç$
  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$"  è    ÇD$    Ç$'  è    ÇD$    Ç$-  è    ÇD$    Ç$3  è    ÇD$    Ç$9  è    ÇD$    Ç$?  è    ÇD$    Ç$E  è    ÇD$    Ç$K  è    ÇD$    Ç$Q  è    ÇD$    Ç$W  è    ÇD$    Ç$^  è    ÇD$    Ç$e  è    ÇD$    Ç$l  è    ÇD$    Ç$s  è    ÇD$    Ç$z  è    ÇD$    Ç$  è    ÇD$    Ç$ˆ  è    ÇD$    Ç$  è    ÇD$    Ç$–  è    ÇD$    Ç$  è    ÇD$    Ç$¤  è    ÇD$    Ç$«  è    ÇD$    Ç$²  è    ÇD$    Ç$¹  è    ÇD$    Ç$À  è    ÇD$    Ç$Å  è    ÇD$    Ç$Ê  è    ÇD$    Ç$Ğ  è    ÇD$    Ç$Õ  è    ÇD$    Ç$Ú  è    ÇD$    Ç$á  è    ÇD$    Ç$é  è    ÇD$    Ç$ò  è    ÇD$    Ç$ü  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$&  è    ÇD$    Ç$+  è    ÇD$    Ç$5  è    ÇD$    Ç$<  è    ÇD$    Ç$D  è    ÇD$    Ç$O  è    ÇD$    Ç$U  è    ÇD$    Ç$[  è    ÇD$    Ç$a  è    ÇD$    Ç$g  è    ÇD$    Ç$k  è    ÇD$    Ç$p  è    ÇD$    Ç$w  è    ÇD$    Ç$€  è    ÇD$    Ç$‹  è    ÇD$    Ç$“  è    ÇD$    Ç$œ  è    ÇD$    Ç$¢  è    ÇD$    Ç$¬  è    ÇD$    Ç$µ  è    ÇD$    Ç$¼  è    ÇD$    Ç$Å  è    ÇD$    Ç$Í  è    ÇD$    Ç$Õ  è    ÇD$    Ç$Û  è    ÇD$    Ç$ã  è    ÇD$    Ç$ë  è    ÇD$    Ç$ò  è    ÇD$    Ç$ø  è    ÇD$    Ç$ú  è    ÇD$    Ç$ü  è    ÇD$    Ç$ş  è    ÇD$    Ç$   è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$
  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$  è    ÇD$    Ç$

(define (euclidean/ n1 n2)
  (when (zero? n2)
    (error "in ceiling/ devide by zero " n1 n2))
  (when (or (not (integer? n1)) (not (integer? n2)))
    (error "in ceiling/ not integer " n1 n2))
  (let ((q 0)(r 0))
    (if (> n2 0)
        (set! q (floor (/ n1 n2)))
        (set! q (ceiling (/ n1 n2))))
    (set! r (remainder n1 q))
    (values q r)))

      Simple Scheme‚Ìì¬‚Å“¾‚ç‚ê‚½’mŒ©‚ğ‚à‚Æ‚ÉVM‚ğì‚è’¼‚µ‚½
Normal‚Æ‚¢‚¤Schemeˆ—Œn‚ğì‚Á‚Ä‚¢‚Ü‚·BPAIP‚ÌNorvigƒRƒ“ƒpƒCƒ‰‚ğ
ƒx[ƒX‚É‚µ‚Ä‚¢‚Ü‚·B


¡‰ñ‚ÌÀ‘•‚Å‚ÍÅ“K‰»‚Ì•×‹­‚ÉW’†‚µ‚½‚¢‚Æv‚Á‚Ä‚¢‚Ü‚·B
Simple Scheme‚Ìì¬‚Å“¾‚ç‚ê‚½’mŒ©‚ğ‚à‚Æ‚ÉVM‚ğì‚è’¼‚µ‚½
Normal‚Æ‚¢‚¤Schemeˆ—Œn‚ğì‚Á‚Ä‚¢‚Ü‚·BPAIP‚ÌNorvigƒRƒ“ƒpƒCƒ‰‚ğ
ƒx[ƒX‚É‚µ‚Ä‚¢‚Ü‚·B


¡‰ñ‚ÌÀ‘•‚Å‚ÍÅ“K‰»‚Ì•×‹­‚ÉW’†‚µ‚½‚¢‚Æv‚Á‚Ä‚¢‚Ü‚·B
;;––”öÄ‹AÅ“K‰»ƒeƒXƒg
;;CALLJ–½—ß‚É‚æ‚èƒ‹[ƒv‚Æ“¯—l‚É‚È‚Á‚Ä‚¢‚È‚¢‚Æ‚¢‚¯‚È‚¢B

(define lastl
  (lambda (l)
    (if (null? (cdr l))
        (car l)
        (lastl (cdr l)))))

(define (fact-tail n)
  (fact-tail2 n 1))

(define (fact-tail2 n m)
  (if (= n 0)
      m
      (fact-tail2 (- n 1) (* m n))))

(define (sigma-tail n)
  (sigma-tail2 n 0))

(define (sigma-tail2 n m)
  (if (= n 0)
      m
      (sigma-tail2 (- n 1) (+ m n))))

(define (sigma-rec n)
  (if (= n 0)
      0
      (+ n (sigma-rec (- n 1)))))

(define (foo x)
  (define (boo x)
    (+ x x))
  (define (uoo x)
    (* x x))
  (define (goo x)
    (/ x x))
  (/ (boo x) (uoo x)))

(define (fib-tail n)
  (fib-tail2 n 2 1 0))

(define (fib-tail2 n x n1 n2)
    (if (= x n)
        (+ n1 n2)
        (fib-tail2 n (+ x 1) (+ n1 n2) n1)))



(define (fact-letrec n)
  (letrec ((iter (lambda (n1 p)
		   (if (= n1 1)
		       p
		       (let ((m (- n1 1)))
			 (iter m (* p m)))))))     ; *
    (iter n n)))




(define-library (test)
  (export woo)
  (import (scheme base)
          (scheme inexact))
          
  (begin
    (define (woo x)
      (letrec ((a (lambda (x) (sin x))))
        (a x)))))


    







;;

(import (normal system)
        (scheme file))

(define (compress)
  (when (file-exists? "norms.zip") (delete-file "norms.zip"))
  (system "7z a -t7z norms.zip *.c")
  (system "7z a -t7z norms.zip *.scm")
  (system "7z a -t7z norms.zip *.o")
  (system "7z a -t7z norms.zip makefile")
  (system "copy norms.zip c:\users\kenichi.DOM11731A\documents\D‚«‚¢–²\*.*")
)

(define (unzip)
  (system "copy c:\users\kenichi.DOM11731A\downloads\norms.zip *.*")
  (system "7z e norms.zip"))
;;ƒxƒNƒ^ƒeƒXƒg
(import (normal test))

(test* "(vector 1 2 3)" #(1 2 3) (vector 1 2 3))
(define a (vector 1 2 3))
(test* "(vector-ref a 1)"  1 (vector-ref a 0))
(vector-set! a 0 5)
(test* "(vector-set a 0)" 5 (vector-ref a 0))
(test* "(list->vector '(1 2 3))" #(1 2 3) (list->vector '(1 2 3)))
(test* "(vector->list #(1 2 3))" '(1 2 3) (vector->list #(1 2 3)))
(test* "(make-vector 3 1)" #(1 1 1) (make-vector 3 1))
(vector-fill! a 5)
(test* "vector-fill!" #(5 5 5) a)

;;Shiro‚³‚ñ‚ÌƒeƒXƒgƒR[ƒhBˆê•”‰ü•Ò



(let ((cc #f)
      (count #f))
  
  (call/cc
    (lambda (return)
      (dynamic-wind
        (lambda () (display "A"))
        (lambda () 
          (set! count (call/cc (lambda (c) (set! cc c) 0)))
          (display "B")
          (if (> count 3) (return #f)))
        (lambda () (display "C")))
      (dynamic-wind 
        (lambda () (display "D"))
        (lambda () (cc (+ count 1)))
        (lambda () (display "E"))))))
      

;;R5RS ‚æ‚è
(let ((path '())
      (c #f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call/cc
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))

(15 1 (12 1 3 0 0 17 transfer 1 2 () 2 #t 2 #t 2 #f 2 #f 2 #t 2 #f 4 comp 13 8 2 halt 17 list 1 17 list 1 17 append 2 11) 18 compile 1)
(15 8 (12 8 3 0 0 17 null? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 boolean? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 symbol? 1 10 22 3 0 0 3 0 1 3 0 2 3 0 3 3 0 5 4 comp-var 13 5 11 3 0 0 17 identifier-free? 1 10 22 3 0 0 3 0 1 3 0 2 3 0 3 3 0 5 4 comp-var 13 5 11 3 0 0 17 atom? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 17 vector? 1 10 19 3 0 0 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 34 17 macro-name? 1 10 34 3 0 0 17 macroexpand-1 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 17 hygienic-name? 1 10 34 3 0 0 17 macroexpand-1 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 2 quote 17 eqv? 2 10 34 3 0 0 2 1 2 1 4 args-count-check 13 3 7 3 0 0 17 cadr 1 3 0 2 3 0 3 3 0 5 4 comp-const 13 4 11 3 0 0 34 2 begin 17 eqv? 2 10 32 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-begin 13 8 11 3 0 0 34 2 set! 17 eqv? 2 10 111 3 0 0 2 2 2 2 4 args-count-check 13 3 7 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 3 0 0 17 cadr 1 3 0 1 4 gen-set 13 2 3 0 2 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 0 3 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 13 4 11 3 0 0 34 2 if 17 eqv? 2 10 82 3 0 0 17 length 1 2 3 21 10 16 3 0 0 2 ((undefined)) 17 append 2 5 0 0 7 8 2 3 0 0 2 3 2 3 4 args-count-check 13 3 7 3 0 0 17 cadr 1 3 0 0 17 caddr 1 3 0 0 17 cadddr 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 2 #t 4 comp-if 13 10 11 3 0 0 34 2 lambda 17 eqv? 2 10 41 3 0 2 10 33 3 0 0 17 cadr 1 3 0 0 17 cddr 1 3 0 1 3 0 6 3 0 7 4 comp-lambda 13 5 15 1 (12 1 2 fn 3 1 0 17 cadr 1 4 args-count 13 1 3 0 0 4 gen 13 3 3 1 3 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2) 13 1 11 2 #f 11 3 0 0 34 2 define 17 eqv? 2 10 77 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 2 1 15 1 (12 1 3 0 0 17 primitive-name? 1 17 not 1 11) 2 "can't overwrite primitive name " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 2 def 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 define-macro 17 eqv? 2 10 61 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 2 #f 3 0 7 4 comp 13 8 2 defm 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 define-syntax 17 eqv? 2 10 64 3 0 0 2 1 4 symbol? 2 "require symbol " 4 args-type-check 13 4 7 3 0 0 17 caddr 1 3 0 1 2 #t 2 #t 3 0 4 3 0 5 2 #f 3 0 7 4 comp 13 8 2 defh 3 0 0 17 cadr 1 3 0 1 4 gen 13 3 4 seq 13 2 11 3 0 0 34 2 define-library 17 eqv? 2 10 63 3 0 0 2 2 2 infinity 4 args-count-check 13 3 7 3 0 0 2 1 4 list? 2 "require list for library name" 4 args-type-check 13 4 7 2 deflib 3 0 0 17 cadr 1 3 0 0 17 cddr 1 4 gen 13 3 2 const 3 0 0 17 cadr 1 4 gen 13 2 4 seq 13 2 11 3 0 0 34 2 export 17 eqv? 2 10 29 3 0 0 2 1 2 infinity 4 args-count-check 13 3 7 2 explib 3 0 0 35 4 gen 13 2 4 seq 13 1 11 3 0 0 34 2 import 17 eqv? 2 10 29 3 0 0 2 1 2 infinity 4 args-count-check 13 3 7 2 implib 3 0 0 35 4 gen 13 2 4 seq 13 1 11 3 0 0 34 2 math 17 eqv? 2 10 36 3 0 0 35 4 infix->prefix 13 1 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 2 syntax-rules 17 eqv? 2 10 77 2 lambda 2 expr 2 comp-env 2 vm-env 2 () 36 36 36 2 expand 2 quote 3 0 0 17 cddr 1 2 () 36 36 2 expr 3 0 0 17 cadr 1 2 comp-env 2 () 36 36 36 36 36 2 () 36 36 36 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 11 3 0 0 34 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-funcall 13 9 11) 18 comp 1)
(15 4 (12 4 3 0 1 10 42 2 const 3 0 0 4 gen 13 2 3 0 2 17 not 1 10 7 3 0 3 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2 2 () 11) 18 comp-const 1)
(15 5 (12 5 3 0 2 10 43 3 0 0 3 0 1 4 gen-var 13 2 3 0 3 17 not 1 10 7 3 0 4 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 2 2 () 11) 18 comp-var 1)
(15 8 (12 8 3 0 0 17 null? 1 10 17 2 () 3 0 2 3 0 3 3 0 5 4 comp-const 14 4 3 0 0 4 length=1? 13 1 10 33 3 0 0 34 17 transfer 1 3 0 1 3 0 2 2 #f 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 14 8 3 0 0 34 17 transfer 1 3 0 1 2 #f 2 #t 3 0 4 3 0 5 3 0 6 3 0 7 4 comp 13 8 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 4 comp-begin 13 8 4 seq 14 2) 18 comp-begin 1)
(15 6 (12 6 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 34 3 0 1 2 #t 2 #t 3 0 2 3 0 3 3 0 4 3 0 5 4 comp 13 8 3 0 0 35 3 0 1 3 0 2 3 0 3 3 0 4 3 0 5 4 comp-list 13 6 4 seq 14 2) 18 comp-list 1)
(15 10 (12 10 3 0 0 17 not 1 10 31 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 11 3 0 0 17 atom? 1 10 28 3 0 0 17 symbol? 1 17 not 1 10 13 3 0 0 17 not 1 17 not 1 8 4 2 #f 8 4 2 #f 10 31 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 11 3 0 0 17 list? 1 10 27 3 0 0 35 4 length=1? 13 1 10 13 3 0 0 34 2 not 17 eq? 2 8 4 2 #f 8 4 2 #f 10 40 3 0 0 17 cadr 1 3 0 2 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp-if 13 10 11 3 0 0 3 0 3 2 #t 2 #t 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 3 0 1 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 3 0 2 3 0 3 3 0 4 3 0 5 3 0 6 3 0 7 3 0 8 3 0 9 4 comp 13 8 15 3 (12 3 3 0 1 3 0 2 17 equal? 2 10 36 3 1 0 3 1 3 2 #f 2 #t 3 1 6 3 1 7 3 1 8 3 1 9 4 comp 13 8 3 0 2 4 seq 13 2 11 3 0 1 17 not 1 10 12 4 gen-label 13 0 15 1 (12 1 3 1 0 2 tjump 3 0 0 4 gen 13 2 3 1 2 3 0 0 17 list 1 3 2 5 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5) 13 1 11 4 gen-label 13 0 3 1 5 10 8 4 gen-label 13 0 8 4 2 #f 15 2 (12 2 3 1 0 2 fjump 3 0 0 4 gen 13 2 3 1 1 3 2 5 10 13 2 jump 3 0 1 4 gen 13 2 8 4 2 () 3 0 0 17 list 1 3 1 2 3 2 5 10 10 3 0 1 17 list 1 8 4 2 () 4 seq 14 7) 13 2 11) 13 3 11) 18 comp-if 1)
(15 9 (12 9 3 0 0 17 symbol? 1 17 not 1 10 13 3 0 0 17 list? 1 17 not 1 8 4 2 #f 10 13 2 "illegal function call " 3 0 0 17 error 2 7 8 2 3 0 0 3 0 2 4 primitive? 13 2 15 1 (12 1 3 0 0 10 973 3 1 0 3 1 1 36 3 0 0 4 prim-min 13 1 3 0 0 4 prim-max 13 1 4 args-count-check 13 3 7 3 1 3 17 not 1 10 14 3 0 0 4 prim-side-effect? 13 1 17 not 1 8 4 2 #f 10 29 3 1 1 3 1 2 2 #f 3 1 4 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-begin 14 8 3 1 0 2 (= < <= > >=) 17 memv 2 10 13 3 1 1 17 length 1 2 2 21 8 4 2 #f 10 88 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 4 binomial-op 17 assv 2 17 cadr 1 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 zero? 17 eqv? 2 10 13 3 1 1 17 length 1 2 1 21 8 4 2 #f 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 zerop 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 - 17 eqv? 2 10 56 3 1 1 17 length 1 2 2 21 10 41 3 1 1 17 cadr 1 2 1 17 eq? 2 10 15 3 1 1 17 cadr 1 2 1 17 eq? 2 8 13 3 1 1 17 cadr 1 2 2 17 eq? 2 8 4 2 #f 8 4 2 #f 10 101 3 1 1 17 butlast 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 1 17 cadr 1 2 1 21 10 10 2 sub1 4 gen 13 1 8 8 2 sub2 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 + 17 eqv? 2 10 56 3 1 1 17 length 1 2 2 21 10 41 3 1 1 17 cadr 1 2 1 17 eq? 2 10 15 3 1 1 17 cadr 1 2 1 17 eq? 2 8 13 3 1 1 17 cadr 1 2 2 17 eq? 2 8 4 2 #f 8 4 2 #f 10 101 3 1 1 17 butlast 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 1 17 cadr 1 2 1 21 10 10 2 add1 4 gen 13 1 8 8 2 add2 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 car 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 car 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 cdr 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 cdr 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 2 cons 17 eqv? 2 10 79 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 cons 4 gen 13 1 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 2 prim 3 1 0 3 1 1 17 length 1 4 gen 13 3 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 7 3 1 6 8 4 2 #f 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 4 3 1 0 17 list? 1 10 28 3 1 0 34 2 lambda 17 eqv? 2 10 13 3 1 0 17 cadr 1 17 null? 1 8 4 2 #f 8 4 2 #f 10 54 3 1 1 17 null? 1 17 not 1 10 13 2 "too many arguments: " 3 1 1 17 error 2 7 8 2 3 1 0 17 cddr 1 3 1 2 3 1 3 3 1 4 3 1 5 2 #f 3 1 7 3 1 8 4 comp-begin 14 8 3 1 4 17 not 1 10 28 3 1 5 17 not 1 10 16 3 1 7 10 7 3 1 8 8 4 2 #f 8 4 2 #f 8 4 2 #f 10 66 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 callj 3 1 1 17 length 1 4 gen 13 2 4 seq 14 3 3 1 0 2 call/cc 17 eqv? 2 10 101 3 1 1 3 1 2 3 1 5 3 1 6 2 #f 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 call 3 1 1 17 length 1 4 gen 13 2 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5 3 1 1 3 1 2 3 1 5 3 1 6 3 1 7 3 1 8 4 comp-list 13 6 3 1 0 3 1 2 2 #t 2 #t 3 1 5 3 1 6 3 1 7 3 1 8 4 comp 13 8 2 call 3 1 1 17 length 1 4 gen 13 2 3 1 3 17 not 1 10 10 2 pop 4 gen 13 1 8 4 2 () 3 1 4 17 not 1 10 10 2 return 4 gen 13 1 8 4 2 () 4 seq 14 5) 13 1 11) 18 comp-funcall 1)
(2 ((= neqp) (< smlp) (<= esmlp) (> grtp) (>= egrtp)) 18 binomial-op 1)
(15 1 (12 1 3 0 0 17 cadddr 1 11) 18 prim-always? 1)
(15 1 (12 1 3 0 0 17 cdddr 1 17 cadr 1 11) 18 prim-side-effect? 1)
(15 1 (12 1 3 0 0 17 cadr 1 11) 18 prim-min 1)
(15 1 (12 1 3 0 0 17 caddr 1 11) 18 prim-max 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 17 not 1 10 11 3 0 0 4 *primitive* 17 assoc 2 11 2 #f 11) 18 primitive? 1)
(15 5 (12 5 3 0 3 10 55 2 args 3 0 0 4 args-count 13 1 4 gen 13 2 3 0 1 3 0 0 3 0 2 36 2 #t 2 #t 3 0 1 17 macroexpand 1 4 inner-lambda? 13 1 2 #t 3 0 3 3 0 4 4 comp-begin 13 8 4 seq 14 2 2 args 3 0 0 4 args-count 13 1 4 gen 13 2 3 0 1 3 0 0 3 0 2 36 2 #t 2 #t 2 #f 2 #t 3 0 3 3 0 4 4 comp-begin 13 8 4 seq 14 2) 18 comp-lambda 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 5 2 -1 11 3 0 0 17 list? 1 10 9 3 0 0 17 length 1 11 3 0 0 17 pair-length 1 17 - 1 11) 18 args-count 1)
(15 1 (12 1 3 0 0 17 list? 1 10 12 3 0 0 17 length 1 2 1 21 11 2 #f 11) 18 length=1? 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 () 11 3 0 1 34 3 0 0 13 1 3 0 0 3 0 1 35 4 mappend 13 2 17 append 2 11) 18 mappend 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 #t 11 3 0 0 17 symbol? 1 10 5 2 #t 11 3 0 0 17 atom? 1 10 5 2 #f 11 3 0 0 34 17 symbol? 1 17 not 1 10 5 2 #f 11 3 0 0 35 4 lambda-args? 14 1) 18 lambda-args? 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 9 3 0 0 17 symbol? 1 11 3 0 0 17 list? 1 11) 18 symbol-or-list? 1)
(15 3 (12 3 3 0 0 35 17 length 1 15 1 (12 1 3 0 0 3 1 1 25 10 12 3 1 2 2 infinity 17 eq? 2 8 4 2 #f 10 5 2 #t 11 3 0 0 3 1 1 25 10 11 3 0 0 3 1 2 23 8 4 2 #f 10 5 2 #t 11 2 "incorrect argument count " 3 1 0 17 error 2 11) 13 1 11) 18 args-count-check 1)
(15 4 (12 4 3 0 0 3 0 1 17 list-ref 2 3 0 2 13 1 10 5 2 #t 11 3 0 3 3 0 0 17 error 2 11) 18 args-type-check 1)
(15 -2 (12 -2 3 0 0 3 0 1 36 17 list 1 11) 18 gen 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 15 1 (12 1 3 0 0 10 18 2 lvar 3 0 0 34 3 0 0 17 cadr 1 4 gen 14 3 3 1 0 17 identifier-free? 1 10 14 2 gvar 3 1 0 17 identifier->symbol 1 4 gen 14 2 2 gvar 3 1 0 4 gen 14 2) 13 1 11) 18 gen-var 1)
(15 2 (12 2 3 0 0 3 0 1 4 in-env? 13 2 15 1 (12 1 3 0 0 10 18 2 lset 3 0 0 34 3 0 0 17 cadr 1 4 gen 14 3 2 gset 3 1 0 4 gen 14 2) 13 1 11) 18 gen-set 1)
(15 -1 (12 -1 4 append 3 0 0 17 apply 2 11) 18 seq 1)
(15 0 (12 0 2 "L" 17 gensym 1 11) 18 gen-label 1)
(15 1 (12 1 3 0 0 17 symbol? 1 10 19 3 0 0 17 symbol->string 1 2 2 17 string-ref 2 2 #\L 17 char=? 2 11 2 #f 11) 18 label? 1)
(15 2 (12 2 3 0 0 3 0 1 2 0 4 in-env-iter 13 3 11) 18 in-env? 1)
(15 3 (12 3 3 0 1 17 null? 1 10 5 2 #f 11 3 0 0 3 0 1 34 4 in-args? 13 2 10 20 3 0 2 3 0 0 3 0 1 34 4 nth-args 13 2 17 list 2 11 3 0 0 3 0 1 35 3 0 2 27 4 in-env-iter 14 3) 18 in-env-iter 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 #f 11 3 0 1 17 symbol? 1 10 13 3 0 0 3 0 1 17 eq? 2 8 4 2 #f 10 5 2 #t 11 3 0 1 17 symbol? 1 10 5 2 #f 11 3 0 0 3 0 1 34 17 eq? 2 10 5 2 #t 11 3 0 0 3 0 1 35 4 in-args? 14 2) 18 in-args? 1)
(15 2 (12 2 3 0 1 17 symbol? 1 10 13 3 0 0 3 0 1 17 eq? 2 8 4 2 #f 10 5 2 0 11 3 0 0 3 0 1 34 17 eq? 2 10 5 2 0 11 2 1 3 0 0 3 0 1 35 4 nth-args 13 2 17 + 2 11) 18 nth-args 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 #f 11 3 0 0 17 atom? 1 10 5 2 #f 11 3 0 0 17 vector? 1 10 5 2 #f 11 3 0 0 34 2 lambda 17 eq? 2 10 5 2 #t 11 3 0 0 34 4 inner-lambda? 13 1 10 10 3 0 0 34 4 inner-lambda? 14 1 3 0 0 35 4 inner-lambda? 14 1) 18 inner-lambda? 1)
(15 1 (12 1 3 0 0 17 cadr 1 11) 18 arg1 1)
(15 1 (12 1 3 0 0 17 caddr 1 11) 18 arg2 1)
(15 1 (12 1 3 0 0 17 cadddr 1 11) 18 arg3 1)
(15 1 (12 1 3 0 0 34 11) 18 op 1)
(15 1 (12 1 3 0 0 2 (+) 17 memv 2 10 5 2 + 11 3 0 0 2 (-) 17 memv 2 10 5 2 - 11 3 0 0 2 (/) 17 memv 2 10 5 2 / 11 3 0 0 2 (*) 17 memv 2 10 5 2 * 11 3 0 0 2 (^) 17 memv 2 10 5 2 ^ 11 3 0 0 2 (sin) 17 memv 2 10 5 2 sin 11 3 0 0 2 (cos) 17 memv 2 10 5 2 cos 11 3 0 0 2 (exp) 17 memv 2 10 5 2 exp 11 3 0 0 2 (log) 17 memv 2 10 5 2 log 11 3 0 0 2 (sinh) 17 memv 2 10 5 2 sinh 11 3 0 0 2 (cosh) 17 memv 2 10 5 2 cosh 11 3 0 0 2 else 17 memv 2 10 11 2 "opecode else: " 3 0 0 17 error 2 11 17 undefined 0 11) 18 opcode 1)
(15 1 (12 1 3 0 0 2 (+) 17 memv 2 10 5 2 1 11 3 0 0 2 (-) 17 memv 2 10 5 2 1 11 3 0 0 2 (/) 17 memv 2 10 5 2 2 11 3 0 0 2 (*) 17 memv 2 10 5 2 3 11 3 0 0 2 (^) 17 memv 2 10 5 2 4 11 3 0 0 2 (sin) 17 memv 2 10 5 2 6 11 3 0 0 2 (cos) 17 memv 2 10 5 2 6 11 3 0 0 2 (exp) 17 memv 2 10 5 2 6 11 3 0 0 2 (log) 17 memv 2 10 5 2 6 11 3 0 0 2 (cosh) 17 memv 2 10 5 2 6 11 3 0 0 2 (sinh) 17 memv 2 10 5 2 6 11 3 0 0 2 else 17 memv 2 10 5 2 9 11 17 undefined 0 11) 18 weight 1)
(15 1 (12 1 3 0 0 4 infip 13 1 11) 18 infix->prefix 1)
(15 1 (12 1 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 2 () 2 () 4 inf1 14 3) 18 infip 1)
(15 3 (12 3 3 0 0 4 op 13 1 4 weight 13 1 2 5 22 10 18 3 0 0 4 op 13 1 4 weight 13 1 2 5 22 8 16 3 0 0 4 op 13 1 4 weight 13 1 2 7 24 10 25 3 0 0 35 3 0 1 3 0 0 34 4 infip 13 1 3 0 2 36 4 inf2 14 3 3 0 0 17 cddr 1 3 0 1 3 0 0 4 op 13 1 3 0 0 4 arg1 13 1 4 infip 13 1 17 list 2 3 0 2 36 4 inf3 14 3) 18 inf1 1)
(15 3 (12 3 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 7 3 0 2 34 11 3 0 0 17 null? 1 17 not 1 10 37 3 0 1 17 null? 1 10 10 3 0 1 17 null? 1 8 19 3 0 0 34 4 weight 13 1 3 0 1 34 4 weight 13 1 24 8 4 2 #f 10 21 3 0 0 35 3 0 0 34 3 0 1 36 3 0 2 4 inf1 14 3 3 0 0 3 0 1 35 3 0 1 34 4 opcode 13 1 3 0 2 17 cadr 1 3 0 2 34 17 list 3 3 0 2 17 cddr 1 36 4 inf2 14 3) 18 inf2 1)
(15 3 (12 3 3 0 0 17 null? 1 10 10 3 0 2 17 null? 1 8 4 2 #f 10 7 3 0 2 34 11 3 0 0 17 null? 1 17 not 1 10 39 3 0 1 17 null? 1 10 10 3 0 1 17 null? 1 8 21 3 0 0 34 4 weight 13 1 3 0 0 17 cadr 1 4 weight 13 1 24 8 4 2 #f 10 21 3 0 0 35 3 0 0 34 3 0 1 36 3 0 2 4 inf1 14 3 3 0 0 3 0 1 3 0 2 4 inf2 14 3) 18 inf3 1)
(15 1 (12 1 3 0 0 3 0 0 4 pass1 13 1 4 pass2 13 2 11) 18 assemble 1)
(15 1 (12 1 3 0 0 2 1 2 () 4 pass1-iter 13 3 11) 18 pass1 1)
(15 3 (12 3 3 0 0 17 null? 1 10 6 3 0 2 11 3 0 0 34 4 label? 13 1 10 25 3 0 0 35 3 0 1 3 0 0 34 3 0 1 36 3 0 2 36 4 pass1-iter 14 3 3 0 0 35 3 0 1 3 0 0 34 4 op-count 13 1 17 + 2 3 0 2 4 pass1-iter 14 3) 18 pass1-iter 1)
(15 2 (12 2 3 0 0 2 1 2 () 3 0 1 4 pass2-iter 13 4 11) 18 pass2 1)
(15 4 (12 4 3 0 0 17 null? 1 10 9 3 0 2 17 reverse 1 11 3 0 0 34 4 label? 13 1 10 19 3 0 0 35 3 0 1 3 0 2 3 0 3 4 pass2-iter 14 4 3 0 0 35 3 0 1 3 0 0 34 4 op-count 13 1 17 + 2 3 0 0 34 3 0 3 3 0 1 4 mnemonic->code 13 3 17 reverse 1 3 0 2 17 append 2 3 0 3 4 pass2-iter 14 4) 18 pass2-iter 1)
(15 3 (12 3 3 0 0 34 2 halt 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 const 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 lvar 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 gvar 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 lset 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 gset 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 pop 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 jump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 tjump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 fjump 17 eqv? 2 10 33 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 1 17 assq 2 35 3 0 2 17 - 2 17 list 2 11 3 0 0 34 2 return 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 args 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 call 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 callj 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 fn 17 eqv? 2 10 30 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 4 assemble 13 1 17 list 3 11 3 0 0 34 2 save 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 prim 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 def 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 defm 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 defh 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 neqp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 smlp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 esmlp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 grtp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 egrtp 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 zerop 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 add1 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 sub1 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 add2 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 sub2 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 gref 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 catch 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 pause 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 car 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 cdr 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 cons 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 adapt 17 eqv? 2 10 14 3 0 0 34 4 op-code 13 1 17 list 1 11 3 0 0 34 2 deflib 17 eqv? 2 10 26 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 3 0 0 17 caddr 1 17 list 3 11 3 0 0 34 2 explib 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 3 0 0 34 2 implib 17 eqv? 2 10 20 3 0 0 34 4 op-code 13 1 3 0 0 17 cadr 1 17 list 2 11 17 undefined 0 11) 18 mnemonic->code 1)
(15 1 (12 1 3 0 0 17 length 1 11) 18 op-count 1)
(15 1 (12 1 3 0 0 4 mnemonic 17 member 2 11) 18 op-code? 1)
(15 1 (12 1 4 mnemonic 17 length 1 3 0 0 4 mnemonic 17 member 2 17 length 1 17 - 2 11) 18 op-code 1)
(2 nop 2 halt 2 const 2 lvar 2 gvar 2 lset 2 gset 2 pop 2 jump 2 tjump 2 fjump 2 return 2 args 2 call 2 callj 2 fn 2 save 2 prim 2 def 2 defm 2 defh 2 neqp 2 smlp 2 esmlp 2 grtp 2 egrtp 2 zerop 2 add1 2 sub1 2 add2 2 sub2 2 gref 2 catch 2 pause 2 car 2 cdr 2 cons 2 adapt 2 deflib 2 explib 2 implib 17 list 41 18 mnemonic 1)
(2 ((car 1 1 #t #f) (cdr 1 1 #t #f) (cons 2 2 #t #f) (caar 1 1 #t #f) (cdar 1 1 #t #f) (cddr 1 1 #t #f) (cadr 1 1 #t #f) (caaar 1 1 #t #f) (cdaar 1 1 #t #f) (cadar 1 1 #t #f) (caadr 1 1 #t #f) (cddar 1 1 #t #f) (caddr 1 1 #t #f) (cdadr 1 1 #t #f) (cdddr 1 1 #t #f) (caaaar 1 1 #t #f) (cdaaar 1 1 #t #f) (cadaar 1 1 #t #f) (caadar 1 1 #t #f) (caaadr 1 1 #t #f) (cddaar 1 1 #t #f) (caddar 1 1 #t #f) (caaddr 1 1 #t #f) (cdaadr 1 1 #t #f) (cdadar 1 1 #t #f) (cadddr 1 1 #t #f) (cdaddr 1 1 #t #f) (cddadr 1 1 #t #f) (cdddar 1 1 #t #f) (cddddr 1 1 #t #f) (assq 2 2 #t #f) (assv 2 2 #t #f) (assoc 2 2 #t #f) (memq 2 2 #t #f) (memv 2 2 #t #f) (member 2 2 #t #f) (reverse 1 1 #t #f) (reverse! 1 1 #t #t) (list-tail 1 1 #t #f) (list-ref 2 2 #t #f) (append 2 2 #t #f) (append! 2 infinity #t #ft) (set-car! 2 2 #t #f) (set-cdr! 2 2 #t #f) (list 0 infinity #t #f) (make-list 1 2 #t #f) (length 1 1 #t #f) (pair-length 1 1 #t #f) (last 1 1 #t #f) (butlast 1 1 #t #f) (newline 0 1 #t #t) (display 1 2 #t #t) (write 1 2 #t #t) (write-char 1 1 #t #t) (null? 1 1 #t #f) (list? 1 1 #t #f) (pair? 1 1 #t #f) (atom? 1 1 #t #f) (eq? 1 infinity #t #f) (eqv? 1 infinity #t #f) (equal? 1 infinity #t #f) (boolean? 1 1 #t #f) (procedure? 1 1 #t #f) (number? 1 1 #t #f) (integer? 1 1 #t #f) (real? 1 1 #t #f) (rational? 1 1 #t #f) (complex? 1 1 #t #f) (exact? 1 1 #t #f) (inexact? 1 1 #t #f) (symbol? 1 1 #t #f) (string? 1 1 #t #f) (char? 1 1 #t #f) (bignum? 1 1 #t #f) (vector? 1 1 #t #f) (macro? 1 1 #t #f) (macro-name? 1 1 #t #f) (hygienic-name? 1 1 #t #f) (zero? 1 1 #t #f) (+ 0 infinity #t #f) (- 1 infinity #t #f) (* 0 infinity #t #f) (/ 1 infinity #t #f) (< 2 infinity #t #f) (<= 2 infinity #t #f) (> 2 infinity #t #f) (>= 2 infinity #t #f) (= 2 infinity #t #f) (sin 1 1 #t #f) (cos 1 1 #t #f) (tan 1 1 #t #f) (asin 1 1 #t #f) (acos 1 1 #t #f) (atan 1 2 #t #f) (log 1 1 #t #f) (exp 1 1 #t #f) (sqrt 1 1 #t #f) (expt 2 2 #t #f) (not 1 1 #t #f) (odd? 1 1 #t #f) (even? 1 1 #t #f) (floor 1 1 #t #f) (ceiling 1 1 #t #f) (truncate 1 1 #t #f) (round 1 1 #t #f) (numerator 1 1 #t #f) (denominator 1 1 #t #f) (positive? 1 1 #t #f) (negative? 1 1 #t #f) (abs 1 1 #t #f) (max 1 infinity #t #f) (min 1 infinity #t #f) (real-part 1 1 #t #f) (imag-part 1 1 #t #f) (magnitude 1 1 #t #f) (angle 1 1 #t #f) (make-rectangular 2 2 #t #f) (make-polar 2 2 #t #f) (exact->inexact 1 1 #t #f) (inexact->exact 1 1 #t #f) (remainder 2 2 #t #f) (modulo 2 2 #t #f) (quotient 2 2 #t #f) (gcd 0 2 #t #f) (lcm 0 2 #t #f) (char=? 2 2 #t #f) (char>? 2 2 #t #f) (char>=? 2 2 #t #f) (char<? 2 2 #t #f) (char<=? 2 2 #t #f) (char-ci=? 2 2 #t #f) (char-ci>? 2 2 #t #f) (char-ci>=? 2 2 #t #f) (char-ci<? 2 2 #t #f) (char-ci<=? 2 2 #t #f) (char-alphabetic? 1 1 #t #f) (char-numeric? 1 1 #t #f) (char-whitespace? 1 1 #t #f) (char-upper-case? 1 1 #t #f) (char-lower-case? 1 1 #t #f) (char->integer 1 1 #t #f) (integer->char 1 1 #t #f) (char-upcase 1 1 #t #f) (char-downcase 1 1 #t #f) (string-append 1 infinity #t #f) (number->string 1 2 #t #f) (string->number 1 2 #t #f) (string=? 1 1 #t #f) (string>? 1 1 #t #f) (string>=? 1 1 #t #f) (string<? 1 1 #t #f) (string<=? 1 1 #t #f) (string-ci=? 1 1 #t #f) (string-ci>? 1 1 #t #f) (string-ci>=? 1 1 #t #f) (string-ci<? 1 1 #t #f) (string-ci<=? 1 1 #t #f) (string->symbol 1 1 #t #f) (symbol->string 1 1 #t #f) (string-length 1 1 #t #f) (make-string 1 1 #t #f) (string 1 1 #t #f) (string-ref 2 2 #t #f) (string-set! 2 2 #t #t) (substring 1 1 #t #f) (string->list 1 1 #t #f) (list->string 1 1 #t #f) (string-copy 1 1 #t #f) (string-fill! 1 1 #t #t) (make-vector 2 2 #t #f) (vector-set! 3 3 #t #f) (vector 1 infinity #t #f) (vector-ref 2 2 #t #f) (vector-length 1 1 #t #f) (vector-fill! 2 2 #t #f) (vector->list 1 1 #t #f) (list->vector 1 1 #t #f) (read 0 1 #t #f) (load 1 1 #t #f) (open-input-file 1 1 #t #t) (open-output-file 1 1 #t #t) (close-input-port 1 1 #t #t) (close-output-port 1 1 #t #t) (eof-object? 1 1 #t #f) (input-port? 1 1 #t #f) (output-port? 1 1 #t #f) (current-input-port 1 1 #t #f) (current-output-port 1 1 #t #f) (read-char 1 1 #t #f) (peek-char 1 1 #t #f) (char-ready? 1 1 #t #f) (exit 0 0 #t #t) (gensym 0 1 #t #f) (apply 2 infinity #t #t) (primitive-name? 1 1 #t #f) (macroexpand-1 1 1 #t #f) (macroexpand 1 1 #t #f) (addr 1 1 #t #f) (entity-addr 1 1 #t #f) (undefined 0 0 #t #f) (step 1 1 #t #t) (vm2-step 1 1 #t #t) (vm1 1 1 #t #t) (vm2 1 1 #t #t) (dump 1 2 #t #t) (addr-prt 1 1 #t #t) (gbc 0 1 #t #t) (room 0 0 #t #f) (vmcode 1 1 #t #f) (env 1 1 #t #f) (timer-set 0 0 #t #t) (timer-get 0 0 #t #t) (timer-gbc 0 0 #t #t) (eval 1 1 #t #f) (load 1 1 #t #t) (error 2 2 #t #t) (flush 0 1 #t #t) (set-trace 0 infinity #t #t) (set-untrace 0 infinity #t #t) (current-module 0 0 #t #f) (transfer 1 1 #t #f) (debug 1 1 #t #t) (profiler 1 1 #t #t) (lambda/asm 2 2 #t #f) (values 0 infinity #t #t) (sys-cont-room 1 1 #t #t) (make-syntactic-clousre 3 3 #t #t) (symbol->identifier 1 1 #t #f) (identifier->symbol 1 1 #t #f) (syntactic-closure? 1 1 #t #f) (identifier? 1 1 #t #f) (identifier-bind! 2 2 #t #t) (identifier-free? 1 1 #t #f) (identifier-bound? 1 1 #t #f) (identifier-bound 1 1 #t #f) (global-bound? 1 1 #t #f) (inspect 0 0 #t #t)) 18 *primitive* 1)
(15 1 (12 1 3 0 0 2 ".scm" 17 string-append 2 15 1 (12 1 3 1 0 2 ".o" 17 string-append 2 15 1 (12 1 3 1 0 17 open-input-file 1 15 1 (12 1 3 1 0 17 open-output-file 1 15 1 (12 1 3 1 0 17 read 1 3 1 0 3 0 0 4 compile-file1 13 3 7 3 1 0 17 close-input-port 1 7 3 0 0 17 close-output-port 1 7 2 "compiled!" 17 display 1 7 17 flush 0 11) 13 1 11) 13 1 11) 13 1 11) 13 1 11) 18 compile-file 1)
(15 3 (12 3 3 0 0 17 eof-object? 1 10 5 2 #t 11 3 0 0 4 compile 13 1 4 assemble 13 1 3 0 2 17 write 2 7 3 0 2 17 newline 1 7 3 0 1 17 read 1 3 0 1 3 0 2 4 compile-file1 14 3) 18 compile-file1 1)
(2 1 2 ((args 1) (catch) (lvar 0 0) (call 1) (return)) 17 lambda/asm 2 18 ncall/cc 1)
(2 2 2 ((args 2) (lvar 0 0) (call 0) (adapt) (lvar 0 1) (call 0) (return)) 17 lambda/asm 2 18 call-with-values 1)
(2 () 18 winders 1)
(15 3 (12 3 3 0 0 13 0 7 3 0 0 3 0 2 36 4 winders 36 6 winders 7 3 0 1 13 0 15 1 (12 1 4 winders 35 6 winders 7 3 1 2 13 0 7 3 0 0 11) 13 1 11) 18 dynamic-wind 1)
(15 2 (12 2 3 0 0 17 reverse 1 3 0 1 17 reverse 1 4 common-tail1 13 2 17 reverse 1 11) 18 common-tail 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 1 17 null? 1 10 5 2 () 11 3 0 0 34 3 0 1 34 17 eq? 2 17 not 1 10 5 2 () 11 3 0 0 34 3 0 0 35 3 0 1 35 4 common-tail1 13 2 36 11) 18 common-tail1 1)
(15 1 (12 1 3 0 0 4 winders 4 common-tail 13 2 15 1 (12 1 4 winders 3 0 0 4 do-wind-after 13 2 7 3 1 0 17 reverse 1 3 0 0 17 reverse 1 4 do-wind-before 13 2 7 3 1 0 6 winders 11) 13 1 11) 18 do-wind 1)
(15 2 (12 2 3 0 0 3 0 1 17 equal? 2 10 5 2 #t 11 3 0 0 17 cdar 1 13 0 7 3 0 0 35 3 0 1 4 do-wind-after 14 2) 18 do-wind-after 1)
(15 2 (12 2 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 5 2 #t 11 3 0 1 17 null? 1 10 22 3 0 0 17 caar 1 13 0 7 3 0 0 35 3 0 1 4 do-wind-before 14 2 3 0 0 35 3 0 1 35 4 do-wind-before 14 2) 18 do-wind-before 1)
(15 1 (12 1 15 1 (12 1 4 winders 15 1 (12 1 15 -1 (12 -1 3 1 0 4 winders 17 eq? 2 17 not 1 10 12 3 1 0 4 do-wind 13 1 7 8 2 3 2 0 3 0 0 17 apply 2 11) 11) 13 1 3 1 0 13 1 11) 4 ncall/cc 13 1 11) 18 call/cc 1)
(4 call/cc 18 call-with-current-continuation 1)
(15 3 (12 3 3 0 0 3 0 1 3 0 2 2 () 4 match1 13 4 11) 18 match 1)
(15 4 (12 4 3 0 0 17 null? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 6 3 0 3 11 3 0 0 4 ellipsis? 13 1 10 66 3 0 0 17 cddr 1 3 0 1 3 0 0 17 cddr 1 17 length 1 4 list-take-right 13 2 3 0 2 3 0 0 34 3 0 1 3 0 1 17 length 1 3 0 0 17 cddr 1 17 length 1 17 - 2 4 list-take 13 2 36 3 0 3 36 4 match1 13 4 11 3 0 0 17 null? 1 10 13 3 0 1 17 null? 1 17 not 1 8 4 2 #f 10 5 2 #f 11 3 0 0 17 identifier? 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 13 3 0 0 3 0 1 36 17 list 1 11 3 0 0 17 null? 1 17 not 1 10 10 3 0 1 17 null? 1 8 4 2 #f 10 5 2 #f 11 3 0 0 34 17 atom? 1 10 34 3 0 0 34 3 0 2 17 memq 2 10 18 3 0 0 34 3 0 1 34 17 eq? 2 17 not 1 8 4 2 #f 8 4 2 #f 10 5 2 #f 11 3 0 0 34 17 atom? 1 10 31 3 0 0 35 3 0 1 35 3 0 2 3 0 0 34 3 0 1 34 36 3 0 3 36 4 match1 13 4 11 3 0 0 34 4 vec-ellipsis? 13 1 10 11 3 0 1 34 17 vector? 1 8 4 2 #f 10 39 3 0 0 35 3 0 1 35 3 0 2 3 0 0 34 2 0 17 vector-ref 2 3 0 1 34 17 vector->list 1 36 3 0 3 36 4 match1 13 4 11 3 0 0 4 ellipsises? 13 1 10 22 3 0 0 34 17 length 1 3 0 1 4 transpose 13 1 17 length 1 21 8 4 2 #f 10 15 3 0 1 4 transpose 13 1 15 1 (12 1 3 1 0 17 caar 1 3 0 0 34 36 3 1 0 17 cadar 1 3 0 0 17 cadr 1 36 17 list 2 3 1 3 17 append 2 11) 13 1 11 3 0 0 34 3 0 1 34 3 0 2 3 0 3 4 match1 13 4 3 0 0 35 3 0 1 35 3 0 2 3 0 3 4 match1 13 4 15 2 (12 2 3 0 0 10 7 3 0 1 8 4 2 #f 10 12 3 0 0 3 0 1 17 append 2 11 2 #f 11) 13 2 11) 18 match1 1)
(15 1 (12 1 2 *undef* 15 1 (12 1 15 2 (12 2 3 0 0 3 0 1 21 10 5 2 () 11 15 1 (12 1 3 0 0 3 1 0 17 list-ref 2 11) 3 2 0 4 map 13 2 3 0 0 27 3 0 1 3 1 0 13 2 36 11) 5 0 0 7 2 0 3 1 0 34 17 length 1 3 0 0 13 2 11) 13 1 11) 18 transpose 1)
(15 1 (12 1 3 0 0 17 list? 1 10 58 3 0 0 17 length 1 2 2 25 10 44 3 0 0 34 17 identifier? 1 10 11 3 0 0 34 17 identifier? 1 8 9 3 0 0 34 17 symbol? 1 10 14 3 0 0 17 cadr 1 2 ... 17 eqv? 2 11 2 #f 11 2 #f 11 2 #f 11) 18 ellipsis? 1)
(15 1 (12 1 3 0 0 17 list 1 10 40 3 0 0 17 length 1 2 2 25 10 26 3 0 0 34 17 list? 1 10 14 3 0 0 17 cadr 1 2 ... 17 eqv? 2 11 2 #f 11 2 #f 11 2 #f 11) 18 ellipsises? 1)
(15 1 (12 1 3 0 0 17 vector? 1 10 32 3 0 0 2 0 17 vector-ref 2 17 symbol? 1 10 16 3 0 0 2 1 17 vector-ref 2 2 ... 17 eq? 2 11 2 #f 11 2 #f 11) 18 vec-ellipsis? 1)
(15 2 (12 2 3 0 1 2 0 21 10 5 2 () 11 3 0 0 34 3 0 0 35 3 0 1 28 4 list-take 13 2 36 11) 18 list-take 1)
(15 2 (12 2 3 0 0 3 0 0 17 length 1 3 0 1 17 - 2 4 list-drop 13 2 11) 18 list-take-right 1)
(15 2 (12 2 3 0 1 2 0 21 10 6 3 0 0 11 3 0 0 35 3 0 1 28 4 list-drop 14 2) 18 list-drop 1)
(15 1 (12 1 3 0 0 2 fail 17 eq? 2 11) 18 fail? 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 symbol? 1 10 52 3 0 0 3 0 1 4 local-bound? 13 2 10 14 3 0 0 3 0 1 4 local-bound? 13 2 8 26 3 0 0 17 global-bound? 1 10 10 3 0 0 17 global-bound? 1 8 10 3 0 0 2 else 17 eq? 2 8 4 2 #f 10 15 3 0 0 17 symbol->identifier 1 3 0 0 17 identifier-bind! 2 11 3 0 0 17 symbol? 1 10 9 3 0 0 17 symbol->identifier 1 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 34 3 0 1 4 subst-to-identifier 13 2 3 0 0 35 3 0 1 4 subst-to-identifier 13 2 36 11) 18 subst-to-identifier 1)
(15 2 (12 2 3 0 1 17 null? 1 10 5 2 #f 11 3 0 0 3 0 1 34 17 member 2 10 5 2 #t 11 3 0 0 3 0 1 35 4 local-bound? 14 2) 18 local-bound? 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier? 1 10 13 3 0 0 3 0 1 17 assv 2 8 4 2 #f 10 19 3 0 0 3 0 0 3 0 1 17 assv 2 35 17 identifier-bind! 2 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 34 3 0 1 4 subst-pattern-vars 13 2 3 0 0 35 3 0 1 4 subst-pattern-vars 13 2 36 11) 18 subst-pattern-vars 1)
(15 1 (12 1 3 0 0 3 0 0 2 () 4 scan-let-vars 13 2 4 subst-let-vars1 13 2 11) 18 subst-let-vars 1)
(15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier? 1 10 25 3 0 0 17 identifier-free? 1 10 13 3 0 0 3 0 1 17 assv 2 8 4 2 #f 8 4 2 #f 10 19 3 0 0 3 0 0 3 0 1 17 assv 2 35 17 identifier-bind! 2 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 34 3 0 1 4 subst-let-vars1 13 2 3 0 0 35 3 0 1 4 subst-let-vars1 13 2 36 11) 18 subst-let-vars1 1)
(15 2 (12 2 3 0 0 17 null? 1 10 12 15 1 (12 1 3 0 0 17 gensym 0 36 11) 3 0 1 4 map 14 2 3 0 0 17 atom? 1 10 5 2 () 11 3 0 0 4 lambda? 13 1 10 13 3 0 0 17 cadr 1 17 atom? 1 8 4 2 #f 10 22 3 0 0 17 cddr 1 3 0 0 17 cadr 1 3 0 1 36 4 scan-let-vars 14 2 3 0 0 4 lambda? 13 1 10 31 3 0 0 17 cadr 1 17 list? 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 8 4 2 #f 10 24 3 0 0 17 cddr 1 3 0 0 17 cadr 1 3 0 1 17 append 2 4 scan-let-vars 14 2 3 0 0 4 lambda? 13 1 10 31 3 0 0 17 cadr 1 17 pair? 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 8 4 2 #f 10 22 3 0 0 17 caddr 1 3 0 0 17 cadr 1 4 pair->list 13 1 4 scan-let-vars 14 2 3 0 0 4 let? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 let*? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 letrec? 13 1 10 16 3 0 0 17 cadr 1 17 null? 1 17 not 1 8 4 2 #f 10 23 3 0 0 17 cddr 1 3 0 0 17 cadr 1 4 transpose 13 1 34 4 scan-let-vars 14 2 3 0 0 4 named-let? 13 1 10 16 3 0 0 17 caddr 1 17 null? 1 17 not 1 8 4 2 #f 10 36 3 0 0 17 cdddr 1 3 0 0 17 caddr 1 4 transpose 13 1 34 3 0 0 17 cadr 1 3 0 1 36 17 append 2 4 scan-let-vars 14 2 3 0 0 35 3 0 1 4 scan-let-vars 14 2) 18 scan-let-vars 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 lambda 17 eqv? 2 11 2 #f 11 2 #f 11) 18 lambda? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 43 3 0 0 17 length 1 2 3 25 10 29 3 0 0 34 2 let 17 eqv? 2 10 15 3 0 0 17 cadr 1 17 identifier? 1 17 not 1 11 2 #f 11 2 #f 11 2 #f 11) 18 let? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 40 3 0 0 17 length 1 2 4 25 10 26 3 0 0 34 2 let 17 eqv? 2 10 12 3 0 0 17 cadr 1 17 identifier? 1 11 2 #f 11 2 #f 11 2 #f 11) 18 named-let? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 letrec 17 eqv? 2 11 2 #f 11 2 #f 11) 18 letrec? 1)
(15 1 (12 1 3 0 0 17 list? 1 10 26 3 0 0 17 length 1 2 3 25 10 12 3 0 0 34 2 let* 17 eqv? 2 11 2 #f 11 2 #f 11) 18 let*? 1)
(15 1 (12 1 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 17 identifier-free? 1 10 6 3 0 0 11 3 0 0 17 identifier? 1 10 9 3 0 0 17 identifier-bound 1 11 3 0 0 17 atom? 1 10 6 3 0 0 11 3 0 0 17 vector? 1 10 6 3 0 0 11 3 0 0 17 length 1 2 2 21 10 11 3 0 0 4 ellipsis? 13 1 8 4 2 #f 10 10 3 0 0 34 17 identifier-bound 1 11 3 0 0 17 length 1 2 2 24 10 17 3 0 0 2 2 4 list-take 13 2 4 ellipsis? 13 1 8 4 2 #f 10 23 3 0 0 34 17 identifier-bound 1 3 0 0 17 cddr 1 4 subst-from-identifier 13 1 17 append 2 11 3 0 0 34 4 subst-from-identifier 13 1 3 0 0 35 4 subst-from-identifier 13 1 36 11) 18 subst-from-identifier 1)
(15 3 (12 3 3 0 0 3 0 2 4 subst-to-identifier 13 2 3 0 1 4 subst-pattern-vars 13 2 4 subst-let-vars 13 1 4 subst-from-identifier 13 1 11) 18 expand-template 1)
(15 4 (12 4 3 0 0 17 caar 1 15 1 (12 1 3 1 0 17 cadar 1 15 1 (12 1 3 1 0 3 2 1 3 2 2 4 match 13 3 15 1 (12 1 3 0 0 10 15 3 1 0 3 0 0 3 3 3 4 expand-template 14 3 3 3 0 35 17 null? 1 10 11 2 "syntax-rules fail " 3 3 1 17 error 2 11 3 3 0 35 3 3 1 3 3 2 3 3 3 4 expand 14 4) 13 1 11) 13 1 11) 13 1 11) 18 expand 1)
(15 -3 (12 -3 17 undefined 0 17 undefined 0 15 2 (12 2 15 1 (12 1 3 0 0 17 null? 1 10 5 2 () 11 3 0 0 34 3 2 0 13 1 3 0 0 35 3 1 0 13 1 36 11) 5 0 0 7 15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 2 0 3 0 0 34 4 car 3 0 1 4 map 13 2 17 apply 3 3 0 0 35 4 cdr 3 0 1 4 map 13 2 3 1 1 13 2 36 11) 5 0 1 7 3 1 2 17 null? 1 10 10 3 1 1 3 0 0 14 1 3 1 1 3 1 2 3 0 1 14 2) 13 2 11) 18 map 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 5 2 #t 11 3 0 0 35 17 null? 1 10 7 3 0 0 34 11 2 if 3 0 0 34 2 and 3 0 0 35 2 () 17 append 2 36 2 #f 2 () 36 36 36 36 11) 19 and 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 5 2 #f 11 3 0 0 35 17 null? 1 10 7 3 0 0 34 11 2 if 3 0 0 34 3 0 0 34 2 or 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 11) 19 or 1)
(15 -2 (12 -2 3 0 0 17 null? 1 10 20 2 lambda 2 () 3 0 1 2 () 17 append 2 36 36 2 () 36 11 3 0 0 17 pair? 1 10 39 2 lambda 4 car 3 0 0 4 map 13 2 3 0 1 2 () 17 append 2 36 36 4 cadr 3 0 0 4 map 13 2 2 () 17 append 2 36 11 2 letrec 3 0 0 2 lambda 4 car 3 0 1 34 4 map 13 2 3 0 1 35 2 () 17 append 2 36 36 2 () 36 36 2 () 36 3 0 0 4 cadr 3 0 1 34 4 map 13 2 2 () 17 append 2 36 2 () 36 36 36 11) 19 let 1)
(15 -2 (12 -2 3 0 0 17 null? 1 10 20 2 lambda 2 () 3 0 1 2 () 17 append 2 36 36 2 () 36 11 3 0 0 35 17 null? 1 10 22 2 let 3 0 0 34 2 () 36 3 0 1 2 () 17 append 2 36 36 11 2 let 3 0 0 34 2 () 36 2 let* 3 0 0 35 3 0 1 2 () 17 append 2 36 36 2 () 36 36 36 11) 19 let* 1)
(15 -2 (12 -2 4 car 3 0 0 4 map 13 2 4 cadr 3 0 0 4 map 13 2 15 2 (12 2 2 let 15 1 (12 1 3 0 0 2 quote 2 *undef* 2 () 36 36 2 () 36 36 11) 3 0 0 4 map 13 2 15 2 (12 2 2 set! 3 0 0 3 0 1 2 () 36 36 36 11) 3 0 0 3 0 1 4 map 13 3 3 1 1 2 () 17 append 2 17 append 2 36 36 11) 13 2 11) 19 letrec 1)
(15 -1 (12 -1 3 0 0 17 null? 1 10 8 2 undefined 2 () 36 11 3 0 0 17 cdar 1 17 null? 1 10 49 2 let 2 *val* 3 0 0 17 caar 1 2 () 36 36 2 () 36 2 if 2 *val* 2 *val* 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 2 () 36 36 36 11 3 0 0 17 cadar 1 2 => 17 eq? 2 10 46 2 let 2 *val* 3 0 0 17 caar 1 2 () 36 36 2 () 36 2 if 2 *val* 3 0 0 17 caddar 1 2 *val* 2 () 36 36 2 () 36 36 36 2 () 36 36 36 11 3 0 0 17 caar 1 2 else 17 eqv? 2 10 36 3 0 0 17 cdar 1 4 length=1? 13 1 10 9 3 0 0 17 cadar 1 11 2 begin 3 0 0 17 cdar 1 2 () 17 append 2 36 11 3 0 0 17 cdar 1 4 length=1? 13 1 10 37 2 if 3 0 0 17 caar 1 3 0 0 17 cdar 1 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 17 append 2 36 36 11 2 if 3 0 0 17 caar 1 2 begin 3 0 0 17 cdar 1 2 () 17 append 2 36 2 cond 3 0 0 35 2 () 17 append 2 36 2 () 36 36 36 36 11) 19 cond 1)
(15 -2 (12 -2 3 0 1 17 null? 1 10 8 2 undefined 2 () 36 11 3 0 1 17 caar 1 2 else 17 eq? 2 10 17 2 begin 3 0 1 17 cdar 1 2 () 17 append 2 36 11 2 if 2 memv 3 0 0 2 quote 3 0 1 17 caar 1 2 () 36 36 2 () 36 36 36 2 begin 3 0 1 17 cdar 1 2 () 17 append 2 36 2 case 3 0 0 3 0 1 35 2 () 17 append 2 36 36 2 () 36 36 36 36 11) 19 case 1)
(15 -3 (12 -3 4 car 3 0 0 4 map 13 2 4 cadr 3 0 0 4 map 13 2 4 cddr 3 0 0 4 map 13 2 15 3 (12 3 2 letrec 2 loop 2 lambda 3 0 0 2 if 3 1 1 34 2 begin 3 1 1 35 2 () 17 append 2 36 2 begin 3 1 2 2 loop 15 2 (12 2 3 0 0 17 null? 1 10 6 3 0 1 11 3 0 0 34 11) 3 0 2 3 0 0 4 map 13 3 2 () 17 append 2 36 2 () 36 17 append 2 36 2 () 36 36 36 36 2 () 36 36 36 2 () 36 36 2 () 36 2 loop 3 0 1 2 () 17 append 2 36 2 () 36 36 36 11) 13 3 11) 19 do 1)
(15 -3 (12 -3 2 *undef* 15 1 (12 1 15 2 (12 2 3 0 0 17 null? 1 10 5 2 () 11 3 2 0 3 0 0 34 4 car 3 0 1 4 map 13 2 17 apply 3 7 3 0 0 35 4 cdr 3 0 1 4 map 13 2 3 1 0 14 2) 5 0 0 7 3 1 1 3 1 2 3 0 0 13 2 11) 13 1 7 17 undefined 0 11) 18 for-each 1)
;;––”öÄ‹AÅ“K‰»ƒRƒ“ƒpƒCƒ‰
;;has-lambda? “ü‚êq‚Ìlambda®‚ğ‚à‚Â‚©‚Ç‚¤‚©B
;;in-lambda?@lambda®‚Ì’†‚Ì®‚©‚Ç‚¤‚©H
;;tail?@––”öÄ‹AÅ“K‰»‚ğ‚·‚é‚×‚«‚©‚Ç‚¤‚©H
;;define-macro‚Ì‚Æ‚«‚É‚Í#f‚É‚·‚éB
;;--------------------------------- 


(define (compile x)
  (append (comp (transfer x) '() #t #t #f #f #t #f) (list (list 'halt))))


(define (comp x env val? more? has-lambda? in-lambda? tail? if?)
  (cond ((null? x) (comp-const x val? more? in-lambda?))
        ((boolean? x) (comp-const x val? more? in-lambda?))
        ((symbol? x) (comp-var x env val? more? in-lambda?))
        ((identifier-free? x) (comp-var x env val? more? in-lambda?))
        ((atom? x ) (comp-const x val? more? in-lambda?))
        ((vector? x) (comp-const x val? more? in-lambda?))
        ((macro-name? (car x))
         (comp (macroexpand-1 x) env val? more? has-lambda? in-lambda? tail? if?))
        ((hygienic-name? (car x))
         (comp (macroexpand-1 x) env val? more? has-lambda? in-lambda? tail? if?))
        ((eqv? (car x) 'quote)
         (args-count-check x 1 1)
         (comp-const (cadr x) val? more? in-lambda?))
        ((eqv? (car x) 'begin)
         (comp-begin (cdr x) env val? more? has-lambda? in-lambda? tail? if?))
        ((eqv? (car x) 'set!)
         (args-count-check x 2 2)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? tail? if?)
              (gen-set (cadr x) env)
              (if (not val?) (gen 'pop) '())
              (if (not more?) (gen 'return) '())))
        ((eqv? (car x) 'if)
         (if (= (length x) 3) (set! x (append x '((undefined)))) (undefined))
         (args-count-check x 3 3)
         (comp-if (cadr x) (caddr x) (cadddr x)
                  env val? more? has-lambda? in-lambda? tail? #t))
        ((eqv? (car x) 'lambda)
         (if val?
             (let ((f (comp-lambda (cadr x) (cddr x) env tail? if?)))
               (seq (gen 'fn (args-count (cadr x))f)
                    (if (not more?) (gen 'return) '())))
             #f))
        ((eqv? (car x) 'define)
         (args-type-check x 1 symbol? "require symbol ")
         (args-type-check x 1 (lambda (y) (not (primitive-name? y)))
                          "can't overwrite primitive name ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? tail? if?) 
              (gen 'def (cadr x))))
        ((eqv? (car x) 'define-macro)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? #f if?)
              (gen 'defm (cadr x))))
        ((eqv? (car x) 'define-syntax)
         (args-type-check x 1 symbol? "require symbol ")
         (seq (comp (caddr x) env #t #t has-lambda? in-lambda? #f if?)
              (gen 'defh (cadr x) env)))
        ((eqv? (car x) 'define-library)
         (args-count-check x 2 'infinity)
         (args-type-check x 1 list? "require list for library name")
         (seq (gen 'deflib (cadr x) (cddr x))
              (gen 'const (cadr x))))
        ((eqv? (car x) 'export)
         (args-count-check x 1 'infinity)
         (seq (gen 'explib (cdr x))))
        ((eqv? (car x) 'import)
         (args-count-check x 1 'infinity)
         (seq (gen 'implib (cdr x))))
        ((eqv? (car x) 'math)
         (comp (infix->prefix (cdr x)) env val? more? has-lambda? in-lambda? tail? if?))
        ((eqv? (car x) 'syntax-rules)
         (comp `(lambda (expr comp-env vm-env) (expand ',(cddr x) expr ,(cadr x) comp-env))
               env val? more? has-lambda? in-lambda? tail? if?))
        (else
          (comp-funcall (car x) (cdr x) env val? more? has-lambda? in-lambda? tail? if?))))


(define (comp-const x val? more? in-lambda?)
  (if val? 
      (seq (gen 'const x)
           (if (and (not more?) in-lambda?)
               (gen 'return)
               '()))
      '()))

(define (comp-var x env val? more? in-lambda?)
  (if val?
      (seq (gen-var x env)
           (if (and (not more?) in-lambda?)
               (gen 'return)
               '()))
      '()))

(define (comp-begin exps env val? more? has-lambda? in-lambda? tail? if?)
  (cond ((null? exps) (comp-const '() val? more? in-lambda?))
        ((length=1? exps) (comp (transfer (car exps)) env val? #f has-lambda? in-lambda? tail? if?))
        (else (seq (comp (transfer (car exps)) env #f #t has-lambda? in-lambda? tail? if?)
                   (comp-begin  (cdr exps) env val? more? has-lambda? in-lambda? tail? if?)))))


(define (comp-list exps env has-lambda? in-lambda? tail? if?)
  (if (null? exps)
      '()
      (seq (comp (car exps) env #t #t has-lambda? in-lambda? tail? if?)
           (comp-list (cdr exps) env has-lambda? in-lambda? tail? if?))))

(define (comp-if pred then else env val? more? has-lambda? in-lambda? tail? if?)
  (cond ((not pred)
         (comp else env val? more? has-lambda? in-lambda? tail? if?))
        ((and (atom? pred) (not (symbol? pred)) (not (not pred)))
         (comp then env val? more? has-lambda? in-lambda? tail? if?))
        ((and (list? pred)
              (length=1? (cdr pred))
              (eq? (car pred) 'not))
         (comp-if (cadr pred) else then env val? more? has-lambda? in-lambda? tail? if?))
        (else 
          (let ((pcode (comp pred env #t #t has-lambda? in-lambda? tail? if?))
                (tcode (comp then env val? more? has-lambda? in-lambda? tail? if?))
                (ecode (comp else env val? more? has-lambda? in-lambda? tail? if?)))
            (cond ((equal? tcode ecode)
                   (seq (comp pred env #f #t has-lambda? in-lambda? tail? if?) ecode))
                  ((not tcode)
                   (let ((L2 (gen-label)))
                     (seq pcode (gen 'tjump L2) ecode (list L2)
                          (if (not more?) (gen 'return) '()))))
                  (else
                    (let ((L1 (gen-label))
                          (L2 (if more? (gen-label) #f)))
                      (seq pcode (gen 'fjump L1) tcode
                           (if more? (gen 'jump L2) '())
                           (list L1) ecode (if more? (list L2) '())))))))))

(define (comp-funcall f args env val? more? has-lambda? in-lambda? tail? if?)
  (if (and (not (symbol? f)) (not (list? f))) (error "illegal function call " f))
  (let ((prim (primitive? f env)))
    (cond (prim
            (args-count-check (cons f args) (prim-min prim) (prim-max prim))
            (cond ((and (not val?) (not (prim-side-effect? prim)))
                   (comp-begin args env #f more? has-lambda? in-lambda? tail? if?))
                  ((and (memv f '(= < <= > >=))(= (length args) 2));;2€”äŠr‰‰Zq
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen (cadr (assv f binomial-op)))
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eqv? f 'zero?)(= (length args) 1));;(zero? n)->(zerop)
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen 'zerop)
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eqv? f '-)(= (length args) 2)
                        (or (eq? (cadr args) 1) (eq? (cadr args) 2))) ;;(- x 1or2)->(sub1or2)
                   (seq (comp-list (butlast args) env has-lambda? in-lambda? tail? if?)
                        (if (= (cadr args) 1) (gen 'sub1) (gen 'sub2))
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((and (eqv? f '+)(= (length args) 2)
                        (or (eq? (cadr args) 1) (eq? (cadr args) 2))) ;;(+ x 1or2)->(add1or2)
                   (seq (comp-list (butlast args) env has-lambda? in-lambda? tail? if?)
                        (if (= (cadr args) 1) (gen 'add1) (gen 'add2))
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((eqv? f 'car)
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen 'car)
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((eqv? f 'cdr)
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen 'cdr)
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  ((eqv? f 'cons)
                   (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                        (gen 'cons)
                        (if (not val?) (gen 'pop) '())
                        (if (and (not more?) in-lambda?) (gen 'return) '())))
                  (else (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                             (gen 'prim f (length args))
                             (if (not val?) (gen 'pop) '())
                             (if (and (not more?) in-lambda?) (gen 'return) '())))))
          ((and (list? f) (eqv? (car f) 'lambda) (null? (cadr f)))
           (if (not (null? args)) (error "too many arguments: " args) '())
           (comp-begin (cddr f) env val? more? has-lambda? #f tail? if?))
          ((and (not more?)(not has-lambda?) tail? if?)
           (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                (comp f env #t #t has-lambda? in-lambda? tail? if?)
                (gen 'callj (length args))))
          ((eqv? f 'call/cc)
           (seq (comp-list args env has-lambda? in-lambda? #f if?)
                (comp f env #t #t has-lambda? in-lambda? tail? if?)
                (gen 'call (length args))
                (if (not val?) (gen 'pop) '())
                (if (not more?) (gen 'return) '())))
          (else
            (seq (comp-list args env has-lambda? in-lambda? tail? if?)
                 (comp f env #t #t has-lambda? in-lambda? tail? if?)
                 (gen 'call (length args))
                 (if (not val?) (gen 'pop) '())
                 (if (not more?) (gen 'return) '()))))))


(define binomial-op
  '((= neqp) (< smlp) (<= esmlp)
    (> grtp) (>= egrtp)))


(define (prim-always? x)
  (cadddr x))

(define (prim-side-effect? x)
  (cadr (cdddr x)))

(define (prim-min x)
  (cadr x))

(define (prim-max x)
  (caddr x))


(define (primitive? x env)
  (and (not (in-env? x env))
       (assoc x *primitive*)))

;;macro‚Å‚Ítail?=#f‚É‚µ‚Ä––”öÄ‹AÅ“K‰»‚Í‚µ‚È‚¢B
(define (comp-lambda args body env tail? if?)
  (if tail?
      (seq (gen 'args (args-count args))
           (comp-begin body
                       (cons args env) #t #t 
                       (inner-lambda? (macroexpand body)) #t tail? if?))
      (seq (gen 'args (args-count args))
           (comp-begin body
                       (cons args env) #t #t #f #t tail? if?))))


(define (args-count x)
  (cond ((symbol? x) -1)
        ((list? x)(length x))
        (else (- (pair-length x)))))

(define (length=1? x)
  (and (list? x)
       (= (length x) 1)))

(define (mappend proc x)
  (if (null? x)
      '()
      (append (proc (car x)) (mappend proc (cdr x)))))

(define (lambda-args? x)
  (cond ((null? x) #t)
        ((symbol? x) #t)
        ((atom? x) #f)
        ((not (symbol? (car x))) #f)
        (else (lambda-args? (cdr x)))))

(define (symbol-or-list? x)
  (or (symbol? x)
      (list? x)))

(define (args-count-check x min max)
  (let ((n (length (cdr x))))
    (cond ((and (>= n min) (eq? max 'infinity)) #t)
          ((and (>= n min) (<= n max)) #t)
          (else (error "incorrect argument count " x)))))

(define (args-type-check x n pred msg)
  (if (pred (list-ref x n))
      #t
      (error msg x)))

(define (gen opcode . args)
  (list (cons opcode args)))

(define (gen-var var env)
  (let ((p (in-env? var env)))
    (cond (p (gen 'lvar (car p) (cadr p)))
          ((identifier-free? var) (gen 'gvar (identifier->symbol var)))
          (else (gen 'gvar var)))))

(define (gen-set var env)
  (let ((p (in-env? var env)))
    (if p
        (gen 'lset (car p) (cadr p))
        (gen 'gset var))))

(define (seq . code)
  (apply append code))

(define (gen-label)
  (gensym "L"))

(define (label? x)
  (and (symbol? x)
       (char=? (string-ref (symbol->string x) 2) #\L)))


(define (in-env? symbol env)
  (in-env-iter symbol env 0))

(define (in-env-iter symbol env i)
  (cond ((null? env) #f)
        ((in-args? symbol (car env)) (list i (nth-args symbol (car env))))
        (else (in-env-iter symbol (cdr env) (+ i 1)))))

(define (in-args? symbol args)
  (cond ((null? args) #f)
        ((and (symbol? args) (eq? symbol args)) #t)
        ((symbol? args) #f)
        ((eq? symbol (car args)) #t)
        (else (in-args? symbol (cdr args)))))


(define (nth-args symbol args)
  (cond ((and (symbol? args) (eq? symbol args)) 0)
        ((eq? symbol (car args)) 0)
        (else (+ 1 (nth-args symbol (cdr args))))))


(define (inner-lambda? x)
  (cond ((null? x) #f)
        ((atom? x) #f)
        ((vector? x) #f)
        ((eq? (car x) 'lambda) #t)
        (else (or (inner-lambda? (car x))
                  (inner-lambda? (cdr x))))))


;;“à‘}•\Œ»‚©‚ç‘O’u•\Œ»‚Ö•ÏŠ·‚·‚éB

(define (arg1 f)
  (cadr f))

(define (arg2 f)
  (caddr f))

(define (arg3 f)
  (cadddr f))

(define (op f)
  (car f))


(define (opcode op)
  (case op
        ((+) '+)((-) '-)((/) '/)((*) '*)((^) '^)
        ((sin) 'sin)((cos) 'cos)((exp) 'exp)((log) 'log)
        ((sinh) 'sinh)((cosh) 'cosh)
        (else (error "opecode else: " op))))

(define (weight op)
  (case op
        ((+) 1)((-) 1)((/) 2)((*) 3)((^) 4)
        ((sin) 6)((cos) 6)((exp) 6)((log) 6)
        ((cosh) 6)((sinh) 6)
        (else 9)))

(define (infix->prefix fmla)
  (infip fmla))

(define (infip fmla)
  (if (atom? fmla) fmla (inf1 fmla '() '())))

(define (inf1 fmla optr opln)
  (if (or (< (weight (op fmla)) 5)
          (> (weight (op fmla)) 7))
      (inf2 (cdr fmla) optr (cons (infip (car fmla)) opln))
      (inf3 (cddr fmla)
            optr
            (cons (list (op fmla) (infip (arg1 fmla))) opln))))

(define (inf2 fmla optr opln)
  (cond ((and (null? fmla) (null? optr))
         (car opln))
        ((and (not (null? fmla))
              (or (null? optr)
                  (> (weight (car fmla))
                     (weight (car optr)))))
         (inf1 (cdr fmla) (cons (car fmla) optr) opln))
        (else (inf2 fmla
                    (cdr optr)
                    (cons (list (opcode (car optr))
                                (cadr opln)
                                (car opln))
                          (cddr opln))))))

(define (inf3 fmla optr opln)
  (cond ((and (null? fmla) (null? opln))
         (car opln))
        ((and (not (null? fmla))
              (or (null? optr)
                  (> (weight (car fmla))
                     (weight (cadr fmla)))))
         (inf1 (cdr fmla) (cons (car fmla) optr) opln))
        (else (inf2 fmla optr opln)))) ;Œ´’˜C³




;;ƒAƒZƒ“ƒuƒ‰

(define (assemble ls)
  (pass2 ls (pass1 ls))) 


(define (pass1 x)
  (pass1-iter x 1 '()))

(define (pass1-iter ls pc labels)
  (cond ((null? ls) labels)
        ((label? (car ls))
         (pass1-iter (cdr ls) pc (cons (cons (car ls) pc) labels)))
        (else
          (pass1-iter (cdr ls) (+ pc (op-count (car ls))) labels))))

(define (pass2 x labels)
  (pass2-iter x 1 '() labels))

(define (pass2-iter ls pc obj labels)
  (cond ((null? ls) (reverse obj))
        ((label? (car ls)) (pass2-iter (cdr ls) pc obj labels))
        (else
          (pass2-iter (cdr ls)
                      (+ pc (op-count (car ls)))
                      (append (reverse (mnemonic->code (car ls) labels pc))
                              obj)
                      labels))))

(define (mnemonic->code x labels pc)
  (cond ((eqv? (car x) 'halt) (list (op-code (car x))))
        ((eqv? (car x) 'const) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'lvar) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'gvar) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'lset) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'gset) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'pop) (list (op-code (car x))))
        ((eqv? (car x) 'jump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
        ((eqv? (car x) 'tjump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
        ((eqv? (car x) 'fjump) (list (op-code (car x)) (- (cdr (assq (cadr x) labels)) pc)))
        ((eqv? (car x) 'return) (list (op-code (car x))))
        ((eqv? (car x) 'args) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'call) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'callj) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'fn) (list (op-code (car x)) (cadr x) (assemble (caddr x))))
        ((eqv? (car x) 'save) (list (op-code (car x))))
        ((eqv? (car x) 'prim) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'def) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'defm) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'defh) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'neqp) (list (op-code (car x))))
        ((eqv? (car x) 'smlp) (list (op-code (car x))))
        ((eqv? (car x) 'esmlp) (list (op-code (car x))))
        ((eqv? (car x) 'grtp) (list (op-code (car x))))
        ((eqv? (car x) 'egrtp) (list (op-code (car x))))
        ((eqv? (car x) 'zerop) (list (op-code (car x))))
        ((eqv? (car x) 'add1) (list (op-code (car x))))
        ((eqv? (car x) 'sub1) (list (op-code (car x))))
        ((eqv? (car x) 'add2) (list (op-code (car x))))
        ((eqv? (car x) 'sub2) (list (op-code (car x))))
        ((eqv? (car x) 'gref) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'catch) (list (op-code (car x))))
        ((eqv? (car x) 'pause) (list (op-code (car x))))
        ((eqv? (car x) 'car) (list (op-code (car x))))
        ((eqv? (car x) 'cdr) (list (op-code (car x))))
        ((eqv? (car x) 'cons) (list (op-code (car x))))
        ((eqv? (car x) 'adapt) (list (op-code (car x))))
        ((eqv? (car x) 'deflib) (list (op-code (car x)) (cadr x) (caddr x)))
        ((eqv? (car x) 'explib) (list (op-code (car x)) (cadr x)))
        ((eqv? (car x) 'implib) (list (op-code (car x)) (cadr x)))))

(define (op-count x) 
  (length x))


(define (op-code? x)
  (member x mnemonic))

(define (op-code x)
  (- (length mnemonic) (length (member x mnemonic))))


(define mnemonic 
  (list 'nop 'halt 'const 'lvar 'gvar 'lset 'gset 'pop 'jump 'tjump 'fjump
        'return 'args 'call 'callj 'fn 'save 'prim 'def 'defm 'defh
        'neqp 'smlp 'esmlp 'grtp 'egrtp 'zerop 
        'add1 'sub1 'add2 'sub2 'gref 'catch 'pause 'car 'cdr 'cons 'adapt
        'deflib 'explib 'implib))

;;(symbol-name args-min args-max always side-effect)
(define *primitive*
  '((car 1 1 #t #f)
    (cdr 1 1 #t #f)
    (cons 2 2 #t #f)
    (caar 1 1 #t #f)
    (cdar 1 1 #t #f)
    (cddr 1 1 #t #f)
    (cadr 1 1 #t #f)
    (caaar 1 1 #t #f)
    (cdaar 1 1 #t #f)
    (cadar 1 1 #t #f)
    (caadr 1 1 #t #f)
    (cddar 1 1 #t #f)
    (caddr 1 1 #t #f)
    (cdadr 1 1 #t #f)
    (cdddr 1 1 #t #f)
    (caaaar 1 1 #t #f)
    (cdaaar 1 1 #t #f)
    (cadaar 1 1 #t #f)
    (caadar 1 1 #t #f)
    (caaadr 1 1 #t #f)
    (cddaar 1 1 #t #f)
    (caddar 1 1 #t #f)
    (caaddr 1 1 #t #f)
    (cdaadr 1 1 #t #f)
    (cdadar 1 1 #t #f)
    (cadddr 1 1 #t #f)
    (cdaddr 1 1 #t #f)
    (cddadr 1 1 #t #f)
    (cdddar 1 1 #t #f)
    (cddddr 1 1 #t #f)
    (assq 2 2 #t #f)
    (assv 2 2 #t #f)
    (assoc 2 2 #t #f)
    (memq 2 2 #t #f)
    (memv 2 2 #t #f)
    (member 2 2 #t #f)
    (reverse 1 1 #t #f)
    (reverse! 1 1 #t #t)
    (list-tail 1 1 #t #f)
    (list-ref 2 2 #t #f)
    (append 2 2 #t #f)
    (append! 2 infinity #t #ft)
    (set-car! 2 2 #t #f)
    (set-cdr! 2 2 #t #f)
    (list 0 infinity #t #f)
    (make-list 1 2 #t #f)
    (length 1 1 #t #f)
    (pair-length 1 1 #t #f)
    (last 1 1 #t #f)
    (butlast 1 1 #t #f)
    (newline 0 1 #t #t)
    (display 1 2 #t #t)
    (write 1 2 #t #t)
    (write-char 1 1 #t #t)
    (null? 1 1 #t #f)
    (list? 1 1 #t #f)
    (pair? 1 1 #t #f)
    (atom? 1 1 #t #f)
    (eq? 1 infinity #t #f)
    (eqv? 1 infinity #t #f)
    (equal? 1 infinity #t #f)
    (boolean? 1 1 #t #f)
    (procedure? 1 1 #t #f)
    (number? 1 1 #t #f)
    (integer? 1 1 #t #f)
    (real? 1 1 #t #f)
    (rational? 1 1 #t #f)
    (complex? 1 1 #t #f)
    (exact? 1 1 #t #f)
    (inexact? 1 1 #t #f)
    (symbol? 1 1 #t #f)
    (string? 1 1 #t #f)
    (char? 1 1 #t #f)
    (bignum? 1 1 #t #f)
    (vector? 1 1 #t #f)
    (macro? 1 1 #t #f)
    (macro-name? 1 1 #t #f)
    (hygienic-name? 1 1 #t #f)
    (zero? 1 1 #t #f)
    (+ 0 infinity #t #f)
    (- 1 infinity #t #f)
    (* 0 infinity #t #f)
    (/ 1 infinity #t #f)
    (< 2 infinity #t #f)
    (<= 2 infinity #t #f)
    (> 2 infinity #t #f)
    (>= 2 infinity #t #f)
    (= 2 infinity #t #f)
    (sin 1 1 #t #f)
    (cos 1 1 #t #f)
    (tan 1 1 #t #f)
    (asin 1 1 #t #f)
    (acos 1 1 #t #f)
    (atan 1 2 #t #f)
    (log 1 1 #t #f)
    (exp 1 1 #t #f)
    (sqrt 1 1 #t #f)
    (expt 2 2 #t #f)
    (not 1 1 #t #f)
    (odd? 1 1 #t #f)
    (even? 1 1 #t #f)
    (floor 1 1 #t #f)
    (ceiling 1 1 #t #f)
    (truncate 1 1 #t #f)
    (round 1 1 #t #f)
    (numerator 1 1 #t #f)
    (denominator 1 1 #t #f)
    (positive? 1 1 #t #f)
    (negative? 1 1 #t #f)
    (abs 1 1 #t #f)
    (max 1 infinity #t #f)
    (min 1 infinity #t #f)
    (real-part 1 1 #t #f)
    (imag-part 1 1 #t #f)
    (magnitude 1 1 #t #f)
    (angle 1 1 #t #f)
    (make-rectangular 2 2 #t #f)
    (make-polar 2 2 #t #f)
    (exact->inexact 1 1 #t #f)
    (inexact->exact 1 1 #t #f)
    (remainder 2 2 #t #f)
    (modulo 2 2 #t #f)
    (quotient 2 2 #t #f)
    (gcd 0 2 #t #f)
    (lcm 0 2 #t #f)
    (char=? 2 2 #t #f)
    (char>? 2 2 #t #f)
    (char>=? 2 2 #t #f)
    (char<? 2 2 #t #f)
    (char<=? 2 2 #t #f)
    (char-ci=? 2 2 #t #f)
    (char-ci>? 2 2 #t #f)
    (char-ci>=? 2 2 #t #f)
    (char-ci<? 2 2 #t #f)
    (char-ci<=? 2 2 #t #f)
    (char-alphabetic? 1 1 #t #f)
    (char-numeric? 1 1 #t #f)
    (char-whitespace? 1 1 #t #f)
    (char-upper-case? 1 1 #t #f)
    (char-lower-case? 1 1 #t #f)
    (char->integer 1 1 #t #f)
    (integer->char 1 1 #t #f)
    (char-upcase 1 1 #t #f)
    (char-downcase 1 1 #t #f)
    (string-append 1 infinity #t #f)
    (number->string 1 2 #t #f)
    (string->number 1 2 #t #f)
    (string=? 1 1 #t #f)
    (string>? 1 1 #t #f)
    (string>=? 1 1 #t #f)
    (string<? 1 1 #t #f)
    (string<=? 1 1 #t #f)
    (string-ci=? 1 1 #t #f)
    (string-ci>? 1 1 #t #f)
    (string-ci>=? 1 1 #t #f)
    (string-ci<? 1 1 #t #f)
    (string-ci<=? 1 1 #t #f)
    (string->symbol 1 1 #t #f)
    (symbol->string 1 1 #t #f)
    (string-length 1 1 #t #f)
    (make-string 1 1 #t #f)
    (string 1 1 #t #f)
    (string-ref 2 2 #t #f)
    (string-set! 2 2 #t #t)
    (substring 1 1 #t #f)
    (string->list 1 1 #t #f)
    (list->string 1 1 #t #f)
    (string-copy 1 1 #t #f)
    (string-fill! 1 1 #t #t)
    (make-vector 2 2 #t #f)
    (vector-set! 3 3 #t #f)
    (vector 1 infinity #t #f)
    (vector-ref 2 2 #t #f)
    (vector-length 1 1 #t #f)
    (vector-fill! 2 2 #t #f)
    (vector->list 1 1 #t #f)
    (list->vector 1 1 #t #f)
    (read 0 1 #t #f)
    (load 1 1 #t #f)
    (open-input-file 1 1 #t #t)
    (open-output-file 1 1 #t #t)
    (close-input-port 1 1 #t #t)
    (close-output-port 1 1 #t #t)
    (eof-object? 1 1 #t #f)
    (input-port? 1 1 #t #f)
    (output-port? 1 1 #t #f)
    (current-input-port 1 1 #t #f)
    (current-output-port 1 1 #t #f)
    (read-char 1 1 #t #f)
    (peek-char 1 1 #t #f)
    (char-ready? 1 1 #t #f)
    (exit 0 0 #t #t)
    (gensym 0 1 #t #f)
    (apply 2 infinity #t #t)
    (primitive-name? 1 1 #t #f)
    (macroexpand-1 1 1 #t #f)
    (macroexpand 1 1 #t #f)
    (addr 1 1 #t #f)
    (entity-addr 1 1 #t #f)
    (undefined 0 0 #t #f)
    (step 1 1 #t #t)
    (vm2-step 1 1 #t #t)
    (vm1 1 1 #t #t)
    (vm2 1 1 #t #t)
    (dump 1 2 #t #t)
    (addr-prt 1 1 #t #t)
    (gbc 0 1 #t #t)
    (room 0 0 #t #f)
    (vmcode 1 1 #t #f)
    (env 1 1 #t #f)
    (timer-set 0 0 #t #t)
    (timer-get 0 0 #t #t)
    (timer-gbc 0 0 #t #t)
    (eval 1 1 #t #f)
    (load 1 1 #t #t)
    (error 2 2 #t #t)
    (flush 0 1 #t #t)
    (set-trace 0 infinity #t #t)
    (set-untrace 0 infinity #t #t)
    (current-module 0 0 #t #f)
    (transfer 1 1 #t #f)
    (debug 1 1 #t #t)
    (profiler 1 1 #t #t)
    (lambda/asm 2 2 #t #f)
    (values 0 infinity #t #t)
    (sys-cont-room 1 1 #t #t)
    (make-syntactic-clousre 3 3 #t #t)
    (symbol->identifier 1 1 #t #f)
    (identifier->symbol 1 1 #t #f)
    (syntactic-closure? 1 1 #t #f)
    (identifier? 1 1 #t #f)
    (identifier-bind! 2 2 #t #t)
    (identifier-free? 1 1 #t #f)
    (identifier-bound? 1 1 #t #f)
    (identifier-bound 1 1 #t #f)
    (global-bound? 1 1 #t #f)
    (inspect 0 0 #t #t)
    ))

;;ƒRƒ“ƒpƒCƒ‹
(define (compile-file x)
  (let* ((inf (string-append x ".scm"))
         (outf (string-append x ".o"))
         (inp (open-input-file inf))
         (outp (open-output-file outf)))
    (compile-file1 (read inp) inp outp)
    (close-input-port inp)
    (close-output-port outp)
    (display "compiled!")(flush)))

(define (compile-file1 sexp inp outp)
  (cond ((eof-object? sexp) #t)
        (else (write (assemble (compile sexp)) outp)
              (newline outp)
              (compile-file1 (read inp) inp outp))))



;;Œp‘±
(define ncall/cc 
  (lambda/asm 1 '((args 1) (catch) (lvar 0 0) (call 1) (return))))

;;‘½’l
(define call-with-values
  (lambda/asm 2 '((args 2) (lvar 0 0) (call 0) (adapt) (lvar 0 1) (call 0) (return))))

;;dynamic-wind 
;;Kent dybvig p93 QÆ
(define winders '())

(define (dynamic-wind before body after)
  (before)
  (set! winders (cons (cons before after) winders))
  (let ((ans (body)))
    (set! winders (cdr winders))
    (after)
    ans))


(define (common-tail x y)
  (reverse (common-tail1 (reverse x) (reverse y))))

(define (common-tail1 x y)
  (cond ((null? x) '())
        ((null? y) '())
        ((not (eq? (car x)(car y))) '())
        (else (cons (car x) (common-tail1 (cdr x) (cdr y))))))

(define (do-wind new)
  (let ((tail (common-tail new winders)))
    (do-wind-after winders tail)
    (do-wind-before (reverse new) (reverse tail))
    (set! winders new)))

(define (do-wind-after old tail)
  (if (equal? old tail)
      #t
      (begin
        ((cdar old))
        (do-wind-after (cdr old) tail))))

(define (do-wind-before new tail)
  (cond ((and (null? new) (null? tail)) #t)
        ((null? tail) ((caar new))(do-wind-before (cdr new) tail))
        (else (do-wind-before (cdr new) (cdr tail)))))

(define (call/cc f)
  (ncall/cc
    (lambda (k)
      (f (let ((save winders))
           (lambda x
             (if (not (eq? save winders))
                 (do-wind save)
                 (undefined))
             (apply k x)))))))


(define call-with-current-continuation call/cc)

;;Hygienic macro


(define (match x y lits)
  (match1 x y lits '()))

(define (match1 x y lits vars)
  (cond ((and (null? x) (null? y)) vars)
        ((ellipsis? x) (match1 (cddr x)
                               (list-take-right y (length (cddr x)))
                               lits
                               (cons (cons (car x) (list-take y (- (length y) (length (cddr x))))) vars)))
        ((and (null? x) (not (null? y))) #f)
        ((and (identifier? x) (null? y)) (list (cons x y)))
        ((and (not (null? x)) (null? y)) #f)
        ((and (atom? (car x)) (memq (car x) lits) (not (eq? (car x) (car y)))) #f)
        ((atom? (car x)) (match1 (cdr x) (cdr y) lits (cons (cons (car x)(car y)) vars)))
        ((and (vec-ellipsis? (car x))(vector? (car y))) 
         (match1 (cdr x) (cdr y) lits (cons (cons (vector-ref (car x) 0) (vector->list (car y))) vars)))
        ((and (ellipsises? x) (= (length (car x)) (length (transpose y))))
         (let ((r (transpose y))) (append (list (cons (caar x) (car r))
                                                (cons (cadar x) (cadr r))) vars)))
        (else (let ((r1 (match1 (car x) (car y) lits vars))
                    (r2 (match1 (cdr x) (cdr y) lits vars)))
                (if (and r1 r2)
                    (append r1 r2)
                    #f)))))



;;—á((1 2)(3 4)(5 6)) -> ((1 3 5)(2 4 6)) 
(define (transpose ls) 
  (define (iter m n) 
    (if (= m n) 
        '() 
        (cons (map (lambda (x) (list-ref x m)) ls) 
              (iter (+ m 1) n)))) 
  (iter 0 (length (car ls)))) 

;;È—ªq
(define (ellipsis? x)
  (and (list? x)
       (>= (length x) 2)
       (or (identifier? (car x)) (symbol? (car x)))
       (eqv? (cadr x) '...)))

;;•¡‡È—ªq
(define (ellipsises? x)
  (and (list x)
       (>= (length x) 2)
       (list? (car x))
       (eqv? (cadr x) '...)))

;;ƒxƒNƒ^È—ªq
(define (vec-ellipsis? x)
  (and (vector? x)
       (symbol? (vector-ref x 0))
       (eq? (vector-ref x 1) '...)))


(define (list-take ls n)
  (if (= n 0)
      '()
      (cons (car ls) (list-take (cdr ls) (- n 1)))))

(define (list-take-right ls n)
  (list-drop ls (- (length ls) n)))

(define (list-drop ls n)
  (if (= n 0)
      ls
      (list-drop (cdr ls) (- n 1))))


(define (fail? x)
  (eq? x 'fail))

(define (subst-to-identifier x env)
  (cond ((null? x) '())
        ((and (symbol? x)
              (or (local-bound? x env) (global-bound? x) (eq? x 'else)))
         (identifier-bind! (symbol->identifier x) x))
        ((symbol? x)
         (symbol->identifier x))
        ((atom? x) x)
        ((vector? x) x)
        (else (cons (subst-to-identifier (car x) env)
                    (subst-to-identifier (cdr x) env)))))

(define (local-bound? x env)
  (cond ((null? env) #f)
        ((member x (car env)) #t)
        (else (local-bound? x (cdr env)))))

(define (subst-pattern-vars x pat)
  (cond ((null? x) '())
        ((and (identifier? x)(assv x pat))
         (identifier-bind! x (cdr (assv x pat))))
        ((atom? x) x)
        ((vector? x) x)
        (else (cons (subst-pattern-vars (car x) pat)
                    (subst-pattern-vars (cdr x) pat)))))



(define (subst-let-vars x)
  (subst-let-vars1 x (scan-let-vars x '())))

(define (subst-let-vars1 x a-list)
  (cond ((null? x) '())
        ((and (identifier? x)(identifier-free? x)(assv x a-list))
         (identifier-bind! x (cdr (assv x a-list))))
        ((atom? x) x)
        ((vector? x) x)
        (else (cons (subst-let-vars1 (car x) a-list)
                    (subst-let-vars1 (cdr x) a-list)))))


(define (scan-let-vars x v-list)
  (cond ((null? x) (map (lambda (x) (cons x (gensym))) v-list))
        ((atom? x) '())
        ((and (lambda? x)(atom? (cadr x)))
         (scan-let-vars (cddr x) (cons (cadr x) v-list)))
        ((and (lambda? x)(list? (cadr x))(not (null? (cadr x))))
         (scan-let-vars (cddr x) (append (cadr x) v-list)))
        ((and (lambda? x)(pair? (cadr x))(not (null? (cadr x))))
         (scan-let-vars (caddr x) (pair->list (cadr x))))
        ((and (let? x)(not (null? (cadr x)))) (scan-let-vars (cddr x) (car (transpose (cadr x)))))
        ((and (let*? x)(not (null? (cadr x)))) (scan-let-vars (cddr x) (car (transpose (cadr x)))))
        ((and (letrec? x)(not (null? (cadr x)))) (scan-let-vars (cddr x) (car (transpose (cadr x)))))
        ((and (named-let? x)(not (null? (caddr x))))
         (scan-let-vars (cdddr x) 
                        (append (car (transpose (caddr x))) 
                                (cons (cadr x) v-list))))
        (else (scan-let-vars (cdr x) v-list))))

(define (lambda? x)
  (and (list? x) (>= (length x) 3) (eqv? (car x) 'lambda)))

(define (let? x)
  (and (list? x) (>= (length x) 3) (eqv? (car x) 'let) (not (identifier? (cadr x)))))

(define (named-let? x)
  (and (list? x) (>= (length x) 4) (eqv? (car x) 'let) (identifier? (cadr x))))

(define (letrec? x)
  (and (list? x) (>= (length x) 3) (eqv? (car x) 'letrec)))

(define (let*? x)
  (and (list? x) (>= (length x) 3) (eqv? (car x) 'let*)))


(define (subst-from-identifier x)
  (cond ((null? x) '())
        ((identifier-free? x) x)
        ((identifier? x) (identifier-bound x))
        ((atom? x) x)
        ((vector? x) x)
        ((and (= (length x) 2)(ellipsis? x))
         (identifier-bound (car x)))
        ;;(x ...)
        ((and (> (length x) 2)(ellipsis? (list-take x 2)))
         (append (identifier-bound (car x))
                 (subst-from-identifier (cddr x))))
        ;;ex(x ... n)
        (else (cons (subst-from-identifier (car x))
                    (subst-from-identifier (cdr x))))))




(define (expand-template x vars comp-env)
  (subst-from-identifier
    (subst-let-vars
      (subst-pattern-vars
        (subst-to-identifier x comp-env)
        vars))))


(define (expand x y lits comp-env)
  (let* ((pat (caar x))
         (temp (cadar x))
         (vars (match pat y lits)))
    (cond (vars (expand-template temp vars comp-env))
          ((null? (cdr x)) (error "syntax-rules fail " y))
          (else (expand (cdr x) y lits comp-env)))))


;;Normal macros
;;Scheme macros written by M.hiroi modified for Normal by k.sasagawa
;;cond‚È‚Ç‚Ì§Œä\‘¢‚Íƒ}ƒNƒ‚Å—^‚¦‚ç‚ê‚éB
;;M.Hiroi‚³‚ñ‚Ìmicro Scheme‚Ì‚à‚Ì‚ğg‚í‚¹‚Ä‚¢‚½‚¾‚¢‚Ä‚¢‚Ü‚·B
;;Normal‚Ì‹N“®‚É“Ç‚İ‚Ü‚êƒRƒ“ƒpƒCƒ‹‚³‚ê‚éB

(define map 
  (lambda (f ls . more)
    ((lambda (map1 map-more)
       (set! map1 (lambda (ls)
                    (if (null? ls) 
                        (quote ()) 
                        (cons (f (car ls))
                              (map1 (cdr ls))))))
       (set! map-more (lambda (ls more)
                        (if (null? ls)
                            (quote ()) 
                            (cons (apply f (car ls) (map car more))
                                  (map-more (cdr ls) (map cdr more))))))
       (if (null? more)
           (map1 ls)
           (map-more ls more)))
      (undefined) (undefined))))

(define-macro and
  (lambda args
    (if (null? args)
        #t
        (if (null? (cdr args))
            (car args)
            `(if ,(car args) (and ,@(cdr args)) #f)))))

(define-macro or
  (lambda args
    (if (null? args)
        #f
        (if (null? (cdr args))
            (car args)
            `(if ,(car args) ,(car args) (or ,@(cdr args)))))))


(define-macro let
  (lambda (args . body)
    (if (null? args)
        `((lambda () ,@body))
        (if (pair? args)
            `((lambda ,(map car args) ,@body) ,@(map cadr args))
            ; named-let
            `(letrec ((,args (lambda ,(map car (car body)) ,@(cdr body))))
               (,args ,@(map cadr (car body))))))))


(define-macro let*
  (lambda (args . body)
    (if (null? args)
        `((lambda () ,@body))
        (if (null? (cdr args))
            `(let (,(car args)) ,@body)
            `(let (,(car args)) (let* ,(cdr args) ,@body))))))

(define-macro letrec
  (lambda (args . body)
    (let ((vars (map car args))
          (vals (map cadr args)))
      `(let ,(map (lambda (x) `(,x '*undef*)) vars)
            ,@(map (lambda (x y) `(set! ,x ,y)) vars vals)
            ,@body))))

(define-macro cond
  (lambda args
    (if (null? args)
        `(undefined)
        (if (null? (cdar args))
            `(let ((*val* ,(caar args)))
               (if *val* *val* (cond ,@(cdr args))))
            (if (eq? (cadar args) '=>)
            `(let ((*val* ,(caar args)))
               (if *val* (,(caddar args) *val*)))
                (if (eqv? (caar args) 'else)
                    (if (length=1? (cdar args))
                        (cadar args)
                        `(begin ,@(cdar args)))
                    (if (length=1? (cdar args))
                        `(if ,(caar args)
                           ,@(cdar args)
                           (cond ,@(cdr args)))
                        `(if ,(caar args)
                           (begin ,@(cdar args))
                           (cond ,@(cdr args))))))))))

(define-macro case
  (lambda (key . args)
    (if (null? args)
        `(undefined)
        (if (eq? (caar args) 'else)
            `(begin ,@(cdar args))
            `(if (memv ,key ',(caar args))
                 (begin ,@(cdar args))
                 (case ,key ,@(cdr args)))))))


(define-macro do
  (lambda (var-form test-form . args)
    (let ((vars (map car var-form))
          (vals (map cadr var-form))
          (step (map cddr var-form)))
      `(letrec ((loop (lambda ,vars
                        (if ,(car test-form)
                            (begin ,@(cdr test-form))
                          (begin
                            ,@args
                            (loop ,@(map (lambda (x y)
                                             (if (null? x) y (car x)))
                                           step
                                           vars)))))))
        (loop ,@vals)))))


;;kent dyvig p89
(define for-each
  (lambda (f ls . more)
    (do ((ls ls (cdr ls)) (more more (map cdr more)))
        ((null? ls))
        (apply f (car ls) (map car more)))
    (undefined)))(38 (normal system) ((import (normal compile) (scheme base) (scheme write)) (export pair-length last butlast sys-code sys-env sys-timer-set sys-timer-get sys-timer-gbc primitive-name? macroexpand-1 macroexpand addr entity-addr undefined step vm2-step vm1 vm2 dump addr-prt room macro-name? hygienic-name? gensym error flush sys-set-trace sys-set-untrace transfer debug profiler current-module sys-cont-room make-syntactic-closure symbol->identifier identifier->symbol syntactic-closure? identifier? identifier-bind! identifier-free? identifier-bound? identifier-bound global-bound? inspect lambda/asm)) 2 (normal system) 1)
(38 (normal compile) ((export compile assemble compile-file let let* cond letrec do case map)) 2 (normal compile) 1)
(38 (scheme base) ((import (normal system) (normal compile)) (export car cdr cons caar cdar cddr cadr caaar cdaar cadar caadr cddar caddr cdadr cdddr caaaar cdaaar cadaar caadar caaadr cddaar caddar caaddr cdaadr cdadar cadddr cdaddr cddadr cdddar cddddr assq assv assoc memq memv member reverse reverse! list-tail list-ref append append! set-car! set-cdr! list length newline write-char null? list? pair? atom? eq? eqv? equal? boolean? procedure? number? integer? real? rational? complex? exact? inexact? symbol? string? char? bignum? vector? macro? zero? + - * / < <= > >= = expt not odd? even? floor ceiling truncate round numerator denominator positive? negative? abs max min exact->inexact inexact->exact remainder modulo quotient gcd lcm string-append number->string string->number string=? string>? string>=? string<? string<=? string-ci=? string-ci>? string-ci>=? string-ci<? string-ci<=? string->symbol symbol->string string-length make-string string string-ref string-set! substring string->list list->string string-copy string-fill! make-vector vector-set! vector vector-ref vector-length vector-fill! vector->list list->vector open-input-file open-output-file close-input-port close-output-port eof-object? input-port? output-port? current-input-port current-output-port read-char peek-char char-ready? exit apply gbc eval values let let* cond letrec do case map for-each) (begin (define for-each (lambda (f ls . more) (do ((ls ls (cdr ls)) (more more (map cdr more))) ((null? ls)) (apply f (car ls) (map car more))) (undefined))))) 2 (scheme base) 1)
(38 (scheme inexact) ((export sin cos tan asin acos atan log exp sqrt)) 2 (scheme inexact) 1)
(38 (scheme complex) ((export real-part imag-part magnitude angle make-rectangular make-polar)) 2 (scheme complex) 1)
(38 (scheme load) ((export load)) 2 (scheme load) 1)
(38 (scheme read) ((export read)) 2 (scheme read) 1)
(38 (scheme write) ((export display write)) 2 (scheme write) 1)
(38 (scheme char) ((export char=? char>? char>=? char<? char<=? char-ci=? char-ci>? char-ci>=? char-ci<? char-ci<=? char-alphabetic? char-numeric? char-whitespace? char-upper-case? char-lower-case? char->integer integer->char char-upcase char-downcase)) 2 (scheme char) 1)
(38 (scheme lazy) ((export delay force) (import (scheme base)) (begin (define-macro delay (lambda (expr) (cons 'make-promise (cons (cons 'lambda (cons '() (cons expr '()))) '())))) (define make-promise (lambda (p) (let ((val #f) (set? #f)) (lambda () (if (not set?) (let ((x (p))) (if (not set?) (begin (set! val x) (set! set? #t)) '())) '()) val)))) (define force (lambda (x) (if (procedure? x) (x) x))))) 2 (scheme lazy) 1)
(38 (scheme time) ((import (normal system) (scheme base) (scheme write)) (export time) (begin (define-macro time (lambda (expr) (cons 'begin (cons (cons 'gbc '()) (cons (cons 'sys-timer-set '()) (cons (cons 'display (cons expr '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"total " '())) (cons (cons 'display (cons (cons 'sys-timer-get '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) (cons (cons 'display (cons '"GC    " '())) (cons (cons 'display (cons (cons 'sys-timer-gbc '()) '())) (cons (cons 'display (cons '" second" '())) (cons (cons 'newline '()) '()))))))))))))))))) 2 (scheme time) 1)
(38 (scheme file) ((export call-with-input-file call-with-output-file with-input-from-file with-output-to-file) (begin (define (call-with-input-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc p))) (close-input-port p) v))) (define (call-with-output-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc p))) (close-output-port p) v))) (define (with-input-from-file filename proc) (let ((p (open-input-file filename))) (let ((v (proc))) (close-input-port p) v))) (define (with-output-to-file filename proc) (let ((p (open-output-file filename))) (let ((v (proc))) (close-output-port p) v))))) 2 (scheme file) 1)
(40 ((scheme base)) 1)
(40 ((scheme load)) 1)
(40 ((scheme write)) 1)
(40 ((scheme read)) 1)

(define-library (normal system)
  (import (normal compile)
          (scheme base)
          (scheme write))
  (export
    pair-length
    last
    butlast
    sys-code
    sys-env
    sys-timer-set
    sys-timer-get
    sys-timer-gbc
    primitive-name?
    macroexpand-1
    macroexpand
    addr
    entity-addr
    undefined
    step
    vm2-step
    vm1
    vm2
    dump
    addr-prt
    room
    macro-name?
    hygienic-name?
    gensym
    error
    flush
    sys-set-trace
    sys-set-untrace
    transfer
    debug
    profiler
    current-module
    sys-cont-room
    make-syntactic-closure
    symbol->identifier
    identifier->symbol
    syntactic-closure?
    identifier?
    identifier-bind!
    identifier-free?
    identifier-bound?
    identifier-bound
    global-bound?
    inspect
    lambda/asm))
  
(define-library (normal compile)
  (export compile assemble compile-file let let* cond letrec do case
          map))

(define-library (scheme base)
  (import (normal system)
          (normal compile))
  (export
    car cdr cons caar cdar cddr cadr caaar cdaar cadar
    caadr
    cddar
    caddr
    cdadr
    cdddr
    caaaar
    cdaaar
    cadaar
    caadar
    caaadr
    cddaar
    caddar
    caaddr
    cdaadr
    cdadar
    cadddr
    cdaddr
    cddadr
    cdddar
    cddddr
    assq
    assv
    assoc
    memq
    memv
    member
    reverse
    reverse!
    list-tail
    list-ref
    append
    append!
    set-car!
    set-cdr!
    list
    length
    newline
    write-char
    null?
    list?
    pair?
    atom?
    eq?
    eqv?
    equal?
    boolean?
    procedure?
    number?
    integer?
    real?
    rational?
    complex?
    exact?
    inexact?
    symbol?
    string?
    char?
    bignum?
    vector?
    macro?
    zero?
    +
    -
    *
    /
    <
    <=
    >
    >=
    =
    expt
    not
    odd?
    even?
    floor
    ceiling
    truncate
    round
    numerator
    denominator
    positive?
    negative?
    abs
    max
    min
    exact->inexact
    inexact->exact
    remainder
    modulo
    quotient
    gcd
    lcm
    string-append
    number->string
    string->number
    string=?
    string>?
    string>=?
    string<?
    string<=?
    string-ci=?
    string-ci>?
    string-ci>=?
    string-ci<?
    string-ci<=?
    string->symbol
    symbol->string
    string-length
    make-string
    string
    string-ref
    string-set!
    substring
    string->list
    list->string
    string-copy
    string-fill!
    make-vector
    vector-set!
    vector
    vector-ref
    vector-length
    vector-fill!
    vector->list
    list->vector
    open-input-file
    open-output-file
    close-input-port
    close-output-port
    eof-object?
    input-port?
    output-port?
    current-input-port
    current-output-port
    read-char
    peek-char
    char-ready?
    exit
	apply
    gbc
    eval
    values
    let let* cond letrec do case map for-each)
  (begin
    ;;kent dyvig p89
    (define for-each
      (lambda (f ls . more)
        (do ((ls ls (cdr ls)) (more more (map cdr more)))
            ((null? ls))
            (apply f (car ls) (map car more)))
        (undefined))))
)



(define-library (scheme inexact)
  (export
    sin
    cos
    tan
    asin
    acos
    atan
    log
    exp
    sqrt))

(define-library (scheme complex)
  (export
    real-part
    imag-part
    magnitude
    angle
    make-rectangular
    make-polar))

(define-library (scheme load)
  (export load))

(define-library (scheme read)
  (export read))

(define-library (scheme write)
  (export display write))

(define-library (scheme char)
  (export
    char=?
    char>?
    char>=?
    char<?
    char<=?
    char-ci=?
    char-ci>?
    char-ci>=?
    char-ci<?
    char-ci<=?
    char-alphabetic?
	char-numeric?
    char-whitespace?
    char-upper-case?
    char-lower-case?
    char->integer
    integer->char
    char-upcase
    char-downcase))

(define-library (scheme lazy)
  (export delay force)
  (import (scheme base))
  (begin
    ;;; ;;’x‰„•]‰¿
    ;;; ;;Kent Dybvig p98
    (define-macro delay
      (lambda (expr)
        `(make-promise (lambda () ,expr))))
    
    (define make-promise
      (lambda (p)
        (let ((val #f) (set? #f))
          (lambda ()
            (if (not set?)
                (let ((x (p)))
                  (if (not set?)
                      (begin (set! val x)
                             (set! set? #t))
                      '()))
                '())
            val))))
    
    (define force
      (lambda (x)
        (if (procedure? x)
            (x)
            x)))))

(define-library (scheme time)
  (import (normal system)
          (scheme base)
          (scheme write))
  (export time)
  (begin
    (define-macro time
      (lambda (expr)
        `(begin (gbc)
                (sys-timer-set)
                (display ,expr)
                (newline)
                (display "total ")
                (display (sys-timer-get))
                (display " second")
                (newline)
                (display "GC    ")
                (display (sys-timer-gbc))
                (display " second")
                (newline))))))

(define-library (scheme file)
  (export call-with-input-file
          call-with-output-file
          with-input-from-file
          with-output-to-file)
  (begin
    ;;ƒtƒ@ƒCƒ‹
    (define (call-with-input-file filename proc)
      (let ((p (open-input-file filename)))
        (let ((v (proc p)))
          (close-input-port p)
          v)))
    
    (define (call-with-output-file filename proc)
      (let ((p (open-output-file filename)))
        (let ((v (proc p)))
          (close-output-port p)
          v)))
    
    (define (with-input-from-file filename proc)
      (let ((p (open-input-file filename)))
        (let ((v (proc)))
          (close-input-port p)
          v)))
    
    (define (with-output-to-file filename proc)
      (let ((p (open-output-file filename)))
        (let ((v (proc)))
          (close-output-port p)
          v)))
    ))


(import (scheme base))
(import (scheme load))
(import (scheme write))
(import (scheme read))


  